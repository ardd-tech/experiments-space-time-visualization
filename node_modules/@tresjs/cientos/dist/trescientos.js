/**
 * name: @tresjs/cientos
 * version: v3.8.0
 * (c) 2024
 * description: Collection of useful helpers and fully functional, ready-made abstractions for Tres
 * author: Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)
 */
var rl = Object.defineProperty;
var ol = (o, e, t) => e in o ? rl(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t;
var oe = (o, e, t) => (ol(o, typeof e != "symbol" ? e + "" : e, t), t);
import * as Ar from "three";
import { TrianglesDrawMode as al, TriangleFanDrawMode as Ni, TriangleStripDrawMode as ko, REVISION as rr, Color as Be, Vector3 as ee, CompressedTexture as ii, Texture as zn, MathUtils as We, RGBAFormat as Uo, DoubleSide as wn, BufferAttribute as pt, PropertyBinding as Yt, InterpolateDiscrete as Bo, Matrix4 as De, Scene as Xs, PlaneGeometry as Dt, ShaderMaterial as Xt, Uniform as Re, Mesh as ae, PerspectiveCamera as Mt, WebGLRenderer as ll, InterpolateLinear as or, NearestFilter as No, NearestMipmapNearestFilter as zo, NearestMipmapLinearFilter as Ho, LinearFilter as At, LinearMipmapNearestFilter as Go, LinearMipmapLinearFilter as ar, ClampToEdgeWrapping as Hn, RepeatWrapping as Gn, MirroredRepeatWrapping as jo, Triangle as cl, Object3D as St, Raycaster as Vo, Quaternion as He, Euler as _n, MeshBasicMaterial as Gt, LineBasicMaterial as qs, CylinderGeometry as xt, BoxGeometry as tn, BufferGeometry as rt, Float32BufferAttribute as it, Line as Ie, OctahedronGeometry as dn, TorusGeometry as xs, SphereGeometry as ul, EventDispatcher as Yo, Ray as hl, Plane as lr, MOUSE as on, TOUCH as Lt, OrthographicCamera as jt, Spherical as Ws, Vector2 as le, Loader as cs, LoaderUtils as Ft, FileLoader as Tn, SpotLight as Xo, PointLight as zi, DirectionalLight as Wo, MeshPhysicalMaterial as fn, InstancedMesh as fl, TextureLoader as cr, ImageBitmapLoader as dl, InterleavedBuffer as ur, InterleavedBufferAttribute as Vt, PointsMaterial as pl, Material as ri, MeshStandardMaterial as us, SkinnedMesh as $o, LineSegments as ml, LineLoop as gl, Points as Zo, Group as ns, Skeleton as Ko, AnimationClip as qo, Bone as Hi, FrontSide as yl, VectorKeyframeTrack as Qo, QuaternionKeyframeTrack as Gi, NumberKeyframeTrack as Jo, Box3 as hs, Sphere as Qs, Interpolant as vl, ExtrudeGeometry as _l, Vector4 as ht, Curve as xl, MeshPhongMaterial as oi, MeshLambertMaterial as wl, EquirectangularReflectionMapping as ji, AmbientLight as Tl, Uint16BufferAttribute as bl, Matrix3 as vn, ShapePath as nn, DataTextureLoader as El, HalfFloatType as un, FloatType as Gs, DataUtils as ws, ShapeUtils as Ml, Box2 as ea, Shape as Sl, Path as ai, BackSide as ta, AnimationMixer as Al, WebGLRenderTarget as bn, UniformsUtils as Js, AudioListener as Pl, Audio as Rl, AudioLoader as Cl, FramebufferTexture as Pr, RawShaderMaterial as li, AdditiveBlending as na, UnsignedByteType as Vi, DepthTexture as sa, CubeTextureLoader as Il, CubeReflectionMapping as Dl, ShapeGeometry as Ll, DefaultLoadingManager as Ts, VideoTexture as Ol, NoBlending as Fl, Camera as kl, DepthFormat as Ul, UnsignedShortType as Bl, InstancedBufferGeometry as Nl, InstancedInterleavedBuffer as Yi, WireframeGeometry as zl, UniformsLib as js, ShaderLib as Vs, Line3 as Hl, CatmullRomCurve3 as Gl, QuadraticBezierCurve3 as jl, MeshDepthMaterial as Vl, DataTexture as ia, UVMapping as Yl, IcosahedronGeometry as Xl, DirectionalLightHelper as Wl, PointLightHelper as $l, SpotLightHelper as Zl, HemisphereLightHelper as Kl, ArrowHelper as ql } from "three";
import { defineComponent as pe, toRefs as Fe, useSlots as ra, computed as Ne, shallowRef as xe, withAsyncContext as fs, toValue as Kt, watchEffect as ft, unref as z, openBlock as fe, createElementBlock as de, createCommentVNode as Wt, renderSlot as $e, ref as ue, shallowReactive as Ql, mergeProps as Ye, createElementVNode as Te, getCurrentScope as Jl, onScopeDispose as ec, onMounted as ds, nextTick as tc, getCurrentInstance as oa, watch as we, reactive as Xi, onUnmounted as ot, isReactive as nc, onBeforeUnmount as aa, Fragment as la, renderList as ca, normalizeProps as ua, guardReactiveProps as ha, useAttrs as fa, createBlock as sc, triggerRef as ic, isRef as Wi, createVNode as bs, render as rc } from "vue";
import { useTresContext as je, useRenderLoop as Ke, normalizeColor as ln, useLoader as rs, useLogger as ps, useTexture as $i, normalizeVectorFlexibleParam as oc } from "@tresjs/core";
import { Pane as ac } from "tweakpane";
function Rr(o, e) {
  if (e === al)
    return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), o;
  if (e === Ni || e === ko) {
    let t = o.getIndex();
    if (t === null) {
      const r = [], a = o.getAttribute("position");
      if (a !== void 0) {
        for (let l = 0; l < a.count; l++)
          r.push(l);
        o.setIndex(r), t = o.getIndex();
      } else
        return console.error(
          "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
        ), o;
    }
    const n = t.count - 2, s = [];
    if (t)
      if (e === Ni)
        for (let r = 1; r <= n; r++)
          s.push(t.getX(0)), s.push(t.getX(r)), s.push(t.getX(r + 1));
      else
        for (let r = 0; r < n; r++)
          r % 2 === 0 ? (s.push(t.getX(r)), s.push(t.getX(r + 1)), s.push(t.getX(r + 2))) : (s.push(t.getX(r + 2)), s.push(t.getX(r + 1)), s.push(t.getX(r)));
    s.length / 3 !== n && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const i = o.clone();
    return i.setIndex(s), i.clearGroups(), i;
  } else
    return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), o;
}
const da = parseInt(rr.replace(/\D+/g, ""));
var lc = Object.defineProperty, cc = (o, e, t) => e in o ? lc(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, uc = (o, e, t) => (cc(o, typeof e != "symbol" ? e + "" : e, t), t);
async function Cr(o) {
  const e = await o.arrayBuffer(), t = btoa(String.fromCharCode(...new Uint8Array(e)));
  return `data:${o.type || ""};base64,${t}`;
}
let Es, ci, Pn, Ms;
function ui(o, e = 1 / 0, t = null) {
  ci || (ci = new Dt(2, 2, 1, 1)), Pn || (Pn = new Xt({
    uniforms: { blitTexture: new Re(o) },
    vertexShader: (
      /* glsl */
      `
        varying vec2 vUv;
        void main(){
            vUv = uv;
            gl_Position = vec4(position.xy * 1.0,0.,.999999);
        }
      `
    ),
    fragmentShader: (
      /* glsl */
      `
          uniform sampler2D blitTexture; 
          varying vec2 vUv;

          void main(){ 
              gl_FragColor = vec4(vUv.xy, 0, 1);
              
              #ifdef IS_SRGB
              gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );
              #else
              gl_FragColor = texture2D( blitTexture, vUv);
              #endif
          }
      `
    )
  })), Pn.uniforms.blitTexture.value = o, Pn.defines.IS_SRGB = "colorSpace" in o ? o.colorSpace === "srgb" : o.encoding === 3001, Pn.needsUpdate = !0, Ms || (Ms = new ae(ci, Pn), Ms.frustrumCulled = !1);
  const n = new Mt(), s = new Xs();
  s.add(Ms), t || (t = Es = new ll({ antialias: !1 })), t.setSize(Math.min(o.image.width, e), Math.min(o.image.height, e)), t.clear(), t.render(s, n);
  const i = new zn(t.domElement);
  return i.minFilter = o.minFilter, i.magFilter = o.magFilter, i.wrapS = o.wrapS, i.wrapT = o.wrapT, i.name = o.name, Es && (Es.dispose(), Es = null), i;
}
const Ir = {
  POSITION: [
    "byte",
    "byte normalized",
    "unsigned byte",
    "unsigned byte normalized",
    "short",
    "short normalized",
    "unsigned short",
    "unsigned short normalized"
  ],
  NORMAL: ["byte normalized", "short normalized"],
  TANGENT: ["byte normalized", "short normalized"],
  TEXCOORD: ["byte", "byte normalized", "unsigned byte", "short", "short normalized", "unsigned short"]
};
class hr {
  constructor() {
    this.pluginCallbacks = [], this.register(function(e) {
      return new xc(e);
    }), this.register(function(e) {
      return new wc(e);
    }), this.register(function(e) {
      return new Ec(e);
    }), this.register(function(e) {
      return new Mc(e);
    }), this.register(function(e) {
      return new Sc(e);
    }), this.register(function(e) {
      return new Ac(e);
    }), this.register(function(e) {
      return new Tc(e);
    }), this.register(function(e) {
      return new bc(e);
    }), this.register(function(e) {
      return new Pc(e);
    }), this.register(function(e) {
      return new Rc(e);
    }), this.register(function(e) {
      return new Cc(e);
    });
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  /**
   * Parse scenes and generate GLTF output
   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
   * @param  {Function} onDone  Callback on completed
   * @param  {Function} onError  Callback on errors
   * @param  {Object} options options
   */
  parse(e, t, n, s) {
    const i = new _c(), r = [];
    for (let a = 0, l = this.pluginCallbacks.length; a < l; a++)
      r.push(this.pluginCallbacks[a](i));
    i.setPlugins(r), i.write(e, t, s).catch(n);
  }
  parseAsync(e, t) {
    const n = this;
    return new Promise(function(s, i) {
      n.parse(e, s, i, t);
    });
  }
}
uc(hr, "Utils", {
  insertKeyframe: function(o, e) {
    const n = o.getValueSize(), s = new o.TimeBufferType(o.times.length + 1), i = new o.ValueBufferType(o.values.length + n), r = o.createInterpolant(new o.ValueBufferType(n));
    let a;
    if (o.times.length === 0) {
      s[0] = e;
      for (let l = 0; l < n; l++)
        i[l] = 0;
      a = 0;
    } else if (e < o.times[0]) {
      if (Math.abs(o.times[0] - e) < 1e-3)
        return 0;
      s[0] = e, s.set(o.times, 1), i.set(r.evaluate(e), 0), i.set(o.values, n), a = 0;
    } else if (e > o.times[o.times.length - 1]) {
      if (Math.abs(o.times[o.times.length - 1] - e) < 1e-3)
        return o.times.length - 1;
      s[s.length - 1] = e, s.set(o.times, 0), i.set(o.values, 0), i.set(r.evaluate(e), o.values.length), a = s.length - 1;
    } else
      for (let l = 0; l < o.times.length; l++) {
        if (Math.abs(o.times[l] - e) < 1e-3)
          return l;
        if (o.times[l] < e && o.times[l + 1] > e) {
          s.set(o.times.slice(0, l + 1), 0), s[l + 1] = e, s.set(o.times.slice(l + 1), l + 2), i.set(o.values.slice(0, (l + 1) * n), 0), i.set(r.evaluate(e), (l + 1) * n), i.set(o.values.slice((l + 1) * n), (l + 2) * n), a = l + 1;
          break;
        }
      }
    return o.times = s, o.values = i, a;
  },
  mergeMorphTargetTracks: function(o, e) {
    const t = [], n = {}, s = o.tracks;
    for (let i = 0; i < s.length; ++i) {
      let r = s[i];
      const a = Yt.parseTrackName(r.name), l = Yt.findNode(e, a.nodeName);
      if (a.propertyName !== "morphTargetInfluences" || a.propertyIndex === void 0) {
        t.push(r);
        continue;
      }
      if (r.createInterpolant !== r.InterpolantFactoryMethodDiscrete && r.createInterpolant !== r.InterpolantFactoryMethodLinear) {
        if (r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)
          throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
        console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), r = r.clone(), r.setInterpolation(or);
      }
      const c = l.morphTargetInfluences.length, u = l.morphTargetDictionary[a.propertyIndex];
      if (u === void 0)
        throw new Error("THREE.GLTFExporter: Morph target name not found: " + a.propertyIndex);
      let h;
      if (n[l.uuid] === void 0) {
        h = r.clone();
        const p = new h.ValueBufferType(c * h.times.length);
        for (let v = 0; v < h.times.length; v++)
          p[v * c + u] = h.values[v];
        h.name = (a.nodeName || "") + ".morphTargetInfluences", h.values = p, n[l.uuid] = h, t.push(h);
        continue;
      }
      const m = r.createInterpolant(new r.ValueBufferType(1));
      h = n[l.uuid];
      for (let p = 0; p < h.times.length; p++)
        h.values[p * c + u] = m.evaluate(h.times[p]);
      for (let p = 0; p < r.times.length; p++) {
        const v = this.insertKeyframe(h, r.times[p]);
        h.values[v * c + u] = r.values[p];
      }
    }
    return o.tracks = t, o;
  }
});
const Pe = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  BYTE: 5120,
  UNSIGNED_BYTE: 5121,
  SHORT: 5122,
  UNSIGNED_SHORT: 5123,
  INT: 5124,
  UNSIGNED_INT: 5125,
  FLOAT: 5126,
  ARRAY_BUFFER: 34962,
  ELEMENT_ARRAY_BUFFER: 34963,
  NEAREST: 9728,
  LINEAR: 9729,
  NEAREST_MIPMAP_NEAREST: 9984,
  LINEAR_MIPMAP_NEAREST: 9985,
  NEAREST_MIPMAP_LINEAR: 9986,
  LINEAR_MIPMAP_LINEAR: 9987,
  CLAMP_TO_EDGE: 33071,
  MIRRORED_REPEAT: 33648,
  REPEAT: 10497
}, hi = "KHR_mesh_quantization", mt = {};
mt[No] = Pe.NEAREST;
mt[zo] = Pe.NEAREST_MIPMAP_NEAREST;
mt[Ho] = Pe.NEAREST_MIPMAP_LINEAR;
mt[At] = Pe.LINEAR;
mt[Go] = Pe.LINEAR_MIPMAP_NEAREST;
mt[ar] = Pe.LINEAR_MIPMAP_LINEAR;
mt[Hn] = Pe.CLAMP_TO_EDGE;
mt[Gn] = Pe.REPEAT;
mt[jo] = Pe.MIRRORED_REPEAT;
const Dr = {
  scale: "scale",
  position: "translation",
  quaternion: "rotation",
  morphTargetInfluences: "weights"
}, hc = new Be(), Lr = 12, fc = 1179937895, dc = 2, Or = 8, pc = 1313821514, mc = 5130562;
function ts(o, e) {
  return o.length === e.length && o.every(function(t, n) {
    return t === e[n];
  });
}
function gc(o) {
  return new TextEncoder().encode(o).buffer;
}
function yc(o) {
  return ts(o.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
}
function vc(o, e, t) {
  const n = {
    min: new Array(o.itemSize).fill(Number.POSITIVE_INFINITY),
    max: new Array(o.itemSize).fill(Number.NEGATIVE_INFINITY)
  };
  for (let s = e; s < e + t; s++)
    for (let i = 0; i < o.itemSize; i++) {
      let r;
      o.itemSize > 4 ? r = o.array[s * o.itemSize + i] : (i === 0 ? r = o.getX(s) : i === 1 ? r = o.getY(s) : i === 2 ? r = o.getZ(s) : i === 3 && (r = o.getW(s)), o.normalized === !0 && (r = We.normalize(r, o.array))), n.min[i] = Math.min(n.min[i], r), n.max[i] = Math.max(n.max[i], r);
    }
  return n;
}
function pa(o) {
  return Math.ceil(o / 4) * 4;
}
function fi(o, e = 0) {
  const t = pa(o.byteLength);
  if (t !== o.byteLength) {
    const n = new Uint8Array(t);
    if (n.set(new Uint8Array(o)), e !== 0)
      for (let s = o.byteLength; s < t; s++)
        n[s] = e;
    return n.buffer;
  }
  return o;
}
function Fr() {
  return typeof document > "u" && typeof OffscreenCanvas < "u" ? new OffscreenCanvas(1, 1) : document.createElement("canvas");
}
function kr(o, e) {
  if (o.toBlob !== void 0)
    return new Promise((n) => o.toBlob(n, e));
  let t;
  return e === "image/jpeg" ? t = 0.92 : e === "image/webp" && (t = 0.8), o.convertToBlob({
    type: e,
    quality: t
  });
}
class _c {
  constructor() {
    this.plugins = [], this.options = {}, this.pending = [], this.buffers = [], this.byteOffset = 0, this.buffers = [], this.nodeMap = /* @__PURE__ */ new Map(), this.skins = [], this.extensionsUsed = {}, this.extensionsRequired = {}, this.uids = /* @__PURE__ */ new Map(), this.uid = 0, this.json = {
      asset: {
        version: "2.0",
        generator: "THREE.GLTFExporter"
      }
    }, this.cache = {
      meshes: /* @__PURE__ */ new Map(),
      attributes: /* @__PURE__ */ new Map(),
      attributesNormalized: /* @__PURE__ */ new Map(),
      materials: /* @__PURE__ */ new Map(),
      textures: /* @__PURE__ */ new Map(),
      images: /* @__PURE__ */ new Map()
    };
  }
  setPlugins(e) {
    this.plugins = e;
  }
  /**
   * Parse scenes and generate GLTF output
   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
   * @param  {Function} onDone  Callback on completed
   * @param  {Object} options options
   */
  async write(e, t, n = {}) {
    this.options = Object.assign(
      {
        // default options
        binary: !1,
        trs: !1,
        onlyVisible: !0,
        maxTextureSize: 1 / 0,
        animations: [],
        includeCustomExtensions: !1
      },
      n
    ), this.options.animations.length > 0 && (this.options.trs = !0), this.processInput(e), await Promise.all(this.pending);
    const s = this, i = s.buffers, r = s.json;
    n = s.options;
    const a = s.extensionsUsed, l = s.extensionsRequired, c = new Blob(i, { type: "application/octet-stream" }), u = Object.keys(a), h = Object.keys(l);
    u.length > 0 && (r.extensionsUsed = u), h.length > 0 && (r.extensionsRequired = h), r.buffers && r.buffers.length > 0 && (r.buffers[0].byteLength = c.size), n.binary === !0 ? c.arrayBuffer().then((m) => {
      const p = fi(m), v = new DataView(new ArrayBuffer(Or));
      v.setUint32(0, p.byteLength, !0), v.setUint32(4, mc, !0);
      const _ = fi(gc(JSON.stringify(r)), 32), y = new DataView(new ArrayBuffer(Or));
      y.setUint32(0, _.byteLength, !0), y.setUint32(4, pc, !0);
      const E = new ArrayBuffer(Lr), R = new DataView(E);
      R.setUint32(0, fc, !0), R.setUint32(4, dc, !0);
      const T = Lr + y.byteLength + _.byteLength + v.byteLength + p.byteLength;
      R.setUint32(8, T, !0), new Blob([E, y, _, v, p], {
        type: "application/octet-stream"
      }).arrayBuffer().then(t);
    }) : r.buffers && r.buffers.length > 0 ? Cr(c).then((m) => {
      r.buffers[0].uri = m, t(r);
    }) : t(r);
  }
  /**
   * Serializes a userData.
   *
   * @param {THREE.Object3D|THREE.Material} object
   * @param {Object} objectDef
   */
  serializeUserData(e, t) {
    if (Object.keys(e.userData).length === 0)
      return;
    const n = this.options, s = this.extensionsUsed;
    try {
      const i = JSON.parse(JSON.stringify(e.userData));
      if (n.includeCustomExtensions && i.gltfExtensions) {
        t.extensions === void 0 && (t.extensions = {});
        for (const r in i.gltfExtensions)
          t.extensions[r] = i.gltfExtensions[r], s[r] = !0;
        delete i.gltfExtensions;
      }
      Object.keys(i).length > 0 && (t.extras = i);
    } catch (i) {
      console.warn(
        "THREE.GLTFExporter: userData of '" + e.name + "' won't be serialized because of JSON.stringify error - " + i.message
      );
    }
  }
  /**
   * Returns ids for buffer attributes.
   * @param  {Object} object
   * @return {Integer}
   */
  getUID(e, t = !1) {
    if (this.uids.has(e) === !1) {
      const s = /* @__PURE__ */ new Map();
      s.set(!0, this.uid++), s.set(!1, this.uid++), this.uids.set(e, s);
    }
    return this.uids.get(e).get(t);
  }
  /**
   * Checks if normal attribute values are normalized.
   *
   * @param {BufferAttribute} normal
   * @returns {Boolean}
   */
  isNormalizedNormalAttribute(e) {
    if (this.cache.attributesNormalized.has(e))
      return !1;
    const n = new ee();
    for (let s = 0, i = e.count; s < i; s++)
      if (Math.abs(n.fromBufferAttribute(e, s).length() - 1) > 5e-4)
        return !1;
    return !0;
  }
  /**
   * Creates normalized normal buffer attribute.
   *
   * @param {BufferAttribute} normal
   * @returns {BufferAttribute}
   *
   */
  createNormalizedNormalAttribute(e) {
    const t = this.cache;
    if (t.attributesNormalized.has(e))
      return t.attributesNormalized.get(e);
    const n = e.clone(), s = new ee();
    for (let i = 0, r = n.count; i < r; i++)
      s.fromBufferAttribute(n, i), s.x === 0 && s.y === 0 && s.z === 0 ? s.setX(1) : s.normalize(), n.setXYZ(i, s.x, s.y, s.z);
    return t.attributesNormalized.set(e, n), n;
  }
  /**
   * Applies a texture transform, if present, to the map definition. Requires
   * the KHR_texture_transform extension.
   *
   * @param {Object} mapDef
   * @param {THREE.Texture} texture
   */
  applyTextureTransform(e, t) {
    let n = !1;
    const s = {};
    (t.offset.x !== 0 || t.offset.y !== 0) && (s.offset = t.offset.toArray(), n = !0), t.rotation !== 0 && (s.rotation = t.rotation, n = !0), (t.repeat.x !== 1 || t.repeat.y !== 1) && (s.scale = t.repeat.toArray(), n = !0), n && (e.extensions = e.extensions || {}, e.extensions.KHR_texture_transform = s, this.extensionsUsed.KHR_texture_transform = !0);
  }
  buildMetalRoughTexture(e, t) {
    if (e === t)
      return e;
    function n(p) {
      return ("colorSpace" in p ? p.colorSpace === "srgb" : p.encoding === 3001) ? function(_) {
        return _ < 0.04045 ? _ * 0.0773993808 : Math.pow(_ * 0.9478672986 + 0.0521327014, 2.4);
      } : function(_) {
        return _;
      };
    }
    console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures."), e instanceof ii && (e = ui(e)), t instanceof ii && (t = ui(t));
    const s = e ? e.image : null, i = t ? t.image : null, r = Math.max(s ? s.width : 0, i ? i.width : 0), a = Math.max(s ? s.height : 0, i ? i.height : 0), l = Fr();
    l.width = r, l.height = a;
    const c = l.getContext("2d");
    c.fillStyle = "#00ffff", c.fillRect(0, 0, r, a);
    const u = c.getImageData(0, 0, r, a);
    if (s) {
      c.drawImage(s, 0, 0, r, a);
      const p = n(e), v = c.getImageData(0, 0, r, a).data;
      for (let _ = 2; _ < v.length; _ += 4)
        u.data[_] = p(v[_] / 256) * 256;
    }
    if (i) {
      c.drawImage(i, 0, 0, r, a);
      const p = n(t), v = c.getImageData(0, 0, r, a).data;
      for (let _ = 1; _ < v.length; _ += 4)
        u.data[_] = p(v[_] / 256) * 256;
    }
    c.putImageData(u, 0, 0);
    const m = (e || t).clone();
    return m.source = new zn(l).source, "colorSpace" in m ? m.colorSpace = "" : m.encoding = 3e3, m.channel = (e || t).channel, e && t && e.channel !== t.channel && console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match."), m;
  }
  /**
   * Process a buffer to append to the default one.
   * @param  {ArrayBuffer} buffer
   * @return {Integer}
   */
  processBuffer(e) {
    const t = this.json, n = this.buffers;
    return t.buffers || (t.buffers = [{ byteLength: 0 }]), n.push(e), 0;
  }
  /**
   * Process and generate a BufferView
   * @param  {BufferAttribute} attribute
   * @param  {number} componentType
   * @param  {number} start
   * @param  {number} count
   * @param  {number} target (Optional) Target usage of the BufferView
   * @return {Object}
   */
  processBufferView(e, t, n, s, i) {
    const r = this.json;
    r.bufferViews || (r.bufferViews = []);
    let a;
    switch (t) {
      case Pe.BYTE:
      case Pe.UNSIGNED_BYTE:
        a = 1;
        break;
      case Pe.SHORT:
      case Pe.UNSIGNED_SHORT:
        a = 2;
        break;
      default:
        a = 4;
    }
    const l = pa(s * e.itemSize * a), c = new DataView(new ArrayBuffer(l));
    let u = 0;
    for (let p = n; p < n + s; p++)
      for (let v = 0; v < e.itemSize; v++) {
        let _;
        e.itemSize > 4 ? _ = e.array[p * e.itemSize + v] : (v === 0 ? _ = e.getX(p) : v === 1 ? _ = e.getY(p) : v === 2 ? _ = e.getZ(p) : v === 3 && (_ = e.getW(p)), e.normalized === !0 && (_ = We.normalize(_, e.array))), t === Pe.FLOAT ? c.setFloat32(u, _, !0) : t === Pe.INT ? c.setInt32(u, _, !0) : t === Pe.UNSIGNED_INT ? c.setUint32(u, _, !0) : t === Pe.SHORT ? c.setInt16(u, _, !0) : t === Pe.UNSIGNED_SHORT ? c.setUint16(u, _, !0) : t === Pe.BYTE ? c.setInt8(u, _) : t === Pe.UNSIGNED_BYTE && c.setUint8(u, _), u += a;
      }
    const h = {
      buffer: this.processBuffer(c.buffer),
      byteOffset: this.byteOffset,
      byteLength: l
    };
    return i !== void 0 && (h.target = i), i === Pe.ARRAY_BUFFER && (h.byteStride = e.itemSize * a), this.byteOffset += l, r.bufferViews.push(h), {
      id: r.bufferViews.length - 1,
      byteLength: 0
    };
  }
  /**
   * Process and generate a BufferView from an image Blob.
   * @param {Blob} blob
   * @return {Promise<Integer>}
   */
  processBufferViewImage(e) {
    const t = this, n = t.json;
    return n.bufferViews || (n.bufferViews = []), e.arrayBuffer().then((s) => {
      const i = fi(s), r = {
        buffer: t.processBuffer(i),
        byteOffset: t.byteOffset,
        byteLength: i.byteLength
      };
      return t.byteOffset += i.byteLength, n.bufferViews.push(r) - 1;
    });
  }
  /**
   * Process attribute to generate an accessor
   * @param  {BufferAttribute} attribute Attribute to process
   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range
   * @param  {Integer} start (Optional)
   * @param  {Integer} count (Optional)
   * @return {Integer|null} Index of the processed accessor on the "accessors" array
   */
  processAccessor(e, t, n, s) {
    const i = this.json, r = {
      1: "SCALAR",
      2: "VEC2",
      3: "VEC3",
      4: "VEC4",
      9: "MAT3",
      16: "MAT4"
    };
    let a;
    if (e.array.constructor === Float32Array)
      a = Pe.FLOAT;
    else if (e.array.constructor === Int32Array)
      a = Pe.INT;
    else if (e.array.constructor === Uint32Array)
      a = Pe.UNSIGNED_INT;
    else if (e.array.constructor === Int16Array)
      a = Pe.SHORT;
    else if (e.array.constructor === Uint16Array)
      a = Pe.UNSIGNED_SHORT;
    else if (e.array.constructor === Int8Array)
      a = Pe.BYTE;
    else if (e.array.constructor === Uint8Array)
      a = Pe.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.GLTFExporter: Unsupported bufferAttribute component type: " + e.array.constructor.name
      );
    if (n === void 0 && (n = 0), s === void 0 && (s = e.count), s === 0)
      return null;
    const l = vc(e, n, s);
    let c;
    t !== void 0 && (c = e === t.index ? Pe.ELEMENT_ARRAY_BUFFER : Pe.ARRAY_BUFFER);
    const u = this.processBufferView(e, a, n, s, c), h = {
      bufferView: u.id,
      byteOffset: u.byteOffset,
      componentType: a,
      count: s,
      max: l.max,
      min: l.min,
      type: r[e.itemSize]
    };
    return e.normalized === !0 && (h.normalized = !0), i.accessors || (i.accessors = []), i.accessors.push(h) - 1;
  }
  /**
   * Process image
   * @param  {Image} image to process
   * @param  {Integer} format of the image (RGBAFormat)
   * @param  {Boolean} flipY before writing out the image
   * @param  {String} mimeType export format
   * @return {Integer}     Index of the processed texture in the "images" array
   */
  processImage(e, t, n, s = "image/png") {
    if (e !== null) {
      const i = this, r = i.cache, a = i.json, l = i.options, c = i.pending;
      r.images.has(e) || r.images.set(e, {});
      const u = r.images.get(e), h = s + ":flipY/" + n.toString();
      if (u[h] !== void 0)
        return u[h];
      a.images || (a.images = []);
      const m = { mimeType: s }, p = Fr();
      p.width = Math.min(e.width, l.maxTextureSize), p.height = Math.min(e.height, l.maxTextureSize);
      const v = p.getContext("2d");
      if (n === !0 && (v.translate(0, p.height), v.scale(1, -1)), e.data !== void 0) {
        t !== Uo && console.error("GLTFExporter: Only RGBAFormat is supported.", t), (e.width > l.maxTextureSize || e.height > l.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", e);
        const y = new Uint8ClampedArray(e.height * e.width * 4);
        for (let E = 0; E < y.length; E += 4)
          y[E + 0] = e.data[E + 0], y[E + 1] = e.data[E + 1], y[E + 2] = e.data[E + 2], y[E + 3] = e.data[E + 3];
        v.putImageData(new ImageData(y, e.width, e.height), 0, 0);
      } else
        v.drawImage(e, 0, 0, p.width, p.height);
      l.binary === !0 ? c.push(
        kr(p, s).then((y) => i.processBufferViewImage(y)).then((y) => {
          m.bufferView = y;
        })
      ) : p.toDataURL !== void 0 ? m.uri = p.toDataURL(s) : c.push(
        kr(p, s).then(Cr).then((y) => {
          m.uri = y;
        })
      );
      const _ = a.images.push(m) - 1;
      return u[h] = _, _;
    } else
      throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.");
  }
  /**
   * Process sampler
   * @param  {Texture} map Texture to process
   * @return {Integer}     Index of the processed texture in the "samplers" array
   */
  processSampler(e) {
    const t = this.json;
    t.samplers || (t.samplers = []);
    const n = {
      magFilter: mt[e.magFilter],
      minFilter: mt[e.minFilter],
      wrapS: mt[e.wrapS],
      wrapT: mt[e.wrapT]
    };
    return t.samplers.push(n) - 1;
  }
  /**
   * Process texture
   * @param  {Texture} map Map to process
   * @return {Integer} Index of the processed texture in the "textures" array
   */
  processTexture(e) {
    const n = this.options, s = this.cache, i = this.json;
    if (s.textures.has(e))
      return s.textures.get(e);
    i.textures || (i.textures = []), e instanceof ii && (e = ui(e, n.maxTextureSize));
    let r = e.userData.mimeType;
    r === "image/webp" && (r = "image/png");
    const a = {
      sampler: this.processSampler(e),
      source: this.processImage(e.image, e.format, e.flipY, r)
    };
    e.name && (a.name = e.name), this._invokeAll(function(c) {
      c.writeTexture && c.writeTexture(e, a);
    });
    const l = i.textures.push(a) - 1;
    return s.textures.set(e, l), l;
  }
  /**
   * Process material
   * @param  {THREE.Material} material Material to process
   * @return {Integer|null} Index of the processed material in the "materials" array
   */
  processMaterial(e) {
    const t = this.cache, n = this.json;
    if (t.materials.has(e))
      return t.materials.get(e);
    if (e.isShaderMaterial)
      return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."), null;
    n.materials || (n.materials = []);
    const s = { pbrMetallicRoughness: {} };
    e.isMeshStandardMaterial !== !0 && e.isMeshBasicMaterial !== !0 && console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
    const i = e.color.toArray().concat([e.opacity]);
    if (ts(i, [1, 1, 1, 1]) || (s.pbrMetallicRoughness.baseColorFactor = i), e.isMeshStandardMaterial ? (s.pbrMetallicRoughness.metallicFactor = e.metalness, s.pbrMetallicRoughness.roughnessFactor = e.roughness) : (s.pbrMetallicRoughness.metallicFactor = 0.5, s.pbrMetallicRoughness.roughnessFactor = 0.5), e.metalnessMap || e.roughnessMap) {
      const a = this.buildMetalRoughTexture(e.metalnessMap, e.roughnessMap), l = {
        index: this.processTexture(a),
        channel: a.channel
      };
      this.applyTextureTransform(l, a), s.pbrMetallicRoughness.metallicRoughnessTexture = l;
    }
    if (e.map) {
      const a = {
        index: this.processTexture(e.map),
        texCoord: e.map.channel
      };
      this.applyTextureTransform(a, e.map), s.pbrMetallicRoughness.baseColorTexture = a;
    }
    if (e.emissive) {
      const a = e.emissive;
      if (Math.max(a.r, a.g, a.b) > 0 && (s.emissiveFactor = e.emissive.toArray()), e.emissiveMap) {
        const c = {
          index: this.processTexture(e.emissiveMap),
          texCoord: e.emissiveMap.channel
        };
        this.applyTextureTransform(c, e.emissiveMap), s.emissiveTexture = c;
      }
    }
    if (e.normalMap) {
      const a = {
        index: this.processTexture(e.normalMap),
        texCoord: e.normalMap.channel
      };
      e.normalScale && e.normalScale.x !== 1 && (a.scale = e.normalScale.x), this.applyTextureTransform(a, e.normalMap), s.normalTexture = a;
    }
    if (e.aoMap) {
      const a = {
        index: this.processTexture(e.aoMap),
        texCoord: e.aoMap.channel
      };
      e.aoMapIntensity !== 1 && (a.strength = e.aoMapIntensity), this.applyTextureTransform(a, e.aoMap), s.occlusionTexture = a;
    }
    e.transparent ? s.alphaMode = "BLEND" : e.alphaTest > 0 && (s.alphaMode = "MASK", s.alphaCutoff = e.alphaTest), e.side === wn && (s.doubleSided = !0), e.name !== "" && (s.name = e.name), this.serializeUserData(e, s), this._invokeAll(function(a) {
      a.writeMaterial && a.writeMaterial(e, s);
    });
    const r = n.materials.push(s) - 1;
    return t.materials.set(e, r), r;
  }
  /**
   * Process mesh
   * @param  {THREE.Mesh} mesh Mesh to process
   * @return {Integer|null} Index of the processed mesh in the "meshes" array
   */
  processMesh(e) {
    const t = this.cache, n = this.json, s = [e.geometry.uuid];
    if (Array.isArray(e.material))
      for (let T = 0, g = e.material.length; T < g; T++)
        s.push(e.material[T].uuid);
    else
      s.push(e.material.uuid);
    const i = s.join(":");
    if (t.meshes.has(i))
      return t.meshes.get(i);
    const r = e.geometry;
    let a;
    e.isLineSegments ? a = Pe.LINES : e.isLineLoop ? a = Pe.LINE_LOOP : e.isLine ? a = Pe.LINE_STRIP : e.isPoints ? a = Pe.POINTS : a = e.material.wireframe ? Pe.LINES : Pe.TRIANGLES;
    const l = {}, c = {}, u = [], h = [], m = {
      ...da >= 152 ? {
        uv: "TEXCOORD_0",
        uv1: "TEXCOORD_1",
        uv2: "TEXCOORD_2",
        uv3: "TEXCOORD_3"
      } : {
        uv: "TEXCOORD_0",
        uv2: "TEXCOORD_1"
      },
      color: "COLOR_0",
      skinWeight: "WEIGHTS_0",
      skinIndex: "JOINTS_0"
    }, p = r.getAttribute("normal");
    p !== void 0 && !this.isNormalizedNormalAttribute(p) && (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), r.setAttribute("normal", this.createNormalizedNormalAttribute(p)));
    let v = null;
    for (let T in r.attributes) {
      if (T.slice(0, 5) === "morph")
        continue;
      const g = r.attributes[T];
      if (T = m[T] || T.toUpperCase(), /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(T) || (T = "_" + T), t.attributes.has(this.getUID(g))) {
        c[T] = t.attributes.get(this.getUID(g));
        continue;
      }
      v = null;
      const x = g.array;
      T === "JOINTS_0" && !(x instanceof Uint16Array) && !(x instanceof Uint8Array) && (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), v = new pt(new Uint16Array(x), g.itemSize, g.normalized));
      const M = this.processAccessor(v || g, r);
      M !== null && (T.startsWith("_") || this.detectMeshQuantization(T, g), c[T] = M, t.attributes.set(this.getUID(g), M));
    }
    if (p !== void 0 && r.setAttribute("normal", p), Object.keys(c).length === 0)
      return null;
    if (e.morphTargetInfluences !== void 0 && e.morphTargetInfluences.length > 0) {
      const T = [], g = [], A = {};
      if (e.morphTargetDictionary !== void 0)
        for (const x in e.morphTargetDictionary)
          A[e.morphTargetDictionary[x]] = x;
      for (let x = 0; x < e.morphTargetInfluences.length; ++x) {
        const M = {};
        let d = !1;
        for (const w in r.morphAttributes) {
          if (w !== "position" && w !== "normal") {
            d || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), d = !0);
            continue;
          }
          const f = r.morphAttributes[w][x], P = w.toUpperCase(), I = r.attributes[w];
          if (t.attributes.has(this.getUID(f, !0))) {
            M[P] = t.attributes.get(this.getUID(f, !0));
            continue;
          }
          const K = f.clone();
          if (!r.morphTargetsRelative)
            for (let N = 0, Z = f.count; N < Z; N++)
              for (let W = 0; W < f.itemSize; W++)
                W === 0 && K.setX(N, f.getX(N) - I.getX(N)), W === 1 && K.setY(N, f.getY(N) - I.getY(N)), W === 2 && K.setZ(N, f.getZ(N) - I.getZ(N)), W === 3 && K.setW(N, f.getW(N) - I.getW(N));
          M[P] = this.processAccessor(K, r), t.attributes.set(this.getUID(I, !0), M[P]);
        }
        h.push(M), T.push(e.morphTargetInfluences[x]), e.morphTargetDictionary !== void 0 && g.push(A[x]);
      }
      l.weights = T, g.length > 0 && (l.extras = {}, l.extras.targetNames = g);
    }
    const _ = Array.isArray(e.material);
    if (_ && r.groups.length === 0)
      return null;
    const y = _ ? e.material : [e.material], E = _ ? r.groups : [{ materialIndex: 0, start: void 0, count: void 0 }];
    for (let T = 0, g = E.length; T < g; T++) {
      const A = {
        mode: a,
        attributes: c
      };
      if (this.serializeUserData(r, A), h.length > 0 && (A.targets = h), r.index !== null) {
        let M = this.getUID(r.index);
        (E[T].start !== void 0 || E[T].count !== void 0) && (M += ":" + E[T].start + ":" + E[T].count), t.attributes.has(M) ? A.indices = t.attributes.get(M) : (A.indices = this.processAccessor(r.index, r, E[T].start, E[T].count), t.attributes.set(M, A.indices)), A.indices === null && delete A.indices;
      }
      const x = this.processMaterial(y[E[T].materialIndex]);
      x !== null && (A.material = x), u.push(A);
    }
    l.primitives = u, n.meshes || (n.meshes = []), this._invokeAll(function(T) {
      T.writeMesh && T.writeMesh(e, l);
    });
    const R = n.meshes.push(l) - 1;
    return t.meshes.set(i, R), R;
  }
  /**
   * If a vertex attribute with a
   * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)
   * is used, it is checked whether it is a valid data type according to the
   * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)
   * extension.
   * In this case the extension is automatically added to the list of used extensions.
   *
   * @param {string} attributeName
   * @param {THREE.BufferAttribute} attribute
   */
  detectMeshQuantization(e, t) {
    if (this.extensionsUsed[hi])
      return;
    let n;
    switch (t.array.constructor) {
      case Int8Array:
        n = "byte";
        break;
      case Uint8Array:
        n = "unsigned byte";
        break;
      case Int16Array:
        n = "short";
        break;
      case Uint16Array:
        n = "unsigned short";
        break;
      default:
        return;
    }
    t.normalized && (n += " normalized");
    const s = e.split("_", 1)[0];
    Ir[s] && Ir[s].includes(n) && (this.extensionsUsed[hi] = !0, this.extensionsRequired[hi] = !0);
  }
  /**
   * Process camera
   * @param  {THREE.Camera} camera Camera to process
   * @return {Integer}      Index of the processed mesh in the "camera" array
   */
  processCamera(e) {
    const t = this.json;
    t.cameras || (t.cameras = []);
    const n = e.isOrthographicCamera, s = {
      type: n ? "orthographic" : "perspective"
    };
    return n ? s.orthographic = {
      xmag: e.right * 2,
      ymag: e.top * 2,
      zfar: e.far <= 0 ? 1e-3 : e.far,
      znear: e.near < 0 ? 0 : e.near
    } : s.perspective = {
      aspectRatio: e.aspect,
      yfov: We.degToRad(e.fov),
      zfar: e.far <= 0 ? 1e-3 : e.far,
      znear: e.near < 0 ? 0 : e.near
    }, e.name !== "" && (s.name = e.type), t.cameras.push(s) - 1;
  }
  /**
   * Creates glTF animation entry from AnimationClip object.
   *
   * Status:
   * - Only properties listed in PATH_PROPERTIES may be animated.
   *
   * @param {THREE.AnimationClip} clip
   * @param {THREE.Object3D} root
   * @return {number|null}
   */
  processAnimation(e, t) {
    const n = this.json, s = this.nodeMap;
    n.animations || (n.animations = []), e = hr.Utils.mergeMorphTargetTracks(e.clone(), t);
    const i = e.tracks, r = [], a = [];
    for (let l = 0; l < i.length; ++l) {
      const c = i[l], u = Yt.parseTrackName(c.name);
      let h = Yt.findNode(t, u.nodeName);
      const m = Dr[u.propertyName];
      if (u.objectName === "bones" && (h.isSkinnedMesh === !0 ? h = h.skeleton.getBoneByName(u.objectIndex) : h = void 0), !h || !m)
        return console.warn('THREE.GLTFExporter: Could not export animation track "%s".', c.name), null;
      const p = 1;
      let v = c.values.length / c.times.length;
      m === Dr.morphTargetInfluences && (v /= h.morphTargetInfluences.length);
      let _;
      c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === !0 ? (_ = "CUBICSPLINE", v /= 3) : c.getInterpolation() === Bo ? _ = "STEP" : _ = "LINEAR", a.push({
        input: this.processAccessor(new pt(c.times, p)),
        output: this.processAccessor(new pt(c.values, v)),
        interpolation: _
      }), r.push({
        sampler: a.length - 1,
        target: {
          node: s.get(h),
          path: m
        }
      });
    }
    return n.animations.push({
      name: e.name || "clip_" + n.animations.length,
      samplers: a,
      channels: r
    }), n.animations.length - 1;
  }
  /**
   * @param {THREE.Object3D} object
   * @return {number|null}
   */
  processSkin(e) {
    const t = this.json, n = this.nodeMap, s = t.nodes[n.get(e)], i = e.skeleton;
    if (i === void 0)
      return null;
    const r = e.skeleton.bones[0];
    if (r === void 0)
      return null;
    const a = [], l = new Float32Array(i.bones.length * 16), c = new De();
    for (let h = 0; h < i.bones.length; ++h)
      a.push(n.get(i.bones[h])), c.copy(i.boneInverses[h]), c.multiply(e.bindMatrix).toArray(l, h * 16);
    return t.skins === void 0 && (t.skins = []), t.skins.push({
      inverseBindMatrices: this.processAccessor(new pt(l, 16)),
      joints: a,
      skeleton: n.get(r)
    }), s.skin = t.skins.length - 1;
  }
  /**
   * Process Object3D node
   * @param  {THREE.Object3D} node Object3D to processNode
   * @return {Integer} Index of the node in the nodes list
   */
  processNode(e) {
    const t = this.json, n = this.options, s = this.nodeMap;
    t.nodes || (t.nodes = []);
    const i = {};
    if (n.trs) {
      const a = e.quaternion.toArray(), l = e.position.toArray(), c = e.scale.toArray();
      ts(a, [0, 0, 0, 1]) || (i.rotation = a), ts(l, [0, 0, 0]) || (i.translation = l), ts(c, [1, 1, 1]) || (i.scale = c);
    } else
      e.matrixAutoUpdate && e.updateMatrix(), yc(e.matrix) === !1 && (i.matrix = e.matrix.elements);
    if (e.name !== "" && (i.name = String(e.name)), this.serializeUserData(e, i), e.isMesh || e.isLine || e.isPoints) {
      const a = this.processMesh(e);
      a !== null && (i.mesh = a);
    } else
      e.isCamera && (i.camera = this.processCamera(e));
    if (e.isSkinnedMesh && this.skins.push(e), e.children.length > 0) {
      const a = [];
      for (let l = 0, c = e.children.length; l < c; l++) {
        const u = e.children[l];
        if (u.visible || n.onlyVisible === !1) {
          const h = this.processNode(u);
          h !== null && a.push(h);
        }
      }
      a.length > 0 && (i.children = a);
    }
    this._invokeAll(function(a) {
      a.writeNode && a.writeNode(e, i);
    });
    const r = t.nodes.push(i) - 1;
    return s.set(e, r), r;
  }
  /**
   * Process Scene
   * @param  {Scene} node Scene to process
   */
  processScene(e) {
    const t = this.json, n = this.options;
    t.scenes || (t.scenes = [], t.scene = 0);
    const s = {};
    e.name !== "" && (s.name = e.name), t.scenes.push(s);
    const i = [];
    for (let r = 0, a = e.children.length; r < a; r++) {
      const l = e.children[r];
      if (l.visible || n.onlyVisible === !1) {
        const c = this.processNode(l);
        c !== null && i.push(c);
      }
    }
    i.length > 0 && (s.nodes = i), this.serializeUserData(e, s);
  }
  /**
   * Creates a Scene to hold a list of objects and parse it
   * @param  {Array} objects List of objects to process
   */
  processObjects(e) {
    const t = new Xs();
    t.name = "AuxScene";
    for (let n = 0; n < e.length; n++)
      t.children.push(e[n]);
    this.processScene(t);
  }
  /**
   * @param {THREE.Object3D|Array<THREE.Object3D>} input
   */
  processInput(e) {
    const t = this.options;
    e = e instanceof Array ? e : [e], this._invokeAll(function(s) {
      s.beforeParse && s.beforeParse(e);
    });
    const n = [];
    for (let s = 0; s < e.length; s++)
      e[s] instanceof Xs ? this.processScene(e[s]) : n.push(e[s]);
    n.length > 0 && this.processObjects(n);
    for (let s = 0; s < this.skins.length; ++s)
      this.processSkin(this.skins[s]);
    for (let s = 0; s < t.animations.length; ++s)
      this.processAnimation(t.animations[s], e[0]);
    this._invokeAll(function(s) {
      s.afterParse && s.afterParse(e);
    });
  }
  _invokeAll(e) {
    for (let t = 0, n = this.plugins.length; t < n; t++)
      e(this.plugins[t]);
  }
}
class xc {
  constructor(e) {
    this.writer = e, this.name = "KHR_lights_punctual";
  }
  writeNode(e, t) {
    if (!e.isLight)
      return;
    if (!e.isDirectionalLight && !e.isPointLight && !e.isSpotLight) {
      console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", e);
      return;
    }
    const n = this.writer, s = n.json, i = n.extensionsUsed, r = {};
    e.name && (r.name = e.name), r.color = e.color.toArray(), r.intensity = e.intensity, e.isDirectionalLight ? r.type = "directional" : e.isPointLight ? (r.type = "point", e.distance > 0 && (r.range = e.distance)) : e.isSpotLight && (r.type = "spot", e.distance > 0 && (r.range = e.distance), r.spot = {}, r.spot.innerConeAngle = (e.penumbra - 1) * e.angle * -1, r.spot.outerConeAngle = e.angle), e.decay !== void 0 && e.decay !== 2 && console.warn(
      "THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."
    ), e.target && (e.target.parent !== e || e.target.position.x !== 0 || e.target.position.y !== 0 || e.target.position.z !== -1) && console.warn(
      "THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."
    ), i[this.name] || (s.extensions = s.extensions || {}, s.extensions[this.name] = { lights: [] }, i[this.name] = !0);
    const a = s.extensions[this.name].lights;
    a.push(r), t.extensions = t.extensions || {}, t.extensions[this.name] = { light: a.length - 1 };
  }
}
let wc = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_unlit";
  }
  writeMaterial(e, t) {
    if (!e.isMeshBasicMaterial)
      return;
    const s = this.writer.extensionsUsed;
    t.extensions = t.extensions || {}, t.extensions[this.name] = {}, s[this.name] = !0, t.pbrMetallicRoughness.metallicFactor = 0, t.pbrMetallicRoughness.roughnessFactor = 0.9;
  }
}, Tc = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_clearcoat";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.clearcoat === 0)
      return;
    const n = this.writer, s = n.extensionsUsed, i = {};
    if (i.clearcoatFactor = e.clearcoat, e.clearcoatMap) {
      const r = {
        index: n.processTexture(e.clearcoatMap),
        texCoord: e.clearcoatMap.channel
      };
      n.applyTextureTransform(r, e.clearcoatMap), i.clearcoatTexture = r;
    }
    if (i.clearcoatRoughnessFactor = e.clearcoatRoughness, e.clearcoatRoughnessMap) {
      const r = {
        index: n.processTexture(e.clearcoatRoughnessMap),
        texCoord: e.clearcoatRoughnessMap.channel
      };
      n.applyTextureTransform(r, e.clearcoatRoughnessMap), i.clearcoatRoughnessTexture = r;
    }
    if (e.clearcoatNormalMap) {
      const r = {
        index: n.processTexture(e.clearcoatNormalMap),
        texCoord: e.clearcoatNormalMap.channel
      };
      n.applyTextureTransform(r, e.clearcoatNormalMap), i.clearcoatNormalTexture = r;
    }
    t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
}, bc = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_iridescence";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.iridescence === 0)
      return;
    const n = this.writer, s = n.extensionsUsed, i = {};
    if (i.iridescenceFactor = e.iridescence, e.iridescenceMap) {
      const r = {
        index: n.processTexture(e.iridescenceMap),
        texCoord: e.iridescenceMap.channel
      };
      n.applyTextureTransform(r, e.iridescenceMap), i.iridescenceTexture = r;
    }
    if (i.iridescenceIor = e.iridescenceIOR, i.iridescenceThicknessMinimum = e.iridescenceThicknessRange[0], i.iridescenceThicknessMaximum = e.iridescenceThicknessRange[1], e.iridescenceThicknessMap) {
      const r = {
        index: n.processTexture(e.iridescenceThicknessMap),
        texCoord: e.iridescenceThicknessMap.channel
      };
      n.applyTextureTransform(r, e.iridescenceThicknessMap), i.iridescenceThicknessTexture = r;
    }
    t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
}, Ec = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_transmission";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.transmission === 0)
      return;
    const n = this.writer, s = n.extensionsUsed, i = {};
    if (i.transmissionFactor = e.transmission, e.transmissionMap) {
      const r = {
        index: n.processTexture(e.transmissionMap),
        texCoord: e.transmissionMap.channel
      };
      n.applyTextureTransform(r, e.transmissionMap), i.transmissionTexture = r;
    }
    t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
}, Mc = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_volume";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.transmission === 0)
      return;
    const n = this.writer, s = n.extensionsUsed, i = {};
    if (i.thicknessFactor = e.thickness, e.thicknessMap) {
      const r = {
        index: n.processTexture(e.thicknessMap),
        texCoord: e.thicknessMap.channel
      };
      n.applyTextureTransform(r, e.thicknessMap), i.thicknessTexture = r;
    }
    i.attenuationDistance = e.attenuationDistance, i.attenuationColor = e.attenuationColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
}, Sc = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_ior";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.ior === 1.5)
      return;
    const s = this.writer.extensionsUsed, i = {};
    i.ior = e.ior, t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
}, Ac = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_specular";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.specularIntensity === 1 && e.specularColor.equals(hc) && !e.specularIntensityMap && !e.specularColorTexture)
      return;
    const n = this.writer, s = n.extensionsUsed, i = {};
    if (e.specularIntensityMap) {
      const r = {
        index: n.processTexture(e.specularIntensityMap),
        texCoord: e.specularIntensityMap.channel
      };
      n.applyTextureTransform(r, e.specularIntensityMap), i.specularTexture = r;
    }
    if (e.specularColorMap) {
      const r = {
        index: n.processTexture(e.specularColorMap),
        texCoord: e.specularColorMap.channel
      };
      n.applyTextureTransform(r, e.specularColorMap), i.specularColorTexture = r;
    }
    i.specularFactor = e.specularIntensity, i.specularColorFactor = e.specularColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
}, Pc = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_sheen";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.sheen == 0)
      return;
    const n = this.writer, s = n.extensionsUsed, i = {};
    if (e.sheenRoughnessMap) {
      const r = {
        index: n.processTexture(e.sheenRoughnessMap),
        texCoord: e.sheenRoughnessMap.channel
      };
      n.applyTextureTransform(r, e.sheenRoughnessMap), i.sheenRoughnessTexture = r;
    }
    if (e.sheenColorMap) {
      const r = {
        index: n.processTexture(e.sheenColorMap),
        texCoord: e.sheenColorMap.channel
      };
      n.applyTextureTransform(r, e.sheenColorMap), i.sheenColorTexture = r;
    }
    i.sheenRoughnessFactor = e.sheenRoughness, i.sheenColorFactor = e.sheenColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
}, Rc = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_anisotropy";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.anisotropy == 0)
      return;
    const n = this.writer, s = n.extensionsUsed, i = {};
    if (e.anisotropyMap) {
      const r = { index: n.processTexture(e.anisotropyMap) };
      n.applyTextureTransform(r, e.anisotropyMap), i.anisotropyTexture = r;
    }
    i.anisotropyStrength = e.anisotropy, i.anisotropyRotation = e.anisotropyRotation, t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
}, Cc = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_emissive_strength";
  }
  writeMaterial(e, t) {
    if (!e.isMeshStandardMaterial || e.emissiveIntensity === 1)
      return;
    const s = this.writer.extensionsUsed, i = {};
    i.emissiveStrength = e.emissiveIntensity, t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
};
var _t = Uint8Array, hn = Uint16Array, Zi = Uint32Array, ma = new _t([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), ga = new _t([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), Ic = new _t([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), ya = function(o, e) {
  for (var t = new hn(31), n = 0; n < 31; ++n)
    t[n] = e += 1 << o[n - 1];
  for (var s = new Zi(t[30]), n = 1; n < 30; ++n)
    for (var i = t[n]; i < t[n + 1]; ++i)
      s[i] = i - t[n] << 5 | n;
  return [t, s];
}, va = ya(ma, 2), _a = va[0], Dc = va[1];
_a[28] = 258, Dc[258] = 28;
var Lc = ya(ga, 0), Oc = Lc[0], Ki = new hn(32768);
for (var Ge = 0; Ge < 32768; ++Ge) {
  var qt = (Ge & 43690) >>> 1 | (Ge & 21845) << 1;
  qt = (qt & 52428) >>> 2 | (qt & 13107) << 2, qt = (qt & 61680) >>> 4 | (qt & 3855) << 4, Ki[Ge] = ((qt & 65280) >>> 8 | (qt & 255) << 8) >>> 1;
}
var ss = function(o, e, t) {
  for (var n = o.length, s = 0, i = new hn(e); s < n; ++s)
    ++i[o[s] - 1];
  var r = new hn(e);
  for (s = 0; s < e; ++s)
    r[s] = r[s - 1] + i[s - 1] << 1;
  var a;
  if (t) {
    a = new hn(1 << e);
    var l = 15 - e;
    for (s = 0; s < n; ++s)
      if (o[s])
        for (var c = s << 4 | o[s], u = e - o[s], h = r[o[s] - 1]++ << u, m = h | (1 << u) - 1; h <= m; ++h)
          a[Ki[h] >>> l] = c;
  } else
    for (a = new hn(n), s = 0; s < n; ++s)
      o[s] && (a[s] = Ki[r[o[s] - 1]++] >>> 15 - o[s]);
  return a;
}, ms = new _t(288);
for (var Ge = 0; Ge < 144; ++Ge)
  ms[Ge] = 8;
for (var Ge = 144; Ge < 256; ++Ge)
  ms[Ge] = 9;
for (var Ge = 256; Ge < 280; ++Ge)
  ms[Ge] = 7;
for (var Ge = 280; Ge < 288; ++Ge)
  ms[Ge] = 8;
var xa = new _t(32);
for (var Ge = 0; Ge < 32; ++Ge)
  xa[Ge] = 5;
var Fc = /* @__PURE__ */ ss(ms, 9, 1), kc = /* @__PURE__ */ ss(xa, 5, 1), di = function(o) {
  for (var e = o[0], t = 1; t < o.length; ++t)
    o[t] > e && (e = o[t]);
  return e;
}, wt = function(o, e, t) {
  var n = e / 8 | 0;
  return (o[n] | o[n + 1] << 8) >> (e & 7) & t;
}, pi = function(o, e) {
  var t = e / 8 | 0;
  return (o[t] | o[t + 1] << 8 | o[t + 2] << 16) >> (e & 7);
}, Uc = function(o) {
  return (o / 8 | 0) + (o & 7 && 1);
}, Bc = function(o, e, t) {
  (e == null || e < 0) && (e = 0), (t == null || t > o.length) && (t = o.length);
  var n = new (o instanceof hn ? hn : o instanceof Zi ? Zi : _t)(t - e);
  return n.set(o.subarray(e, t)), n;
}, Nc = function(o, e, t) {
  var n = o.length;
  if (!n || t && !t.l && n < 5)
    return e || new _t(0);
  var s = !e || t, i = !t || t.i;
  t || (t = {}), e || (e = new _t(n * 3));
  var r = function(J) {
    var F = e.length;
    if (J > F) {
      var B = new _t(Math.max(F * 2, J));
      B.set(e), e = B;
    }
  }, a = t.f || 0, l = t.p || 0, c = t.b || 0, u = t.l, h = t.d, m = t.m, p = t.n, v = n * 8;
  do {
    if (!u) {
      t.f = a = wt(o, l, 1);
      var _ = wt(o, l + 1, 3);
      if (l += 3, _)
        if (_ == 1)
          u = Fc, h = kc, m = 9, p = 5;
        else if (_ == 2) {
          var T = wt(o, l, 31) + 257, g = wt(o, l + 10, 15) + 4, A = T + wt(o, l + 5, 31) + 1;
          l += 14;
          for (var x = new _t(A), M = new _t(19), d = 0; d < g; ++d)
            M[Ic[d]] = wt(o, l + d * 3, 7);
          l += g * 3;
          for (var w = di(M), f = (1 << w) - 1, P = ss(M, w, 1), d = 0; d < A; ) {
            var I = P[wt(o, l, f)];
            l += I & 15;
            var y = I >>> 4;
            if (y < 16)
              x[d++] = y;
            else {
              var K = 0, N = 0;
              for (y == 16 ? (N = 3 + wt(o, l, 3), l += 2, K = x[d - 1]) : y == 17 ? (N = 3 + wt(o, l, 7), l += 3) : y == 18 && (N = 11 + wt(o, l, 127), l += 7); N--; )
                x[d++] = K;
            }
          }
          var Z = x.subarray(0, T), W = x.subarray(T);
          m = di(Z), p = di(W), u = ss(Z, m, 1), h = ss(W, p, 1);
        } else
          throw "invalid block type";
      else {
        var y = Uc(l) + 4, E = o[y - 4] | o[y - 3] << 8, R = y + E;
        if (R > n) {
          if (i)
            throw "unexpected EOF";
          break;
        }
        s && r(c + E), e.set(o.subarray(y, R), c), t.b = c += E, t.p = l = R * 8;
        continue;
      }
      if (l > v) {
        if (i)
          throw "unexpected EOF";
        break;
      }
    }
    s && r(c + 131072);
    for (var X = (1 << m) - 1, V = (1 << p) - 1, ne = l; ; ne = l) {
      var K = u[pi(o, l) & X], se = K >>> 4;
      if (l += K & 15, l > v) {
        if (i)
          throw "unexpected EOF";
        break;
      }
      if (!K)
        throw "invalid length/literal";
      if (se < 256)
        e[c++] = se;
      else if (se == 256) {
        ne = l, u = null;
        break;
      } else {
        var he = se - 254;
        if (se > 264) {
          var d = se - 257, H = ma[d];
          he = wt(o, l, (1 << H) - 1) + _a[d], l += H;
        }
        var k = h[pi(o, l) & V], b = k >>> 4;
        if (!k)
          throw "invalid distance";
        l += k & 15;
        var W = Oc[b];
        if (b > 3) {
          var H = ga[b];
          W += pi(o, l) & (1 << H) - 1, l += H;
        }
        if (l > v) {
          if (i)
            throw "unexpected EOF";
          break;
        }
        s && r(c + 131072);
        for (var U = c + he; c < U; c += 4)
          e[c] = e[c - W], e[c + 1] = e[c + 1 - W], e[c + 2] = e[c + 2 - W], e[c + 3] = e[c + 3 - W];
        c = U;
      }
    }
    t.l = u, t.p = ne, t.b = c, u && (a = 1, t.m = m, t.d = h, t.n = p);
  } while (!a);
  return c == e.length ? e : Bc(e, 0, c);
}, zc = /* @__PURE__ */ new _t(0), Hc = function(o) {
  if ((o[0] & 15) != 8 || o[0] >>> 4 > 7 || (o[0] << 8 | o[1]) % 31)
    throw "invalid zlib data";
  if (o[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function Gc(o, e) {
  return Nc((Hc(o), o.subarray(2, -4)), e);
}
var jc = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), Vc = 0;
try {
  jc.decode(zc, { stream: !0 }), Vc = 1;
} catch {
}
const Je = new cl(), Ss = new ee();
class Yc {
  constructor(e) {
    let t = e.geometry;
    t.index && (console.warn("THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry."), t = t.toNonIndexed()), this.geometry = t, this.randomFunction = Math.random, this.positionAttribute = this.geometry.getAttribute("position"), this.colorAttribute = this.geometry.getAttribute("color"), this.weightAttribute = null, this.distribution = null;
  }
  setWeightAttribute(e) {
    return this.weightAttribute = e ? this.geometry.getAttribute(e) : null, this;
  }
  build() {
    const e = this.positionAttribute, t = this.weightAttribute, n = new Float32Array(e.count / 3);
    for (let i = 0; i < e.count; i += 3) {
      let r = 1;
      t && (r = t.getX(i) + t.getX(i + 1) + t.getX(i + 2)), Je.a.fromBufferAttribute(e, i), Je.b.fromBufferAttribute(e, i + 1), Je.c.fromBufferAttribute(e, i + 2), r *= Je.getArea(), n[i / 3] = r;
    }
    this.distribution = new Float32Array(e.count / 3);
    let s = 0;
    for (let i = 0; i < n.length; i++)
      s += n[i], this.distribution[i] = s;
    return this;
  }
  setRandomGenerator(e) {
    return this.randomFunction = e, this;
  }
  sample(e, t, n) {
    const s = this.sampleFaceIndex();
    return this.sampleFace(s, e, t, n);
  }
  sampleFaceIndex() {
    const e = this.distribution[this.distribution.length - 1];
    return this.binarySearch(this.randomFunction() * e);
  }
  binarySearch(e) {
    const t = this.distribution;
    let n = 0, s = t.length - 1, i = -1;
    for (; n <= s; ) {
      const r = Math.ceil((n + s) / 2);
      if (r === 0 || t[r - 1] <= e && t[r] > e) {
        i = r;
        break;
      } else
        e < t[r] ? s = r - 1 : n = r + 1;
    }
    return i;
  }
  sampleFace(e, t, n, s) {
    let i = this.randomFunction(), r = this.randomFunction();
    return i + r > 1 && (i = 1 - i, r = 1 - r), Je.a.fromBufferAttribute(this.positionAttribute, e * 3), Je.b.fromBufferAttribute(this.positionAttribute, e * 3 + 1), Je.c.fromBufferAttribute(this.positionAttribute, e * 3 + 2), t.set(0, 0, 0).addScaledVector(Je.a, i).addScaledVector(Je.b, r).addScaledVector(Je.c, 1 - (i + r)), n !== void 0 && Je.getNormal(n), s !== void 0 && this.colorAttribute !== void 0 && (Je.a.fromBufferAttribute(this.colorAttribute, e * 3), Je.b.fromBufferAttribute(this.colorAttribute, e * 3 + 1), Je.c.fromBufferAttribute(this.colorAttribute, e * 3 + 2), Ss.set(0, 0, 0).addScaledVector(Je.a, i).addScaledVector(Je.b, r).addScaledVector(Je.c, 1 - (i + r)), s.r = Ss.x, s.g = Ss.y, s.b = Ss.z), this;
  }
}
var Xc = Object.defineProperty, Wc = (o, e, t) => e in o ? Xc(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, q = (o, e, t) => (Wc(o, typeof e != "symbol" ? e + "" : e, t), t);
class $c extends St {
  constructor(e, t) {
    super(), q(this, "isTransformControls", !0), q(this, "visible", !1), q(this, "domElement"), q(this, "raycaster", new Vo()), q(this, "gizmo"), q(this, "plane"), q(this, "tempVector", new ee()), q(this, "tempVector2", new ee()), q(this, "tempQuaternion", new He()), q(this, "unit", {
      X: new ee(1, 0, 0),
      Y: new ee(0, 1, 0),
      Z: new ee(0, 0, 1)
    }), q(this, "pointStart", new ee()), q(this, "pointEnd", new ee()), q(this, "offset", new ee()), q(this, "rotationAxis", new ee()), q(this, "startNorm", new ee()), q(this, "endNorm", new ee()), q(this, "rotationAngle", 0), q(this, "cameraPosition", new ee()), q(this, "cameraQuaternion", new He()), q(this, "cameraScale", new ee()), q(this, "parentPosition", new ee()), q(this, "parentQuaternion", new He()), q(this, "parentQuaternionInv", new He()), q(this, "parentScale", new ee()), q(this, "worldPositionStart", new ee()), q(this, "worldQuaternionStart", new He()), q(this, "worldScaleStart", new ee()), q(this, "worldPosition", new ee()), q(this, "worldQuaternion", new He()), q(this, "worldQuaternionInv", new He()), q(this, "worldScale", new ee()), q(this, "eye", new ee()), q(this, "positionStart", new ee()), q(this, "quaternionStart", new He()), q(this, "scaleStart", new ee()), q(this, "camera"), q(this, "object"), q(this, "enabled", !0), q(this, "axis", null), q(this, "mode", "translate"), q(this, "translationSnap", null), q(this, "rotationSnap", null), q(this, "scaleSnap", null), q(this, "space", "world"), q(this, "size", 1), q(this, "dragging", !1), q(this, "showX", !0), q(this, "showY", !0), q(this, "showZ", !0), q(this, "changeEvent", { type: "change" }), q(this, "mouseDownEvent", { type: "mouseDown", mode: this.mode }), q(this, "mouseUpEvent", { type: "mouseUp", mode: this.mode }), q(this, "objectChangeEvent", { type: "objectChange" }), q(this, "intersectObjectWithRay", (s, i, r) => {
      const a = i.intersectObject(s, !0);
      for (let l = 0; l < a.length; l++)
        if (a[l].object.visible || r)
          return a[l];
      return !1;
    }), q(this, "attach", (s) => (this.object = s, this.visible = !0, this)), q(this, "detach", () => (this.object = void 0, this.visible = !1, this.axis = null, this)), q(this, "reset", () => this.enabled ? (this.dragging && this.object !== void 0 && (this.object.position.copy(this.positionStart), this.object.quaternion.copy(this.quaternionStart), this.object.scale.copy(this.scaleStart), this.dispatchEvent(this.changeEvent), this.dispatchEvent(this.objectChangeEvent), this.pointStart.copy(this.pointEnd)), this) : this), q(this, "updateMatrixWorld", () => {
      this.object !== void 0 && (this.object.updateMatrixWorld(), this.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this.parentPosition, this.parentQuaternion, this.parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this.worldScale), this.parentQuaternionInv.copy(this.parentQuaternion).invert(), this.worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this.cameraScale), this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld();
    }), q(this, "pointerHover", (s) => {
      if (this.object === void 0 || this.dragging === !0)
        return;
      this.raycaster.setFromCamera(s, this.camera);
      const i = this.intersectObjectWithRay(this.gizmo.picker[this.mode], this.raycaster);
      i ? this.axis = i.object.name : this.axis = null;
    }), q(this, "pointerDown", (s) => {
      if (!(this.object === void 0 || this.dragging === !0 || s.button !== 0) && this.axis !== null) {
        this.raycaster.setFromCamera(s, this.camera);
        const i = this.intersectObjectWithRay(this.plane, this.raycaster, !0);
        if (i) {
          let r = this.space;
          if (this.mode === "scale" ? r = "local" : (this.axis === "E" || this.axis === "XYZE" || this.axis === "XYZ") && (r = "world"), r === "local" && this.mode === "rotate") {
            const a = this.rotationSnap;
            this.axis === "X" && a && (this.object.rotation.x = Math.round(this.object.rotation.x / a) * a), this.axis === "Y" && a && (this.object.rotation.y = Math.round(this.object.rotation.y / a) * a), this.axis === "Z" && a && (this.object.rotation.z = Math.round(this.object.rotation.z / a) * a);
          }
          this.object.updateMatrixWorld(), this.object.parent && this.object.parent.updateMatrixWorld(), this.positionStart.copy(this.object.position), this.quaternionStart.copy(this.object.quaternion), this.scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this.worldScaleStart), this.pointStart.copy(i.point).sub(this.worldPositionStart);
        }
        this.dragging = !0, this.mouseDownEvent.mode = this.mode, this.dispatchEvent(this.mouseDownEvent);
      }
    }), q(this, "pointerMove", (s) => {
      const i = this.axis, r = this.mode, a = this.object;
      let l = this.space;
      if (r === "scale" ? l = "local" : (i === "E" || i === "XYZE" || i === "XYZ") && (l = "world"), a === void 0 || i === null || this.dragging === !1 || s.button !== -1)
        return;
      this.raycaster.setFromCamera(s, this.camera);
      const c = this.intersectObjectWithRay(this.plane, this.raycaster, !0);
      if (c) {
        if (this.pointEnd.copy(c.point).sub(this.worldPositionStart), r === "translate")
          this.offset.copy(this.pointEnd).sub(this.pointStart), l === "local" && i !== "XYZ" && this.offset.applyQuaternion(this.worldQuaternionInv), i.indexOf("X") === -1 && (this.offset.x = 0), i.indexOf("Y") === -1 && (this.offset.y = 0), i.indexOf("Z") === -1 && (this.offset.z = 0), l === "local" && i !== "XYZ" ? this.offset.applyQuaternion(this.quaternionStart).divide(this.parentScale) : this.offset.applyQuaternion(this.parentQuaternionInv).divide(this.parentScale), a.position.copy(this.offset).add(this.positionStart), this.translationSnap && (l === "local" && (a.position.applyQuaternion(this.tempQuaternion.copy(this.quaternionStart).invert()), i.search("X") !== -1 && (a.position.x = Math.round(a.position.x / this.translationSnap) * this.translationSnap), i.search("Y") !== -1 && (a.position.y = Math.round(a.position.y / this.translationSnap) * this.translationSnap), i.search("Z") !== -1 && (a.position.z = Math.round(a.position.z / this.translationSnap) * this.translationSnap), a.position.applyQuaternion(this.quaternionStart)), l === "world" && (a.parent && a.position.add(this.tempVector.setFromMatrixPosition(a.parent.matrixWorld)), i.search("X") !== -1 && (a.position.x = Math.round(a.position.x / this.translationSnap) * this.translationSnap), i.search("Y") !== -1 && (a.position.y = Math.round(a.position.y / this.translationSnap) * this.translationSnap), i.search("Z") !== -1 && (a.position.z = Math.round(a.position.z / this.translationSnap) * this.translationSnap), a.parent && a.position.sub(this.tempVector.setFromMatrixPosition(a.parent.matrixWorld))));
        else if (r === "scale") {
          if (i.search("XYZ") !== -1) {
            let u = this.pointEnd.length() / this.pointStart.length();
            this.pointEnd.dot(this.pointStart) < 0 && (u *= -1), this.tempVector2.set(u, u, u);
          } else
            this.tempVector.copy(this.pointStart), this.tempVector2.copy(this.pointEnd), this.tempVector.applyQuaternion(this.worldQuaternionInv), this.tempVector2.applyQuaternion(this.worldQuaternionInv), this.tempVector2.divide(this.tempVector), i.search("X") === -1 && (this.tempVector2.x = 1), i.search("Y") === -1 && (this.tempVector2.y = 1), i.search("Z") === -1 && (this.tempVector2.z = 1);
          a.scale.copy(this.scaleStart).multiply(this.tempVector2), this.scaleSnap && this.object && (i.search("X") !== -1 && (this.object.scale.x = Math.round(a.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), i.search("Y") !== -1 && (a.scale.y = Math.round(a.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), i.search("Z") !== -1 && (a.scale.z = Math.round(a.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
        } else if (r === "rotate") {
          this.offset.copy(this.pointEnd).sub(this.pointStart);
          const u = 20 / this.worldPosition.distanceTo(this.tempVector.setFromMatrixPosition(this.camera.matrixWorld));
          i === "E" ? (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this.startNorm.copy(this.pointStart).normalize(), this.endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this.endNorm.cross(this.startNorm).dot(this.eye) < 0 ? 1 : -1) : i === "XYZE" ? (this.rotationAxis.copy(this.offset).cross(this.eye).normalize(), this.rotationAngle = this.offset.dot(this.tempVector.copy(this.rotationAxis).cross(this.eye)) * u) : (i === "X" || i === "Y" || i === "Z") && (this.rotationAxis.copy(this.unit[i]), this.tempVector.copy(this.unit[i]), l === "local" && this.tempVector.applyQuaternion(this.worldQuaternion), this.rotationAngle = this.offset.dot(this.tempVector.cross(this.eye).normalize()) * u), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), l === "local" && i !== "E" && i !== "XYZE" ? (a.quaternion.copy(this.quaternionStart), a.quaternion.multiply(this.tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this.parentQuaternionInv), a.quaternion.copy(this.tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), a.quaternion.multiply(this.quaternionStart).normalize());
        }
        this.dispatchEvent(this.changeEvent), this.dispatchEvent(this.objectChangeEvent);
      }
    }), q(this, "pointerUp", (s) => {
      s.button === 0 && (this.dragging && this.axis !== null && (this.mouseUpEvent.mode = this.mode, this.dispatchEvent(this.mouseUpEvent)), this.dragging = !1, this.axis = null);
    }), q(this, "getPointer", (s) => {
      var i;
      if (this.domElement && ((i = this.domElement.ownerDocument) != null && i.pointerLockElement))
        return {
          x: 0,
          y: 0,
          button: s.button
        };
      {
        const r = s.changedTouches ? s.changedTouches[0] : s, a = this.domElement.getBoundingClientRect();
        return {
          x: (r.clientX - a.left) / a.width * 2 - 1,
          y: -(r.clientY - a.top) / a.height * 2 + 1,
          button: s.button
        };
      }
    }), q(this, "onPointerHover", (s) => {
      if (this.enabled)
        switch (s.pointerType) {
          case "mouse":
          case "pen":
            this.pointerHover(this.getPointer(s));
            break;
        }
    }), q(this, "onPointerDown", (s) => {
      !this.enabled || !this.domElement || (this.domElement.style.touchAction = "none", this.domElement.ownerDocument.addEventListener("pointermove", this.onPointerMove), this.pointerHover(this.getPointer(s)), this.pointerDown(this.getPointer(s)));
    }), q(this, "onPointerMove", (s) => {
      this.enabled && this.pointerMove(this.getPointer(s));
    }), q(this, "onPointerUp", (s) => {
      !this.enabled || !this.domElement || (this.domElement.style.touchAction = "", this.domElement.ownerDocument.removeEventListener("pointermove", this.onPointerMove), this.pointerUp(this.getPointer(s)));
    }), q(this, "getMode", () => this.mode), q(this, "setMode", (s) => {
      this.mode = s;
    }), q(this, "setTranslationSnap", (s) => {
      this.translationSnap = s;
    }), q(this, "setRotationSnap", (s) => {
      this.rotationSnap = s;
    }), q(this, "setScaleSnap", (s) => {
      this.scaleSnap = s;
    }), q(this, "setSize", (s) => {
      this.size = s;
    }), q(this, "setSpace", (s) => {
      this.space = s;
    }), q(this, "update", () => {
      console.warn(
        "THREE.TransformControls: update function has no more functionality and therefore has been deprecated."
      );
    }), q(this, "connect", (s) => {
      s === document && console.error(
        'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
      ), this.domElement = s, this.domElement.addEventListener("pointerdown", this.onPointerDown), this.domElement.addEventListener("pointermove", this.onPointerHover), this.domElement.ownerDocument.addEventListener("pointerup", this.onPointerUp);
    }), q(this, "dispose", () => {
      var s, i, r, a, l, c;
      (s = this.domElement) == null || s.removeEventListener("pointerdown", this.onPointerDown), (i = this.domElement) == null || i.removeEventListener("pointermove", this.onPointerHover), (a = (r = this.domElement) == null ? void 0 : r.ownerDocument) == null || a.removeEventListener("pointermove", this.onPointerMove), (c = (l = this.domElement) == null ? void 0 : l.ownerDocument) == null || c.removeEventListener("pointerup", this.onPointerUp), this.traverse((u) => {
        const h = u;
        h.geometry && h.geometry.dispose(), h.material && h.material.dispose();
      });
    }), this.domElement = t, this.camera = e, this.gizmo = new Zc(), this.add(this.gizmo), this.plane = new Kc(), this.add(this.plane);
    const n = (s, i) => {
      let r = i;
      Object.defineProperty(this, s, {
        get: function() {
          return r !== void 0 ? r : i;
        },
        set: function(a) {
          r !== a && (r = a, this.plane[s] = a, this.gizmo[s] = a, this.dispatchEvent({ type: s + "-changed", value: a }), this.dispatchEvent(this.changeEvent));
        }
      }), this[s] = i, this.plane[s] = i, this.gizmo[s] = i;
    };
    n("camera", this.camera), n("object", this.object), n("enabled", this.enabled), n("axis", this.axis), n("mode", this.mode), n("translationSnap", this.translationSnap), n("rotationSnap", this.rotationSnap), n("scaleSnap", this.scaleSnap), n("space", this.space), n("size", this.size), n("dragging", this.dragging), n("showX", this.showX), n("showY", this.showY), n("showZ", this.showZ), n("worldPosition", this.worldPosition), n("worldPositionStart", this.worldPositionStart), n("worldQuaternion", this.worldQuaternion), n("worldQuaternionStart", this.worldQuaternionStart), n("cameraPosition", this.cameraPosition), n("cameraQuaternion", this.cameraQuaternion), n("pointStart", this.pointStart), n("pointEnd", this.pointEnd), n("rotationAxis", this.rotationAxis), n("rotationAngle", this.rotationAngle), n("eye", this.eye), t !== void 0 && this.connect(t);
  }
}
class Zc extends St {
  constructor() {
    super(), q(this, "isTransformControlsGizmo", !0), q(this, "type", "TransformControlsGizmo"), q(this, "tempVector", new ee(0, 0, 0)), q(this, "tempEuler", new _n()), q(this, "alignVector", new ee(0, 1, 0)), q(this, "zeroVector", new ee(0, 0, 0)), q(this, "lookAtMatrix", new De()), q(this, "tempQuaternion", new He()), q(this, "tempQuaternion2", new He()), q(this, "identityQuaternion", new He()), q(this, "unitX", new ee(1, 0, 0)), q(this, "unitY", new ee(0, 1, 0)), q(this, "unitZ", new ee(0, 0, 1)), q(this, "gizmo"), q(this, "picker"), q(this, "helper"), q(this, "rotationAxis", new ee()), q(this, "cameraPosition", new ee()), q(this, "worldPositionStart", new ee()), q(this, "worldQuaternionStart", new He()), q(this, "worldPosition", new ee()), q(this, "worldQuaternion", new He()), q(this, "eye", new ee()), q(this, "camera", null), q(this, "enabled", !0), q(this, "axis", null), q(this, "mode", "translate"), q(this, "space", "world"), q(this, "size", 1), q(this, "dragging", !1), q(this, "showX", !0), q(this, "showY", !0), q(this, "showZ", !0), q(this, "updateMatrixWorld", () => {
      let se = this.space;
      this.mode === "scale" && (se = "local");
      const he = se === "local" ? this.worldQuaternion : this.identityQuaternion;
      this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
      let H = [];
      H = H.concat(this.picker[this.mode].children), H = H.concat(this.gizmo[this.mode].children), H = H.concat(this.helper[this.mode].children);
      for (let k = 0; k < H.length; k++) {
        const b = H[k];
        b.visible = !0, b.rotation.set(0, 0, 0), b.position.copy(this.worldPosition);
        let U;
        if (this.camera.isOrthographicCamera ? U = (this.camera.top - this.camera.bottom) / this.camera.zoom : U = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), b.scale.set(1, 1, 1).multiplyScalar(U * this.size / 7), b.tag === "helper") {
          b.visible = !1, b.name === "AXIS" ? (b.position.copy(this.worldPositionStart), b.visible = !!this.axis, this.axis === "X" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, 0, 0)), b.quaternion.copy(he).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(he).dot(this.eye)) > 0.9 && (b.visible = !1)), this.axis === "Y" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, 0, Math.PI / 2)), b.quaternion.copy(he).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(he).dot(this.eye)) > 0.9 && (b.visible = !1)), this.axis === "Z" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, Math.PI / 2, 0)), b.quaternion.copy(he).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(he).dot(this.eye)) > 0.9 && (b.visible = !1)), this.axis === "XYZE" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, Math.PI / 2, 0)), this.alignVector.copy(this.rotationAxis), b.quaternion.setFromRotationMatrix(
            this.lookAtMatrix.lookAt(this.zeroVector, this.alignVector, this.unitY)
          ), b.quaternion.multiply(this.tempQuaternion), b.visible = this.dragging), this.axis === "E" && (b.visible = !1)) : b.name === "START" ? (b.position.copy(this.worldPositionStart), b.visible = this.dragging) : b.name === "END" ? (b.position.copy(this.worldPosition), b.visible = this.dragging) : b.name === "DELTA" ? (b.position.copy(this.worldPositionStart), b.quaternion.copy(this.worldQuaternionStart), this.tempVector.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), this.tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert()), b.scale.copy(this.tempVector), b.visible = this.dragging) : (b.quaternion.copy(he), this.dragging ? b.position.copy(this.worldPositionStart) : b.position.copy(this.worldPosition), this.axis && (b.visible = this.axis.search(b.name) !== -1));
          continue;
        }
        b.quaternion.copy(he), this.mode === "translate" || this.mode === "scale" ? ((b.name === "X" || b.name === "XYZX") && Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(he).dot(this.eye)) > 0.99 && (b.scale.set(1e-10, 1e-10, 1e-10), b.visible = !1), (b.name === "Y" || b.name === "XYZY") && Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(he).dot(this.eye)) > 0.99 && (b.scale.set(1e-10, 1e-10, 1e-10), b.visible = !1), (b.name === "Z" || b.name === "XYZZ") && Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(he).dot(this.eye)) > 0.99 && (b.scale.set(1e-10, 1e-10, 1e-10), b.visible = !1), b.name === "XY" && Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(he).dot(this.eye)) < 0.2 && (b.scale.set(1e-10, 1e-10, 1e-10), b.visible = !1), b.name === "YZ" && Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(he).dot(this.eye)) < 0.2 && (b.scale.set(1e-10, 1e-10, 1e-10), b.visible = !1), b.name === "XZ" && Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(he).dot(this.eye)) < 0.2 && (b.scale.set(1e-10, 1e-10, 1e-10), b.visible = !1), b.name.search("X") !== -1 && (this.alignVector.copy(this.unitX).applyQuaternion(he).dot(this.eye) < 0 ? b.tag === "fwd" ? b.visible = !1 : b.scale.x *= -1 : b.tag === "bwd" && (b.visible = !1)), b.name.search("Y") !== -1 && (this.alignVector.copy(this.unitY).applyQuaternion(he).dot(this.eye) < 0 ? b.tag === "fwd" ? b.visible = !1 : b.scale.y *= -1 : b.tag === "bwd" && (b.visible = !1)), b.name.search("Z") !== -1 && (this.alignVector.copy(this.unitZ).applyQuaternion(he).dot(this.eye) < 0 ? b.tag === "fwd" ? b.visible = !1 : b.scale.z *= -1 : b.tag === "bwd" && (b.visible = !1))) : this.mode === "rotate" && (this.tempQuaternion2.copy(he), this.alignVector.copy(this.eye).applyQuaternion(this.tempQuaternion.copy(he).invert()), b.name.search("E") !== -1 && b.quaternion.setFromRotationMatrix(this.lookAtMatrix.lookAt(this.eye, this.zeroVector, this.unitY)), b.name === "X" && (this.tempQuaternion.setFromAxisAngle(this.unitX, Math.atan2(-this.alignVector.y, this.alignVector.z)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), b.quaternion.copy(this.tempQuaternion)), b.name === "Y" && (this.tempQuaternion.setFromAxisAngle(this.unitY, Math.atan2(this.alignVector.x, this.alignVector.z)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), b.quaternion.copy(this.tempQuaternion)), b.name === "Z" && (this.tempQuaternion.setFromAxisAngle(this.unitZ, Math.atan2(this.alignVector.y, this.alignVector.x)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), b.quaternion.copy(this.tempQuaternion))), b.visible = b.visible && (b.name.indexOf("X") === -1 || this.showX), b.visible = b.visible && (b.name.indexOf("Y") === -1 || this.showY), b.visible = b.visible && (b.name.indexOf("Z") === -1 || this.showZ), b.visible = b.visible && (b.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), b.material.tempOpacity = b.material.tempOpacity || b.material.opacity, b.material.tempColor = b.material.tempColor || b.material.color.clone(), b.material.color.copy(b.material.tempColor), b.material.opacity = b.material.tempOpacity, this.enabled ? this.axis && (b.name === this.axis ? (b.material.opacity = 1, b.material.color.lerp(new Be(1, 1, 1), 0.5)) : this.axis.split("").some(function(J) {
          return b.name === J;
        }) ? (b.material.opacity = 1, b.material.color.lerp(new Be(1, 1, 1), 0.5)) : (b.material.opacity *= 0.25, b.material.color.lerp(new Be(1, 1, 1), 0.5))) : (b.material.opacity *= 0.5, b.material.color.lerp(new Be(1, 1, 1), 0.5));
      }
      super.updateMatrixWorld();
    });
    const e = new Gt({
      depthTest: !1,
      depthWrite: !1,
      transparent: !0,
      side: wn,
      fog: !1,
      toneMapped: !1
    }), t = new qs({
      depthTest: !1,
      depthWrite: !1,
      transparent: !0,
      linewidth: 1,
      fog: !1,
      toneMapped: !1
    }), n = e.clone();
    n.opacity = 0.15;
    const s = e.clone();
    s.opacity = 0.33;
    const i = e.clone();
    i.color.set(16711680);
    const r = e.clone();
    r.color.set(65280);
    const a = e.clone();
    a.color.set(255);
    const l = e.clone();
    l.opacity = 0.25;
    const c = l.clone();
    c.color.set(16776960);
    const u = l.clone();
    u.color.set(65535);
    const h = l.clone();
    h.color.set(16711935), e.clone().color.set(16776960);
    const p = t.clone();
    p.color.set(16711680);
    const v = t.clone();
    v.color.set(65280);
    const _ = t.clone();
    _.color.set(255);
    const y = t.clone();
    y.color.set(65535);
    const E = t.clone();
    E.color.set(16711935);
    const R = t.clone();
    R.color.set(16776960);
    const T = t.clone();
    T.color.set(7895160);
    const g = R.clone();
    g.opacity = 0.25;
    const A = new xt(0, 0.05, 0.2, 12, 1, !1), x = new tn(0.125, 0.125, 0.125), M = new rt();
    M.setAttribute("position", new it([0, 0, 0, 1, 0, 0], 3));
    const d = (se, he) => {
      const H = new rt(), k = [];
      for (let b = 0; b <= 64 * he; ++b)
        k.push(0, Math.cos(b / 32 * Math.PI) * se, Math.sin(b / 32 * Math.PI) * se);
      return H.setAttribute("position", new it(k, 3)), H;
    }, w = () => {
      const se = new rt();
      return se.setAttribute("position", new it([0, 0, 0, 1, 1, 1], 3)), se;
    }, f = {
      X: [
        [new ae(A, i), [1, 0, 0], [0, 0, -Math.PI / 2], null, "fwd"],
        [new ae(A, i), [1, 0, 0], [0, 0, Math.PI / 2], null, "bwd"],
        [new Ie(M, p)]
      ],
      Y: [
        [new ae(A, r), [0, 1, 0], null, null, "fwd"],
        [new ae(A, r), [0, 1, 0], [Math.PI, 0, 0], null, "bwd"],
        [new Ie(M, v), null, [0, 0, Math.PI / 2]]
      ],
      Z: [
        [new ae(A, a), [0, 0, 1], [Math.PI / 2, 0, 0], null, "fwd"],
        [new ae(A, a), [0, 0, 1], [-Math.PI / 2, 0, 0], null, "bwd"],
        [new Ie(M, _), null, [0, -Math.PI / 2, 0]]
      ],
      XYZ: [[new ae(new dn(0.1, 0), l.clone()), [0, 0, 0], [0, 0, 0]]],
      XY: [
        [new ae(new Dt(0.295, 0.295), c.clone()), [0.15, 0.15, 0]],
        [new Ie(M, R), [0.18, 0.3, 0], null, [0.125, 1, 1]],
        [new Ie(M, R), [0.3, 0.18, 0], [0, 0, Math.PI / 2], [0.125, 1, 1]]
      ],
      YZ: [
        [new ae(new Dt(0.295, 0.295), u.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]],
        [new Ie(M, y), [0, 0.18, 0.3], [0, 0, Math.PI / 2], [0.125, 1, 1]],
        [new Ie(M, y), [0, 0.3, 0.18], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
      ],
      XZ: [
        [
          new ae(new Dt(0.295, 0.295), h.clone()),
          [0.15, 0, 0.15],
          [-Math.PI / 2, 0, 0]
        ],
        [new Ie(M, E), [0.18, 0, 0.3], null, [0.125, 1, 1]],
        [new Ie(M, E), [0.3, 0, 0.18], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
      ]
    }, P = {
      X: [[new ae(new xt(0.2, 0, 1, 4, 1, !1), n), [0.6, 0, 0], [0, 0, -Math.PI / 2]]],
      Y: [[new ae(new xt(0.2, 0, 1, 4, 1, !1), n), [0, 0.6, 0]]],
      Z: [[new ae(new xt(0.2, 0, 1, 4, 1, !1), n), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],
      XYZ: [[new ae(new dn(0.2, 0), n)]],
      XY: [[new ae(new Dt(0.4, 0.4), n), [0.2, 0.2, 0]]],
      YZ: [[new ae(new Dt(0.4, 0.4), n), [0, 0.2, 0.2], [0, Math.PI / 2, 0]]],
      XZ: [[new ae(new Dt(0.4, 0.4), n), [0.2, 0, 0.2], [-Math.PI / 2, 0, 0]]]
    }, I = {
      START: [[new ae(new dn(0.01, 2), s), null, null, null, "helper"]],
      END: [[new ae(new dn(0.01, 2), s), null, null, null, "helper"]],
      DELTA: [[new Ie(w(), s), null, null, null, "helper"]],
      X: [[new Ie(M, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
      Y: [[new Ie(M, s.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]],
      Z: [[new Ie(M, s.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]]
    }, K = {
      X: [
        [new Ie(d(1, 0.5), p)],
        [new ae(new dn(0.04, 0), i), [0, 0, 0.99], null, [1, 3, 1]]
      ],
      Y: [
        [new Ie(d(1, 0.5), v), null, [0, 0, -Math.PI / 2]],
        [new ae(new dn(0.04, 0), r), [0, 0, 0.99], null, [3, 1, 1]]
      ],
      Z: [
        [new Ie(d(1, 0.5), _), null, [0, Math.PI / 2, 0]],
        [new ae(new dn(0.04, 0), a), [0.99, 0, 0], null, [1, 3, 1]]
      ],
      E: [
        [new Ie(d(1.25, 1), g), null, [0, Math.PI / 2, 0]],
        [
          new ae(new xt(0.03, 0, 0.15, 4, 1, !1), g),
          [1.17, 0, 0],
          [0, 0, -Math.PI / 2],
          [1, 1, 1e-3]
        ],
        [
          new ae(new xt(0.03, 0, 0.15, 4, 1, !1), g),
          [-1.17, 0, 0],
          [0, 0, Math.PI / 2],
          [1, 1, 1e-3]
        ],
        [
          new ae(new xt(0.03, 0, 0.15, 4, 1, !1), g),
          [0, -1.17, 0],
          [Math.PI, 0, 0],
          [1, 1, 1e-3]
        ],
        [
          new ae(new xt(0.03, 0, 0.15, 4, 1, !1), g),
          [0, 1.17, 0],
          [0, 0, 0],
          [1, 1, 1e-3]
        ]
      ],
      XYZE: [[new Ie(d(1, 1), T), null, [0, Math.PI / 2, 0]]]
    }, N = {
      AXIS: [[new Ie(M, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]]
    }, Z = {
      X: [[new ae(new xs(1, 0.1, 4, 24), n), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]],
      Y: [[new ae(new xs(1, 0.1, 4, 24), n), [0, 0, 0], [Math.PI / 2, 0, 0]]],
      Z: [[new ae(new xs(1, 0.1, 4, 24), n), [0, 0, 0], [0, 0, -Math.PI / 2]]],
      E: [[new ae(new xs(1.25, 0.1, 2, 24), n)]],
      XYZE: [[new ae(new ul(0.7, 10, 8), n)]]
    }, W = {
      X: [
        [new ae(x, i), [0.8, 0, 0], [0, 0, -Math.PI / 2]],
        [new Ie(M, p), null, null, [0.8, 1, 1]]
      ],
      Y: [
        [new ae(x, r), [0, 0.8, 0]],
        [new Ie(M, v), null, [0, 0, Math.PI / 2], [0.8, 1, 1]]
      ],
      Z: [
        [new ae(x, a), [0, 0, 0.8], [Math.PI / 2, 0, 0]],
        [new Ie(M, _), null, [0, -Math.PI / 2, 0], [0.8, 1, 1]]
      ],
      XY: [
        [new ae(x, c), [0.85, 0.85, 0], null, [2, 2, 0.2]],
        [new Ie(M, R), [0.855, 0.98, 0], null, [0.125, 1, 1]],
        [new Ie(M, R), [0.98, 0.855, 0], [0, 0, Math.PI / 2], [0.125, 1, 1]]
      ],
      YZ: [
        [new ae(x, u), [0, 0.85, 0.85], null, [0.2, 2, 2]],
        [new Ie(M, y), [0, 0.855, 0.98], [0, 0, Math.PI / 2], [0.125, 1, 1]],
        [new Ie(M, y), [0, 0.98, 0.855], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
      ],
      XZ: [
        [new ae(x, h), [0.85, 0, 0.85], null, [2, 0.2, 2]],
        [new Ie(M, E), [0.855, 0, 0.98], null, [0.125, 1, 1]],
        [new Ie(M, E), [0.98, 0, 0.855], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
      ],
      XYZX: [[new ae(new tn(0.125, 0.125, 0.125), l.clone()), [1.1, 0, 0]]],
      XYZY: [[new ae(new tn(0.125, 0.125, 0.125), l.clone()), [0, 1.1, 0]]],
      XYZZ: [[new ae(new tn(0.125, 0.125, 0.125), l.clone()), [0, 0, 1.1]]]
    }, X = {
      X: [[new ae(new xt(0.2, 0, 0.8, 4, 1, !1), n), [0.5, 0, 0], [0, 0, -Math.PI / 2]]],
      Y: [[new ae(new xt(0.2, 0, 0.8, 4, 1, !1), n), [0, 0.5, 0]]],
      Z: [[new ae(new xt(0.2, 0, 0.8, 4, 1, !1), n), [0, 0, 0.5], [Math.PI / 2, 0, 0]]],
      XY: [[new ae(x, n), [0.85, 0.85, 0], null, [3, 3, 0.2]]],
      YZ: [[new ae(x, n), [0, 0.85, 0.85], null, [0.2, 3, 3]]],
      XZ: [[new ae(x, n), [0.85, 0, 0.85], null, [3, 0.2, 3]]],
      XYZX: [[new ae(new tn(0.2, 0.2, 0.2), n), [1.1, 0, 0]]],
      XYZY: [[new ae(new tn(0.2, 0.2, 0.2), n), [0, 1.1, 0]]],
      XYZZ: [[new ae(new tn(0.2, 0.2, 0.2), n), [0, 0, 1.1]]]
    }, V = {
      X: [[new Ie(M, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
      Y: [[new Ie(M, s.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]],
      Z: [[new Ie(M, s.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]]
    }, ne = (se) => {
      const he = new St();
      for (let H in se)
        for (let k = se[H].length; k--; ) {
          const b = se[H][k][0].clone(), U = se[H][k][1], J = se[H][k][2], F = se[H][k][3], B = se[H][k][4];
          b.name = H, b.tag = B, U && b.position.set(U[0], U[1], U[2]), J && b.rotation.set(J[0], J[1], J[2]), F && b.scale.set(F[0], F[1], F[2]), b.updateMatrix();
          const S = b.geometry.clone();
          S.applyMatrix4(b.matrix), b.geometry = S, b.renderOrder = 1 / 0, b.position.set(0, 0, 0), b.rotation.set(0, 0, 0), b.scale.set(1, 1, 1), he.add(b);
        }
      return he;
    };
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = ne(f)), this.add(this.gizmo.rotate = ne(K)), this.add(this.gizmo.scale = ne(W)), this.add(this.picker.translate = ne(P)), this.add(this.picker.rotate = ne(Z)), this.add(this.picker.scale = ne(X)), this.add(this.helper.translate = ne(I)), this.add(this.helper.rotate = ne(N)), this.add(this.helper.scale = ne(V)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;
  }
}
class Kc extends ae {
  constructor() {
    super(
      new Dt(1e5, 1e5, 2, 2),
      new Gt({
        visible: !1,
        wireframe: !0,
        side: wn,
        transparent: !0,
        opacity: 0.1,
        toneMapped: !1
      })
    ), q(this, "isTransformControlsPlane", !0), q(this, "type", "TransformControlsPlane"), q(this, "unitX", new ee(1, 0, 0)), q(this, "unitY", new ee(0, 1, 0)), q(this, "unitZ", new ee(0, 0, 1)), q(this, "tempVector", new ee()), q(this, "dirVector", new ee()), q(this, "alignVector", new ee()), q(this, "tempMatrix", new De()), q(this, "identityQuaternion", new He()), q(this, "cameraQuaternion", new He()), q(this, "worldPosition", new ee()), q(this, "worldQuaternion", new He()), q(this, "eye", new ee()), q(this, "axis", null), q(this, "mode", "translate"), q(this, "space", "world"), q(this, "updateMatrixWorld", () => {
      let e = this.space;
      switch (this.position.copy(this.worldPosition), this.mode === "scale" && (e = "local"), this.unitX.set(1, 0, 0).applyQuaternion(e === "local" ? this.worldQuaternion : this.identityQuaternion), this.unitY.set(0, 1, 0).applyQuaternion(e === "local" ? this.worldQuaternion : this.identityQuaternion), this.unitZ.set(0, 0, 1).applyQuaternion(e === "local" ? this.worldQuaternion : this.identityQuaternion), this.alignVector.copy(this.unitY), this.mode) {
        case "translate":
        case "scale":
          switch (this.axis) {
            case "X":
              this.alignVector.copy(this.eye).cross(this.unitX), this.dirVector.copy(this.unitX).cross(this.alignVector);
              break;
            case "Y":
              this.alignVector.copy(this.eye).cross(this.unitY), this.dirVector.copy(this.unitY).cross(this.alignVector);
              break;
            case "Z":
              this.alignVector.copy(this.eye).cross(this.unitZ), this.dirVector.copy(this.unitZ).cross(this.alignVector);
              break;
            case "XY":
              this.dirVector.copy(this.unitZ);
              break;
            case "YZ":
              this.dirVector.copy(this.unitX);
              break;
            case "XZ":
              this.alignVector.copy(this.unitZ), this.dirVector.copy(this.unitY);
              break;
            case "XYZ":
            case "E":
              this.dirVector.set(0, 0, 0);
              break;
          }
          break;
        case "rotate":
        default:
          this.dirVector.set(0, 0, 0);
      }
      this.dirVector.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (this.tempMatrix.lookAt(this.tempVector.set(0, 0, 0), this.dirVector, this.alignVector), this.quaternion.setFromRotationMatrix(this.tempMatrix)), super.updateMatrixWorld();
    });
  }
}
var qc = Object.defineProperty, Qc = (o, e, t) => e in o ? qc(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, Ze = (o, e, t) => (Qc(o, typeof e != "symbol" ? e + "" : e, t), t);
const Rn = new _n(0, 0, 0, "YXZ"), Cn = new ee(), Jc = { type: "change" }, eu = { type: "lock" }, tu = { type: "unlock" }, Ur = Math.PI / 2;
class qi extends Yo {
  constructor(e, t) {
    super(), Ze(this, "camera"), Ze(this, "domElement"), Ze(this, "isLocked"), Ze(this, "minPolarAngle"), Ze(this, "maxPolarAngle"), Ze(this, "pointerSpeed"), Ze(this, "onMouseMove", (n) => {
      if (!this.domElement || this.isLocked === !1)
        return;
      const s = n.movementX || n.mozMovementX || n.webkitMovementX || 0, i = n.movementY || n.mozMovementY || n.webkitMovementY || 0;
      Rn.setFromQuaternion(this.camera.quaternion), Rn.y -= s * 2e-3 * this.pointerSpeed, Rn.x -= i * 2e-3 * this.pointerSpeed, Rn.x = Math.max(Ur - this.maxPolarAngle, Math.min(Ur - this.minPolarAngle, Rn.x)), this.camera.quaternion.setFromEuler(Rn), this.dispatchEvent(Jc);
    }), Ze(this, "onPointerlockChange", () => {
      this.domElement && (this.domElement.ownerDocument.pointerLockElement === this.domElement ? (this.dispatchEvent(eu), this.isLocked = !0) : (this.dispatchEvent(tu), this.isLocked = !1));
    }), Ze(this, "onPointerlockError", () => {
      console.error("THREE.PointerLockControls: Unable to use Pointer Lock API");
    }), Ze(this, "connect", (n) => {
      this.domElement = n || this.domElement, this.domElement && (this.domElement.ownerDocument.addEventListener("mousemove", this.onMouseMove), this.domElement.ownerDocument.addEventListener("pointerlockchange", this.onPointerlockChange), this.domElement.ownerDocument.addEventListener("pointerlockerror", this.onPointerlockError));
    }), Ze(this, "disconnect", () => {
      this.domElement && (this.domElement.ownerDocument.removeEventListener("mousemove", this.onMouseMove), this.domElement.ownerDocument.removeEventListener("pointerlockchange", this.onPointerlockChange), this.domElement.ownerDocument.removeEventListener("pointerlockerror", this.onPointerlockError));
    }), Ze(this, "dispose", () => {
      this.disconnect();
    }), Ze(this, "getObject", () => this.camera), Ze(this, "direction", new ee(0, 0, -1)), Ze(this, "getDirection", (n) => n.copy(this.direction).applyQuaternion(this.camera.quaternion)), Ze(this, "moveForward", (n) => {
      Cn.setFromMatrixColumn(this.camera.matrix, 0), Cn.crossVectors(this.camera.up, Cn), this.camera.position.addScaledVector(Cn, n);
    }), Ze(this, "moveRight", (n) => {
      Cn.setFromMatrixColumn(this.camera.matrix, 0), this.camera.position.addScaledVector(Cn, n);
    }), Ze(this, "lock", () => {
      this.domElement && this.domElement.requestPointerLock();
    }), Ze(this, "unlock", () => {
      this.domElement && this.domElement.ownerDocument.exitPointerLock();
    }), this.camera = e, this.domElement = t, this.isLocked = !1, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.pointerSpeed = 1, t && this.connect(t);
  }
}
var nu = Object.defineProperty, su = (o, e, t) => e in o ? nu(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, ge = (o, e, t) => (su(o, typeof e != "symbol" ? e + "" : e, t), t);
const As = new hl(), Br = new lr(), iu = Math.cos(70 * (Math.PI / 180)), Nr = (o, e) => (o % e + e) % e;
class wa extends Yo {
  constructor(e, t) {
    super(), ge(this, "object"), ge(this, "domElement"), ge(this, "enabled", !0), ge(this, "target", new ee()), ge(this, "minDistance", 0), ge(this, "maxDistance", 1 / 0), ge(this, "minZoom", 0), ge(this, "maxZoom", 1 / 0), ge(this, "minPolarAngle", 0), ge(this, "maxPolarAngle", Math.PI), ge(this, "minAzimuthAngle", -1 / 0), ge(this, "maxAzimuthAngle", 1 / 0), ge(this, "enableDamping", !1), ge(this, "dampingFactor", 0.05), ge(this, "enableZoom", !0), ge(this, "zoomSpeed", 1), ge(this, "enableRotate", !0), ge(this, "rotateSpeed", 1), ge(this, "enablePan", !0), ge(this, "panSpeed", 1), ge(this, "screenSpacePanning", !0), ge(this, "keyPanSpeed", 7), ge(this, "zoomToCursor", !1), ge(this, "autoRotate", !1), ge(this, "autoRotateSpeed", 2), ge(this, "reverseOrbit", !1), ge(this, "reverseHorizontalOrbit", !1), ge(this, "reverseVerticalOrbit", !1), ge(this, "keys", { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }), ge(this, "mouseButtons", {
      LEFT: on.ROTATE,
      MIDDLE: on.DOLLY,
      RIGHT: on.PAN
    }), ge(this, "touches", { ONE: Lt.ROTATE, TWO: Lt.DOLLY_PAN }), ge(this, "target0"), ge(this, "position0"), ge(this, "zoom0"), ge(this, "_domElementKeyEvents", null), ge(this, "getPolarAngle"), ge(this, "getAzimuthalAngle"), ge(this, "setPolarAngle"), ge(this, "setAzimuthalAngle"), ge(this, "getDistance"), ge(this, "listenToKeyEvents"), ge(this, "stopListenToKeyEvents"), ge(this, "saveState"), ge(this, "reset"), ge(this, "update"), ge(this, "connect"), ge(this, "dispose"), this.object = e, this.domElement = t, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = () => u.phi, this.getAzimuthalAngle = () => u.theta, this.setPolarAngle = (j) => {
      let ie = Nr(j, 2 * Math.PI), ve = u.phi;
      ve < 0 && (ve += 2 * Math.PI), ie < 0 && (ie += 2 * Math.PI);
      let Oe = Math.abs(ie - ve);
      2 * Math.PI - Oe < Oe && (ie < ve ? ie += 2 * Math.PI : ve += 2 * Math.PI), h.phi = ie - ve, n.update();
    }, this.setAzimuthalAngle = (j) => {
      let ie = Nr(j, 2 * Math.PI), ve = u.theta;
      ve < 0 && (ve += 2 * Math.PI), ie < 0 && (ie += 2 * Math.PI);
      let Oe = Math.abs(ie - ve);
      2 * Math.PI - Oe < Oe && (ie < ve ? ie += 2 * Math.PI : ve += 2 * Math.PI), h.theta = ie - ve, n.update();
    }, this.getDistance = () => n.object.position.distanceTo(n.target), this.listenToKeyEvents = (j) => {
      j.addEventListener("keydown", An), this._domElementKeyEvents = j;
    }, this.stopListenToKeyEvents = () => {
      this._domElementKeyEvents.removeEventListener("keydown", An), this._domElementKeyEvents = null;
    }, this.saveState = () => {
      n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom;
    }, this.reset = () => {
      n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(s), n.update(), l = a.NONE;
    }, this.update = (() => {
      const j = new ee(), ie = new ee(0, 1, 0), ve = new He().setFromUnitVectors(e.up, ie), Oe = ve.clone().invert(), Qe = new ee(), Ut = new He(), Zt = 2 * Math.PI;
      return function() {
        const Sr = n.object.position;
        ve.setFromUnitVectors(e.up, ie), Oe.copy(ve).invert(), j.copy(Sr).sub(n.target), j.applyQuaternion(ve), u.setFromVector3(j), n.autoRotate && l === a.NONE && N(I()), n.enableDamping ? (u.theta += h.theta * n.dampingFactor, u.phi += h.phi * n.dampingFactor) : (u.theta += h.theta, u.phi += h.phi);
        let Bt = n.minAzimuthAngle, Nt = n.maxAzimuthAngle;
        isFinite(Bt) && isFinite(Nt) && (Bt < -Math.PI ? Bt += Zt : Bt > Math.PI && (Bt -= Zt), Nt < -Math.PI ? Nt += Zt : Nt > Math.PI && (Nt -= Zt), Bt <= Nt ? u.theta = Math.max(Bt, Math.min(Nt, u.theta)) : u.theta = u.theta > (Bt + Nt) / 2 ? Math.max(Bt, u.theta) : Math.min(Nt, u.theta)), u.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, u.phi)), u.makeSafe(), n.enableDamping === !0 ? n.target.addScaledVector(p, n.dampingFactor) : n.target.add(p), n.zoomToCursor && w || n.object.isOrthographicCamera ? u.radius = H(u.radius) : u.radius = H(u.radius * m), j.setFromSpherical(u), j.applyQuaternion(Oe), Sr.copy(n.target).add(j), n.object.matrixAutoUpdate || n.object.updateMatrix(), n.object.lookAt(n.target), n.enableDamping === !0 ? (h.theta *= 1 - n.dampingFactor, h.phi *= 1 - n.dampingFactor, p.multiplyScalar(1 - n.dampingFactor)) : (h.set(0, 0, 0), p.set(0, 0, 0));
        let Vn = !1;
        if (n.zoomToCursor && w) {
          let Yn = null;
          if (n.object instanceof Mt && n.object.isPerspectiveCamera) {
            const Xn = j.length();
            Yn = H(Xn * m);
            const _s = Xn - Yn;
            n.object.position.addScaledVector(M, _s), n.object.updateMatrixWorld();
          } else if (n.object.isOrthographicCamera) {
            const Xn = new ee(d.x, d.y, 0);
            Xn.unproject(n.object), n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / m)), n.object.updateProjectionMatrix(), Vn = !0;
            const _s = new ee(d.x, d.y, 0);
            _s.unproject(n.object), n.object.position.sub(_s).add(Xn), n.object.updateMatrixWorld(), Yn = j.length();
          } else
            console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), n.zoomToCursor = !1;
          Yn !== null && (n.screenSpacePanning ? n.target.set(0, 0, -1).transformDirection(n.object.matrix).multiplyScalar(Yn).add(n.object.position) : (As.origin.copy(n.object.position), As.direction.set(0, 0, -1).transformDirection(n.object.matrix), Math.abs(n.object.up.dot(As.direction)) < iu ? e.lookAt(n.target) : (Br.setFromNormalAndCoplanarPoint(n.object.up, n.target), As.intersectPlane(Br, n.target))));
        } else
          n.object instanceof jt && n.object.isOrthographicCamera && (Vn = m !== 1, Vn && (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / m)), n.object.updateProjectionMatrix()));
        return m = 1, w = !1, Vn || Qe.distanceToSquared(n.object.position) > c || 8 * (1 - Ut.dot(n.object.quaternion)) > c ? (n.dispatchEvent(s), Qe.copy(n.object.position), Ut.copy(n.object.quaternion), Vn = !1, !0) : !1;
      };
    })(), this.connect = (j) => {
      j === document && console.error(
        'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
      ), n.domElement = j, n.domElement.style.touchAction = "none", n.domElement.addEventListener("contextmenu", br), n.domElement.addEventListener("pointerdown", Me), n.domElement.addEventListener("pointercancel", kt), n.domElement.addEventListener("wheel", gt);
    }, this.dispose = () => {
      var j, ie, ve, Oe, Qe, Ut;
      (j = n.domElement) == null || j.removeEventListener("contextmenu", br), (ie = n.domElement) == null || ie.removeEventListener("pointerdown", Me), (ve = n.domElement) == null || ve.removeEventListener("pointercancel", kt), (Oe = n.domElement) == null || Oe.removeEventListener("wheel", gt), (Qe = n.domElement) == null || Qe.ownerDocument.removeEventListener("pointermove", Se), (Ut = n.domElement) == null || Ut.ownerDocument.removeEventListener("pointerup", qe), n._domElementKeyEvents !== null && n._domElementKeyEvents.removeEventListener("keydown", An);
    };
    const n = this, s = { type: "change" }, i = { type: "start" }, r = { type: "end" }, a = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let l = a.NONE;
    const c = 1e-6, u = new Ws(), h = new Ws();
    let m = 1;
    const p = new ee(), v = new le(), _ = new le(), y = new le(), E = new le(), R = new le(), T = new le(), g = new le(), A = new le(), x = new le(), M = new ee(), d = new le();
    let w = !1;
    const f = [], P = {};
    function I() {
      return 2 * Math.PI / 60 / 60 * n.autoRotateSpeed;
    }
    function K() {
      return Math.pow(0.95, n.zoomSpeed);
    }
    function N(j) {
      n.reverseOrbit || n.reverseHorizontalOrbit ? h.theta += j : h.theta -= j;
    }
    function Z(j) {
      n.reverseOrbit || n.reverseVerticalOrbit ? h.phi += j : h.phi -= j;
    }
    const W = (() => {
      const j = new ee();
      return function(ve, Oe) {
        j.setFromMatrixColumn(Oe, 0), j.multiplyScalar(-ve), p.add(j);
      };
    })(), X = (() => {
      const j = new ee();
      return function(ve, Oe) {
        n.screenSpacePanning === !0 ? j.setFromMatrixColumn(Oe, 1) : (j.setFromMatrixColumn(Oe, 0), j.crossVectors(n.object.up, j)), j.multiplyScalar(ve), p.add(j);
      };
    })(), V = (() => {
      const j = new ee();
      return function(ve, Oe) {
        const Qe = n.domElement;
        if (Qe && n.object instanceof Mt && n.object.isPerspectiveCamera) {
          const Ut = n.object.position;
          j.copy(Ut).sub(n.target);
          let Zt = j.length();
          Zt *= Math.tan(n.object.fov / 2 * Math.PI / 180), W(2 * ve * Zt / Qe.clientHeight, n.object.matrix), X(2 * Oe * Zt / Qe.clientHeight, n.object.matrix);
        } else
          Qe && n.object instanceof jt && n.object.isOrthographicCamera ? (W(
            ve * (n.object.right - n.object.left) / n.object.zoom / Qe.clientWidth,
            n.object.matrix
          ), X(
            Oe * (n.object.top - n.object.bottom) / n.object.zoom / Qe.clientHeight,
            n.object.matrix
          )) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1);
      };
    })();
    function ne(j) {
      n.object instanceof Mt && n.object.isPerspectiveCamera || n.object instanceof jt && n.object.isOrthographicCamera ? m /= j : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
    }
    function se(j) {
      n.object instanceof Mt && n.object.isPerspectiveCamera || n.object instanceof jt && n.object.isOrthographicCamera ? m *= j : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
    }
    function he(j) {
      if (!n.zoomToCursor || !n.domElement)
        return;
      w = !0;
      const ie = n.domElement.getBoundingClientRect(), ve = j.clientX - ie.left, Oe = j.clientY - ie.top, Qe = ie.width, Ut = ie.height;
      d.x = ve / Qe * 2 - 1, d.y = -(Oe / Ut) * 2 + 1, M.set(d.x, d.y, 1).unproject(n.object).sub(n.object.position).normalize();
    }
    function H(j) {
      return Math.max(n.minDistance, Math.min(n.maxDistance, j));
    }
    function k(j) {
      v.set(j.clientX, j.clientY);
    }
    function b(j) {
      he(j), g.set(j.clientX, j.clientY);
    }
    function U(j) {
      E.set(j.clientX, j.clientY);
    }
    function J(j) {
      _.set(j.clientX, j.clientY), y.subVectors(_, v).multiplyScalar(n.rotateSpeed);
      const ie = n.domElement;
      ie && (N(2 * Math.PI * y.x / ie.clientHeight), Z(2 * Math.PI * y.y / ie.clientHeight)), v.copy(_), n.update();
    }
    function F(j) {
      A.set(j.clientX, j.clientY), x.subVectors(A, g), x.y > 0 ? ne(K()) : x.y < 0 && se(K()), g.copy(A), n.update();
    }
    function B(j) {
      R.set(j.clientX, j.clientY), T.subVectors(R, E).multiplyScalar(n.panSpeed), V(T.x, T.y), E.copy(R), n.update();
    }
    function S(j) {
      he(j), j.deltaY < 0 ? se(K()) : j.deltaY > 0 && ne(K()), n.update();
    }
    function C(j) {
      let ie = !1;
      switch (j.code) {
        case n.keys.UP:
          V(0, n.keyPanSpeed), ie = !0;
          break;
        case n.keys.BOTTOM:
          V(0, -n.keyPanSpeed), ie = !0;
          break;
        case n.keys.LEFT:
          V(n.keyPanSpeed, 0), ie = !0;
          break;
        case n.keys.RIGHT:
          V(-n.keyPanSpeed, 0), ie = !0;
          break;
      }
      ie && (j.preventDefault(), n.update());
    }
    function D() {
      if (f.length == 1)
        v.set(f[0].pageX, f[0].pageY);
      else {
        const j = 0.5 * (f[0].pageX + f[1].pageX), ie = 0.5 * (f[0].pageY + f[1].pageY);
        v.set(j, ie);
      }
    }
    function G() {
      if (f.length == 1)
        E.set(f[0].pageX, f[0].pageY);
      else {
        const j = 0.5 * (f[0].pageX + f[1].pageX), ie = 0.5 * (f[0].pageY + f[1].pageY);
        E.set(j, ie);
      }
    }
    function $() {
      const j = f[0].pageX - f[1].pageX, ie = f[0].pageY - f[1].pageY, ve = Math.sqrt(j * j + ie * ie);
      g.set(0, ve);
    }
    function Y() {
      n.enableZoom && $(), n.enablePan && G();
    }
    function te() {
      n.enableZoom && $(), n.enableRotate && D();
    }
    function O(j) {
      if (f.length == 1)
        _.set(j.pageX, j.pageY);
      else {
        const ve = si(j), Oe = 0.5 * (j.pageX + ve.x), Qe = 0.5 * (j.pageY + ve.y);
        _.set(Oe, Qe);
      }
      y.subVectors(_, v).multiplyScalar(n.rotateSpeed);
      const ie = n.domElement;
      ie && (N(2 * Math.PI * y.x / ie.clientHeight), Z(2 * Math.PI * y.y / ie.clientHeight)), v.copy(_);
    }
    function L(j) {
      if (f.length == 1)
        R.set(j.pageX, j.pageY);
      else {
        const ie = si(j), ve = 0.5 * (j.pageX + ie.x), Oe = 0.5 * (j.pageY + ie.y);
        R.set(ve, Oe);
      }
      T.subVectors(R, E).multiplyScalar(n.panSpeed), V(T.x, T.y), E.copy(R);
    }
    function re(j) {
      const ie = si(j), ve = j.pageX - ie.x, Oe = j.pageY - ie.y, Qe = Math.sqrt(ve * ve + Oe * Oe);
      A.set(0, Qe), x.set(0, Math.pow(A.y / g.y, n.zoomSpeed)), ne(x.y), g.copy(A);
    }
    function ce(j) {
      n.enableZoom && re(j), n.enablePan && L(j);
    }
    function be(j) {
      n.enableZoom && re(j), n.enableRotate && O(j);
    }
    function Me(j) {
      var ie, ve;
      n.enabled !== !1 && (f.length === 0 && ((ie = n.domElement) == null || ie.ownerDocument.addEventListener("pointermove", Se), (ve = n.domElement) == null || ve.ownerDocument.addEventListener("pointerup", qe)), il(j), j.pointerType === "touch" ? nl(j) : jn(j));
    }
    function Se(j) {
      n.enabled !== !1 && (j.pointerType === "touch" ? sl(j) : Sn(j));
    }
    function qe(j) {
      var ie, ve, Oe;
      Er(j), f.length === 0 && ((ie = n.domElement) == null || ie.releasePointerCapture(j.pointerId), (ve = n.domElement) == null || ve.ownerDocument.removeEventListener("pointermove", Se), (Oe = n.domElement) == null || Oe.ownerDocument.removeEventListener("pointerup", qe)), n.dispatchEvent(r), l = a.NONE;
    }
    function kt(j) {
      Er(j);
    }
    function jn(j) {
      let ie;
      switch (j.button) {
        case 0:
          ie = n.mouseButtons.LEFT;
          break;
        case 1:
          ie = n.mouseButtons.MIDDLE;
          break;
        case 2:
          ie = n.mouseButtons.RIGHT;
          break;
        default:
          ie = -1;
      }
      switch (ie) {
        case on.DOLLY:
          if (n.enableZoom === !1)
            return;
          b(j), l = a.DOLLY;
          break;
        case on.ROTATE:
          if (j.ctrlKey || j.metaKey || j.shiftKey) {
            if (n.enablePan === !1)
              return;
            U(j), l = a.PAN;
          } else {
            if (n.enableRotate === !1)
              return;
            k(j), l = a.ROTATE;
          }
          break;
        case on.PAN:
          if (j.ctrlKey || j.metaKey || j.shiftKey) {
            if (n.enableRotate === !1)
              return;
            k(j), l = a.ROTATE;
          } else {
            if (n.enablePan === !1)
              return;
            U(j), l = a.PAN;
          }
          break;
        default:
          l = a.NONE;
      }
      l !== a.NONE && n.dispatchEvent(i);
    }
    function Sn(j) {
      if (n.enabled !== !1)
        switch (l) {
          case a.ROTATE:
            if (n.enableRotate === !1)
              return;
            J(j);
            break;
          case a.DOLLY:
            if (n.enableZoom === !1)
              return;
            F(j);
            break;
          case a.PAN:
            if (n.enablePan === !1)
              return;
            B(j);
            break;
        }
    }
    function gt(j) {
      n.enabled === !1 || n.enableZoom === !1 || l !== a.NONE && l !== a.ROTATE || (j.preventDefault(), n.dispatchEvent(i), S(j), n.dispatchEvent(r));
    }
    function An(j) {
      n.enabled === !1 || n.enablePan === !1 || C(j);
    }
    function nl(j) {
      switch (Mr(j), f.length) {
        case 1:
          switch (n.touches.ONE) {
            case Lt.ROTATE:
              if (n.enableRotate === !1)
                return;
              D(), l = a.TOUCH_ROTATE;
              break;
            case Lt.PAN:
              if (n.enablePan === !1)
                return;
              G(), l = a.TOUCH_PAN;
              break;
            default:
              l = a.NONE;
          }
          break;
        case 2:
          switch (n.touches.TWO) {
            case Lt.DOLLY_PAN:
              if (n.enableZoom === !1 && n.enablePan === !1)
                return;
              Y(), l = a.TOUCH_DOLLY_PAN;
              break;
            case Lt.DOLLY_ROTATE:
              if (n.enableZoom === !1 && n.enableRotate === !1)
                return;
              te(), l = a.TOUCH_DOLLY_ROTATE;
              break;
            default:
              l = a.NONE;
          }
          break;
        default:
          l = a.NONE;
      }
      l !== a.NONE && n.dispatchEvent(i);
    }
    function sl(j) {
      switch (Mr(j), l) {
        case a.TOUCH_ROTATE:
          if (n.enableRotate === !1)
            return;
          O(j), n.update();
          break;
        case a.TOUCH_PAN:
          if (n.enablePan === !1)
            return;
          L(j), n.update();
          break;
        case a.TOUCH_DOLLY_PAN:
          if (n.enableZoom === !1 && n.enablePan === !1)
            return;
          ce(j), n.update();
          break;
        case a.TOUCH_DOLLY_ROTATE:
          if (n.enableZoom === !1 && n.enableRotate === !1)
            return;
          be(j), n.update();
          break;
        default:
          l = a.NONE;
      }
    }
    function br(j) {
      n.enabled !== !1 && j.preventDefault();
    }
    function il(j) {
      f.push(j);
    }
    function Er(j) {
      delete P[j.pointerId];
      for (let ie = 0; ie < f.length; ie++)
        if (f[ie].pointerId == j.pointerId) {
          f.splice(ie, 1);
          return;
        }
    }
    function Mr(j) {
      let ie = P[j.pointerId];
      ie === void 0 && (ie = new le(), P[j.pointerId] = ie), ie.set(j.pageX, j.pageY);
    }
    function si(j) {
      const ie = j.pointerId === f[0].pointerId ? f[1] : f[0];
      return P[ie.pointerId];
    }
    t !== void 0 && this.connect(t), this.update();
  }
}
class ru extends wa {
  constructor(e, t) {
    super(e, t), this.screenSpacePanning = !1, this.mouseButtons.LEFT = on.PAN, this.mouseButtons.RIGHT = on.ROTATE, this.touches.ONE = Lt.PAN, this.touches.TWO = Lt.DOLLY_ROTATE;
  }
}
class ou extends cs {
  constructor(e) {
    super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
      return new hu(t);
    }), this.register(function(t) {
      return new _u(t);
    }), this.register(function(t) {
      return new xu(t);
    }), this.register(function(t) {
      return new wu(t);
    }), this.register(function(t) {
      return new du(t);
    }), this.register(function(t) {
      return new pu(t);
    }), this.register(function(t) {
      return new mu(t);
    }), this.register(function(t) {
      return new gu(t);
    }), this.register(function(t) {
      return new uu(t);
    }), this.register(function(t) {
      return new yu(t);
    }), this.register(function(t) {
      return new fu(t);
    }), this.register(function(t) {
      return new vu(t);
    }), this.register(function(t) {
      return new lu(t);
    }), this.register(function(t) {
      return new Tu(t);
    }), this.register(function(t) {
      return new bu(t);
    });
  }
  load(e, t, n, s) {
    const i = this;
    let r;
    this.resourcePath !== "" ? r = this.resourcePath : this.path !== "" ? r = this.path : r = Ft.extractUrlBase(e), this.manager.itemStart(e);
    const a = function(c) {
      s ? s(c) : console.error(c), i.manager.itemError(e), i.manager.itemEnd(e);
    }, l = new Tn(this.manager);
    l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(
      e,
      function(c) {
        try {
          i.parse(
            c,
            r,
            function(u) {
              t(u), i.manager.itemEnd(e);
            },
            a
          );
        } catch (u) {
          a(u);
        }
      },
      n,
      a
    );
  }
  setDRACOLoader(e) {
    return this.dracoLoader = e, this;
  }
  setDDSLoader() {
    throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
  }
  setKTX2Loader(e) {
    return this.ktx2Loader = e, this;
  }
  setMeshoptDecoder(e) {
    return this.meshoptDecoder = e, this;
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  parse(e, t, n, s) {
    let i;
    const r = {}, a = {};
    if (typeof e == "string")
      i = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (Ft.decodeText(new Uint8Array(e.slice(0, 4))) === Ta) {
        try {
          r[Ce.KHR_BINARY_GLTF] = new Eu(e);
        } catch (u) {
          s && s(u);
          return;
        }
        i = JSON.parse(r[Ce.KHR_BINARY_GLTF].content);
      } else
        i = JSON.parse(Ft.decodeText(new Uint8Array(e)));
    else
      i = e;
    if (i.asset === void 0 || i.asset.version[0] < 2) {
      s && s(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const l = new Uu(i, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    l.fileLoader.setRequestHeader(this.requestHeader);
    for (let c = 0; c < this.pluginCallbacks.length; c++) {
      const u = this.pluginCallbacks[c](l);
      a[u.name] = u, r[u.name] = !0;
    }
    if (i.extensionsUsed)
      for (let c = 0; c < i.extensionsUsed.length; ++c) {
        const u = i.extensionsUsed[c], h = i.extensionsRequired || [];
        switch (u) {
          case Ce.KHR_MATERIALS_UNLIT:
            r[u] = new cu();
            break;
          case Ce.KHR_DRACO_MESH_COMPRESSION:
            r[u] = new Mu(i, this.dracoLoader);
            break;
          case Ce.KHR_TEXTURE_TRANSFORM:
            r[u] = new Su();
            break;
          case Ce.KHR_MESH_QUANTIZATION:
            r[u] = new Au();
            break;
          default:
            h.indexOf(u) >= 0 && a[u] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + u + '".');
        }
      }
    l.setExtensions(r), l.setPlugins(a), l.parse(n, s);
  }
  parseAsync(e, t) {
    const n = this;
    return new Promise(function(s, i) {
      n.parse(e, t, s, i);
    });
  }
}
function au() {
  let o = {};
  return {
    get: function(e) {
      return o[e];
    },
    add: function(e, t) {
      o[e] = t;
    },
    remove: function(e) {
      delete o[e];
    },
    removeAll: function() {
      o = {};
    }
  };
}
const Ce = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class lu {
  constructor(e) {
    this.parser = e, this.name = Ce.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const e = this.parser, t = this.parser.json.nodes || [];
    for (let n = 0, s = t.length; n < s; n++) {
      const i = t[n];
      i.extensions && i.extensions[this.name] && i.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, i.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser, n = "light:" + e;
    let s = t.cache.get(n);
    if (s)
      return s;
    const i = t.json, l = ((i.extensions && i.extensions[this.name] || {}).lights || [])[e];
    let c;
    const u = new Be(16777215);
    l.color !== void 0 && u.fromArray(l.color);
    const h = l.range !== void 0 ? l.range : 0;
    switch (l.type) {
      case "directional":
        c = new Wo(u), c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      case "point":
        c = new zi(u), c.distance = h;
        break;
      case "spot":
        c = new Xo(u), c.distance = h, l.spot = l.spot || {}, l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0, l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4, c.angle = l.spot.outerConeAngle, c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle, c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type);
    }
    return c.position.set(0, 0, 0), c.decay = 2, an(c, l), l.intensity !== void 0 && (c.intensity = l.intensity), c.name = t.createUniqueName(l.name || "light_" + e), s = Promise.resolve(c), t.cache.add(n, s), s;
  }
  getDependency(e, t) {
    if (e === "light")
      return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this, n = this.parser, i = n.json.nodes[e], a = (i.extensions && i.extensions[this.name] || {}).light;
    return a === void 0 ? null : this._loadLight(a).then(function(l) {
      return n._getNodeRef(t.cache, a, l);
    });
  }
}
class cu {
  constructor() {
    this.name = Ce.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return Gt;
  }
  extendParams(e, t, n) {
    const s = [];
    e.color = new Be(1, 1, 1), e.opacity = 1;
    const i = t.pbrMetallicRoughness;
    if (i) {
      if (Array.isArray(i.baseColorFactor)) {
        const r = i.baseColorFactor;
        e.color.fromArray(r), e.opacity = r[3];
      }
      i.baseColorTexture !== void 0 && s.push(n.assignTexture(e, "map", i.baseColorTexture, 3001));
    }
    return Promise.all(s);
  }
}
class uu {
  constructor(e) {
    this.parser = e, this.name = Ce.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(e, t) {
    const s = this.parser.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = s.extensions[this.name].emissiveStrength;
    return i !== void 0 && (t.emissiveIntensity = i), Promise.resolve();
  }
}
class hu {
  constructor(e) {
    this.parser = e, this.name = Ce.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : fn;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = [], r = s.extensions[this.name];
    if (r.clearcoatFactor !== void 0 && (t.clearcoat = r.clearcoatFactor), r.clearcoatTexture !== void 0 && i.push(n.assignTexture(t, "clearcoatMap", r.clearcoatTexture)), r.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = r.clearcoatRoughnessFactor), r.clearcoatRoughnessTexture !== void 0 && i.push(n.assignTexture(t, "clearcoatRoughnessMap", r.clearcoatRoughnessTexture)), r.clearcoatNormalTexture !== void 0 && (i.push(n.assignTexture(t, "clearcoatNormalMap", r.clearcoatNormalTexture)), r.clearcoatNormalTexture.scale !== void 0)) {
      const a = r.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new le(a, a);
    }
    return Promise.all(i);
  }
}
class fu {
  constructor(e) {
    this.parser = e, this.name = Ce.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : fn;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = [], r = s.extensions[this.name];
    return r.iridescenceFactor !== void 0 && (t.iridescence = r.iridescenceFactor), r.iridescenceTexture !== void 0 && i.push(n.assignTexture(t, "iridescenceMap", r.iridescenceTexture)), r.iridescenceIor !== void 0 && (t.iridescenceIOR = r.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), r.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = r.iridescenceThicknessMinimum), r.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = r.iridescenceThicknessMaximum), r.iridescenceThicknessTexture !== void 0 && i.push(
      n.assignTexture(t, "iridescenceThicknessMap", r.iridescenceThicknessTexture)
    ), Promise.all(i);
  }
}
class du {
  constructor(e) {
    this.parser = e, this.name = Ce.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : fn;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = [];
    t.sheenColor = new Be(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
    const r = s.extensions[this.name];
    return r.sheenColorFactor !== void 0 && t.sheenColor.fromArray(r.sheenColorFactor), r.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = r.sheenRoughnessFactor), r.sheenColorTexture !== void 0 && i.push(n.assignTexture(t, "sheenColorMap", r.sheenColorTexture, 3001)), r.sheenRoughnessTexture !== void 0 && i.push(n.assignTexture(t, "sheenRoughnessMap", r.sheenRoughnessTexture)), Promise.all(i);
  }
}
class pu {
  constructor(e) {
    this.parser = e, this.name = Ce.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : fn;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = [], r = s.extensions[this.name];
    return r.transmissionFactor !== void 0 && (t.transmission = r.transmissionFactor), r.transmissionTexture !== void 0 && i.push(n.assignTexture(t, "transmissionMap", r.transmissionTexture)), Promise.all(i);
  }
}
class mu {
  constructor(e) {
    this.parser = e, this.name = Ce.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : fn;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = [], r = s.extensions[this.name];
    t.thickness = r.thicknessFactor !== void 0 ? r.thicknessFactor : 0, r.thicknessTexture !== void 0 && i.push(n.assignTexture(t, "thicknessMap", r.thicknessTexture)), t.attenuationDistance = r.attenuationDistance || 1 / 0;
    const a = r.attenuationColor || [1, 1, 1];
    return t.attenuationColor = new Be(a[0], a[1], a[2]), Promise.all(i);
  }
}
class gu {
  constructor(e) {
    this.parser = e, this.name = Ce.KHR_MATERIALS_IOR;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : fn;
  }
  extendMaterialParams(e, t) {
    const s = this.parser.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = s.extensions[this.name];
    return t.ior = i.ior !== void 0 ? i.ior : 1.5, Promise.resolve();
  }
}
class yu {
  constructor(e) {
    this.parser = e, this.name = Ce.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : fn;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = [], r = s.extensions[this.name];
    t.specularIntensity = r.specularFactor !== void 0 ? r.specularFactor : 1, r.specularTexture !== void 0 && i.push(n.assignTexture(t, "specularIntensityMap", r.specularTexture));
    const a = r.specularColorFactor || [1, 1, 1];
    return t.specularColor = new Be(a[0], a[1], a[2]), r.specularColorTexture !== void 0 && i.push(
      n.assignTexture(t, "specularColorMap", r.specularColorTexture, 3001)
      // sRGBEncoding
    ), Promise.all(i);
  }
}
class vu {
  constructor(e) {
    this.parser = e, this.name = Ce.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : fn;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = [], r = s.extensions[this.name];
    return r.anisotropyStrength !== void 0 && (t.anisotropy = r.anisotropyStrength), r.anisotropyRotation !== void 0 && (t.anisotropyRotation = r.anisotropyRotation), r.anisotropyTexture !== void 0 && i.push(n.assignTexture(t, "anisotropyMap", r.anisotropyTexture)), Promise.all(i);
  }
}
class _u {
  constructor(e) {
    this.parser = e, this.name = Ce.KHR_TEXTURE_BASISU;
  }
  loadTexture(e) {
    const t = this.parser, n = t.json, s = n.textures[e];
    if (!s.extensions || !s.extensions[this.name])
      return null;
    const i = s.extensions[this.name], r = t.options.ktx2Loader;
    if (!r) {
      if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return t.loadTextureImage(e, i.source, r);
  }
}
class xu {
  constructor(e) {
    this.parser = e, this.name = Ce.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, n = this.parser, s = n.json, i = s.textures[e];
    if (!i.extensions || !i.extensions[t])
      return null;
    const r = i.extensions[t], a = s.images[r.source];
    let l = n.textureLoader;
    if (a.uri) {
      const c = n.options.manager.getHandler(a.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function(c) {
      if (c)
        return n.loadTextureImage(e, r.source, l);
      if (s.extensionsRequired && s.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class wu {
  constructor(e) {
    this.parser = e, this.name = Ce.EXT_TEXTURE_AVIF, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, n = this.parser, s = n.json, i = s.textures[e];
    if (!i.extensions || !i.extensions[t])
      return null;
    const r = i.extensions[t], a = s.images[r.source];
    let l = n.textureLoader;
    if (a.uri) {
      const c = n.options.manager.getHandler(a.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function(c) {
      if (c)
        return n.loadTextureImage(e, r.source, l);
      if (s.extensionsRequired && s.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class Tu {
  constructor(e) {
    this.name = Ce.EXT_MESHOPT_COMPRESSION, this.parser = e;
  }
  loadBufferView(e) {
    const t = this.parser.json, n = t.bufferViews[e];
    if (n.extensions && n.extensions[this.name]) {
      const s = n.extensions[this.name], i = this.parser.getDependency("buffer", s.buffer), r = this.parser.options.meshoptDecoder;
      if (!r || !r.supported) {
        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return i.then(function(a) {
        const l = s.byteOffset || 0, c = s.byteLength || 0, u = s.count, h = s.byteStride, m = new Uint8Array(a, l, c);
        return r.decodeGltfBufferAsync ? r.decodeGltfBufferAsync(u, h, m, s.mode, s.filter).then(function(p) {
          return p.buffer;
        }) : r.ready.then(function() {
          const p = new ArrayBuffer(u * h);
          return r.decodeGltfBuffer(
            new Uint8Array(p),
            u,
            h,
            m,
            s.mode,
            s.filter
          ), p;
        });
      });
    } else
      return null;
  }
}
class bu {
  constructor(e) {
    this.name = Ce.EXT_MESH_GPU_INSTANCING, this.parser = e;
  }
  createNodeMesh(e) {
    const t = this.parser.json, n = t.nodes[e];
    if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0)
      return null;
    const s = t.meshes[n.mesh];
    for (const c of s.primitives)
      if (c.mode !== vt.TRIANGLES && c.mode !== vt.TRIANGLE_STRIP && c.mode !== vt.TRIANGLE_FAN && c.mode !== void 0)
        return null;
    const r = n.extensions[this.name].attributes, a = [], l = {};
    for (const c in r)
      a.push(
        this.parser.getDependency("accessor", r[c]).then((u) => (l[c] = u, l[c]))
      );
    return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)), Promise.all(a).then((c) => {
      const u = c.pop(), h = u.isGroup ? u.children : [u], m = c[0].count, p = [];
      for (const v of h) {
        const _ = new De(), y = new ee(), E = new He(), R = new ee(1, 1, 1), T = new fl(v.geometry, v.material, m);
        for (let g = 0; g < m; g++)
          l.TRANSLATION && y.fromBufferAttribute(l.TRANSLATION, g), l.ROTATION && E.fromBufferAttribute(l.ROTATION, g), l.SCALE && R.fromBufferAttribute(l.SCALE, g), T.setMatrixAt(g, _.compose(y, E, R));
        for (const g in l)
          g !== "TRANSLATION" && g !== "ROTATION" && g !== "SCALE" && v.geometry.setAttribute(g, l[g]);
        St.prototype.copy.call(T, v), this.parser.assignFinalMaterial(T), p.push(T);
      }
      return u.isGroup ? (u.clear(), u.add(...p), u) : p[0];
    }));
  }
}
const Ta = "glTF", Wn = 12, zr = { JSON: 1313821514, BIN: 5130562 };
class Eu {
  constructor(e) {
    this.name = Ce.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const t = new DataView(e, 0, Wn);
    if (this.header = {
      magic: Ft.decodeText(new Uint8Array(e.slice(0, 4))),
      version: t.getUint32(4, !0),
      length: t.getUint32(8, !0)
    }, this.header.magic !== Ta)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const n = this.header.length - Wn, s = new DataView(e, Wn);
    let i = 0;
    for (; i < n; ) {
      const r = s.getUint32(i, !0);
      i += 4;
      const a = s.getUint32(i, !0);
      if (i += 4, a === zr.JSON) {
        const l = new Uint8Array(e, Wn + i, r);
        this.content = Ft.decodeText(l);
      } else if (a === zr.BIN) {
        const l = Wn + i;
        this.body = e.slice(l, l + r);
      }
      i += r;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class Mu {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = Ce.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const n = this.json, s = this.dracoLoader, i = e.extensions[this.name].bufferView, r = e.extensions[this.name].attributes, a = {}, l = {}, c = {};
    for (const u in r) {
      const h = Qi[u] || u.toLowerCase();
      a[h] = r[u];
    }
    for (const u in e.attributes) {
      const h = Qi[u] || u.toLowerCase();
      if (r[u] !== void 0) {
        const m = n.accessors[e.attributes[u]], p = Nn[m.componentType];
        c[h] = p.name, l[h] = m.normalized === !0;
      }
    }
    return t.getDependency("bufferView", i).then(function(u) {
      return new Promise(function(h) {
        s.decodeDracoFile(
          u,
          function(m) {
            for (const p in m.attributes) {
              const v = m.attributes[p], _ = l[p];
              _ !== void 0 && (v.normalized = _);
            }
            h(m);
          },
          a,
          c
        );
      });
    });
  }
}
class Su {
  constructor() {
    this.name = Ce.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e;
  }
}
class Au {
  constructor() {
    this.name = Ce.KHR_MESH_QUANTIZATION;
  }
}
class ba extends vl {
  constructor(e, t, n, s) {
    super(e, t, n, s);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, n = this.sampleValues, s = this.valueSize, i = e * s * 3 + s;
    for (let r = 0; r !== s; r++)
      t[r] = n[i + r];
    return t;
  }
  interpolate_(e, t, n, s) {
    const i = this.resultBuffer, r = this.sampleValues, a = this.valueSize, l = a * 2, c = a * 3, u = s - t, h = (n - t) / u, m = h * h, p = m * h, v = e * c, _ = v - c, y = -2 * p + 3 * m, E = p - m, R = 1 - y, T = E - m + h;
    for (let g = 0; g !== a; g++) {
      const A = r[_ + g + a], x = r[_ + g + l] * u, M = r[v + g + a], d = r[v + g] * u;
      i[g] = R * A + T * x + y * M + E * d;
    }
    return i;
  }
}
const Pu = new He();
class Ru extends ba {
  interpolate_(e, t, n, s) {
    const i = super.interpolate_(e, t, n, s);
    return Pu.fromArray(i).normalize().toArray(i), i;
  }
}
const vt = {
  FLOAT: 5126,
  //FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
}, Nn = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
}, Hr = {
  9728: No,
  9729: At,
  9984: zo,
  9985: Go,
  9986: Ho,
  9987: ar
}, Gr = {
  33071: Hn,
  33648: jo,
  10497: Gn
}, mi = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, Qi = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  // uv => uv1, 4 uv channels
  // https://github.com/mrdoob/three.js/pull/25943
  // https://github.com/mrdoob/three.js/pull/25788
  ...da >= 152 ? {
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv1",
    TEXCOORD_2: "uv2",
    TEXCOORD_3: "uv3"
  } : {
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2"
  },
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
}, Qt = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
}, Cu = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: or,
  STEP: Bo
}, gi = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function Iu(o) {
  return o.DefaultMaterial === void 0 && (o.DefaultMaterial = new us({
    color: 16777215,
    emissive: 0,
    metalness: 1,
    roughness: 1,
    transparent: !1,
    depthTest: !0,
    side: yl
  })), o.DefaultMaterial;
}
function pn(o, e, t) {
  for (const n in t.extensions)
    o[n] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[n] = t.extensions[n]);
}
function an(o, e) {
  e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(o.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
}
function Du(o, e, t) {
  let n = !1, s = !1, i = !1;
  for (let c = 0, u = e.length; c < u; c++) {
    const h = e[c];
    if (h.POSITION !== void 0 && (n = !0), h.NORMAL !== void 0 && (s = !0), h.COLOR_0 !== void 0 && (i = !0), n && s && i)
      break;
  }
  if (!n && !s && !i)
    return Promise.resolve(o);
  const r = [], a = [], l = [];
  for (let c = 0, u = e.length; c < u; c++) {
    const h = e[c];
    if (n) {
      const m = h.POSITION !== void 0 ? t.getDependency("accessor", h.POSITION) : o.attributes.position;
      r.push(m);
    }
    if (s) {
      const m = h.NORMAL !== void 0 ? t.getDependency("accessor", h.NORMAL) : o.attributes.normal;
      a.push(m);
    }
    if (i) {
      const m = h.COLOR_0 !== void 0 ? t.getDependency("accessor", h.COLOR_0) : o.attributes.color;
      l.push(m);
    }
  }
  return Promise.all([
    Promise.all(r),
    Promise.all(a),
    Promise.all(l)
  ]).then(function(c) {
    const u = c[0], h = c[1], m = c[2];
    return n && (o.morphAttributes.position = u), s && (o.morphAttributes.normal = h), i && (o.morphAttributes.color = m), o.morphTargetsRelative = !0, o;
  });
}
function Lu(o, e) {
  if (o.updateMorphTargets(), e.weights !== void 0)
    for (let t = 0, n = e.weights.length; t < n; t++)
      o.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (o.morphTargetInfluences.length === t.length) {
      o.morphTargetDictionary = {};
      for (let n = 0, s = t.length; n < s; n++)
        o.morphTargetDictionary[t[n]] = n;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function Ou(o) {
  let e;
  const t = o.extensions && o.extensions[Ce.KHR_DRACO_MESH_COMPRESSION];
  if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + yi(t.attributes) : e = o.indices + ":" + yi(o.attributes) + ":" + o.mode, o.targets !== void 0)
    for (let n = 0, s = o.targets.length; n < s; n++)
      e += ":" + yi(o.targets[n]);
  return e;
}
function yi(o) {
  let e = "";
  const t = Object.keys(o).sort();
  for (let n = 0, s = t.length; n < s; n++)
    e += t[n] + ":" + o[t[n]] + ";";
  return e;
}
function Ji(o) {
  switch (o) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function Fu(o) {
  return o.search(/\.jpe?g($|\?)/i) > 0 || o.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : o.search(/\.webp($|\?)/i) > 0 || o.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png";
}
const ku = new De();
class Uu {
  constructor(e = {}, t = {}) {
    this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new au(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    let n = !1, s = !1, i = -1;
    typeof navigator < "u" && typeof navigator.userAgent < "u" && (n = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, s = navigator.userAgent.indexOf("Firefox") > -1, i = s ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || n || s && i < 98 ? this.textureLoader = new cr(this.options.manager) : this.textureLoader = new dl(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new Tn(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const n = this, s = this.json, i = this.extensions;
    this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(r) {
      return r._markDefs && r._markDefs();
    }), Promise.all(
      this._invokeAll(function(r) {
        return r.beforeRoot && r.beforeRoot();
      })
    ).then(function() {
      return Promise.all([
        n.getDependencies("scene"),
        n.getDependencies("animation"),
        n.getDependencies("camera")
      ]);
    }).then(function(r) {
      const a = {
        scene: r[0][s.scene || 0],
        scenes: r[0],
        animations: r[1],
        cameras: r[2],
        asset: s.asset,
        parser: n,
        userData: {}
      };
      pn(i, a, s), an(a, s), Promise.all(
        n._invokeAll(function(l) {
          return l.afterRoot && l.afterRoot(a);
        })
      ).then(function() {
        e(a);
      });
    }).catch(t);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const e = this.json.nodes || [], t = this.json.skins || [], n = this.json.meshes || [];
    for (let s = 0, i = t.length; s < i; s++) {
      const r = t[s].joints;
      for (let a = 0, l = r.length; a < l; a++)
        e[r[a]].isBone = !0;
    }
    for (let s = 0, i = e.length; s < i; s++) {
      const r = e[s];
      r.mesh !== void 0 && (this._addNodeRef(this.meshCache, r.mesh), r.skin !== void 0 && (n[r.mesh].isSkinnedMesh = !0)), r.camera !== void 0 && this._addNodeRef(this.cameraCache, r.camera);
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(e, t) {
    t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(e, t, n) {
    if (e.refs[t] <= 1)
      return n;
    const s = n.clone(), i = (r, a) => {
      const l = this.associations.get(r);
      l != null && this.associations.set(a, l);
      for (const [c, u] of r.children.entries())
        i(u, a.children[c]);
    };
    return i(n, s), s.name += "_instance_" + e.uses[t]++, s;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let n = 0; n < t.length; n++) {
      const s = e(t[n]);
      if (s)
        return s;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const n = [];
    for (let s = 0; s < t.length; s++) {
      const i = e(t[s]);
      i && n.push(i);
    }
    return n;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(e, t) {
    const n = e + ":" + t;
    let s = this.cache.get(n);
    if (!s) {
      switch (e) {
        case "scene":
          s = this.loadScene(t);
          break;
        case "node":
          s = this._invokeOne(function(i) {
            return i.loadNode && i.loadNode(t);
          });
          break;
        case "mesh":
          s = this._invokeOne(function(i) {
            return i.loadMesh && i.loadMesh(t);
          });
          break;
        case "accessor":
          s = this.loadAccessor(t);
          break;
        case "bufferView":
          s = this._invokeOne(function(i) {
            return i.loadBufferView && i.loadBufferView(t);
          });
          break;
        case "buffer":
          s = this.loadBuffer(t);
          break;
        case "material":
          s = this._invokeOne(function(i) {
            return i.loadMaterial && i.loadMaterial(t);
          });
          break;
        case "texture":
          s = this._invokeOne(function(i) {
            return i.loadTexture && i.loadTexture(t);
          });
          break;
        case "skin":
          s = this.loadSkin(t);
          break;
        case "animation":
          s = this._invokeOne(function(i) {
            return i.loadAnimation && i.loadAnimation(t);
          });
          break;
        case "camera":
          s = this.loadCamera(t);
          break;
        default:
          if (s = this._invokeOne(function(i) {
            return i != this && i.getDependency && i.getDependency(e, t);
          }), !s)
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(n, s);
    }
    return s;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const n = this, s = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      t = Promise.all(
        s.map(function(i, r) {
          return n.getDependency(e, r);
        })
      ), this.cache.add(e, t);
    }
    return t;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(e) {
    const t = this.json.buffers[e], n = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[Ce.KHR_BINARY_GLTF].body);
    const s = this.options;
    return new Promise(function(i, r) {
      n.load(Ft.resolveURL(t.uri, s.path), i, void 0, function() {
        r(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function(n) {
      const s = t.byteLength || 0, i = t.byteOffset || 0;
      return n.slice(i, i + s);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(e) {
    const t = this, n = this.json, s = this.json.accessors[e];
    if (s.bufferView === void 0 && s.sparse === void 0) {
      const r = mi[s.type], a = Nn[s.componentType], l = s.normalized === !0, c = new a(s.count * r);
      return Promise.resolve(new pt(c, r, l));
    }
    const i = [];
    return s.bufferView !== void 0 ? i.push(this.getDependency("bufferView", s.bufferView)) : i.push(null), s.sparse !== void 0 && (i.push(this.getDependency("bufferView", s.sparse.indices.bufferView)), i.push(this.getDependency("bufferView", s.sparse.values.bufferView))), Promise.all(i).then(function(r) {
      const a = r[0], l = mi[s.type], c = Nn[s.componentType], u = c.BYTES_PER_ELEMENT, h = u * l, m = s.byteOffset || 0, p = s.bufferView !== void 0 ? n.bufferViews[s.bufferView].byteStride : void 0, v = s.normalized === !0;
      let _, y;
      if (p && p !== h) {
        const E = Math.floor(m / p), R = "InterleavedBuffer:" + s.bufferView + ":" + s.componentType + ":" + E + ":" + s.count;
        let T = t.cache.get(R);
        T || (_ = new c(a, E * p, s.count * p / u), T = new ur(_, p / u), t.cache.add(R, T)), y = new Vt(
          T,
          l,
          m % p / u,
          v
        );
      } else
        a === null ? _ = new c(s.count * l) : _ = new c(a, m, s.count * l), y = new pt(_, l, v);
      if (s.sparse !== void 0) {
        const E = mi.SCALAR, R = Nn[s.sparse.indices.componentType], T = s.sparse.indices.byteOffset || 0, g = s.sparse.values.byteOffset || 0, A = new R(
          r[1],
          T,
          s.sparse.count * E
        ), x = new c(r[2], g, s.sparse.count * l);
        a !== null && (y = new pt(
          y.array.slice(),
          y.itemSize,
          y.normalized
        ));
        for (let M = 0, d = A.length; M < d; M++) {
          const w = A[M];
          if (y.setX(w, x[M * l]), l >= 2 && y.setY(w, x[M * l + 1]), l >= 3 && y.setZ(w, x[M * l + 2]), l >= 4 && y.setW(w, x[M * l + 3]), l >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return y;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(e) {
    const t = this.json, n = this.options, i = t.textures[e].source, r = t.images[i];
    let a = this.textureLoader;
    if (r.uri) {
      const l = n.manager.getHandler(r.uri);
      l !== null && (a = l);
    }
    return this.loadTextureImage(e, i, a);
  }
  loadTextureImage(e, t, n) {
    const s = this, i = this.json, r = i.textures[e], a = i.images[t], l = (a.uri || a.bufferView) + ":" + r.sampler;
    if (this.textureCache[l])
      return this.textureCache[l];
    const c = this.loadImageSource(t, n).then(function(u) {
      u.flipY = !1, u.name = r.name || a.name || "", u.name === "" && typeof a.uri == "string" && a.uri.startsWith("data:image/") === !1 && (u.name = a.uri);
      const m = (i.samplers || {})[r.sampler] || {};
      return u.magFilter = Hr[m.magFilter] || At, u.minFilter = Hr[m.minFilter] || ar, u.wrapS = Gr[m.wrapS] || Gn, u.wrapT = Gr[m.wrapT] || Gn, s.associations.set(u, { textures: e }), u;
    }).catch(function() {
      return null;
    });
    return this.textureCache[l] = c, c;
  }
  loadImageSource(e, t) {
    const n = this, s = this.json, i = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((h) => h.clone());
    const r = s.images[e], a = self.URL || self.webkitURL;
    let l = r.uri || "", c = !1;
    if (r.bufferView !== void 0)
      l = n.getDependency("bufferView", r.bufferView).then(function(h) {
        c = !0;
        const m = new Blob([h], { type: r.mimeType });
        return l = a.createObjectURL(m), l;
      });
    else if (r.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
    const u = Promise.resolve(l).then(function(h) {
      return new Promise(function(m, p) {
        let v = m;
        t.isImageBitmapLoader === !0 && (v = function(_) {
          const y = new zn(_);
          y.needsUpdate = !0, m(y);
        }), t.load(Ft.resolveURL(h, i.path), v, void 0, p);
      });
    }).then(function(h) {
      return c === !0 && a.revokeObjectURL(l), h.userData.mimeType = r.mimeType || Fu(r.uri), h;
    }).catch(function(h) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", l), h;
    });
    return this.sourceCache[e] = u, u;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */
  assignTexture(e, t, n, s) {
    const i = this;
    return this.getDependency("texture", n.index).then(function(r) {
      if (!r)
        return null;
      if (n.texCoord !== void 0 && n.texCoord > 0 && (r = r.clone(), r.channel = n.texCoord), i.extensions[Ce.KHR_TEXTURE_TRANSFORM]) {
        const a = n.extensions !== void 0 ? n.extensions[Ce.KHR_TEXTURE_TRANSFORM] : void 0;
        if (a) {
          const l = i.associations.get(r);
          r = i.extensions[Ce.KHR_TEXTURE_TRANSFORM].extendTexture(r, a), i.associations.set(r, l);
        }
      }
      return s !== void 0 && ("colorSpace" in r ? r.colorSpace = s === 3001 ? "srgb" : "srgb-linear" : r.encoding = s), e[t] = r, r;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(e) {
    const t = e.geometry;
    let n = e.material;
    const s = t.attributes.tangent === void 0, i = t.attributes.color !== void 0, r = t.attributes.normal === void 0;
    if (e.isPoints) {
      const a = "PointsMaterial:" + n.uuid;
      let l = this.cache.get(a);
      l || (l = new pl(), ri.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, l.sizeAttenuation = !1, this.cache.add(a, l)), n = l;
    } else if (e.isLine) {
      const a = "LineBasicMaterial:" + n.uuid;
      let l = this.cache.get(a);
      l || (l = new qs(), ri.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, this.cache.add(a, l)), n = l;
    }
    if (s || i || r) {
      let a = "ClonedMaterial:" + n.uuid + ":";
      s && (a += "derivative-tangents:"), i && (a += "vertex-colors:"), r && (a += "flat-shading:");
      let l = this.cache.get(a);
      l || (l = n.clone(), i && (l.vertexColors = !0), r && (l.flatShading = !0), s && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(a, l), this.associations.set(l, this.associations.get(n))), n = l;
    }
    e.material = n;
  }
  getMaterialType() {
    return us;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(e) {
    const t = this, n = this.json, s = this.extensions, i = n.materials[e];
    let r;
    const a = {}, l = i.extensions || {}, c = [];
    if (l[Ce.KHR_MATERIALS_UNLIT]) {
      const h = s[Ce.KHR_MATERIALS_UNLIT];
      r = h.getMaterialType(), c.push(h.extendParams(a, i, t));
    } else {
      const h = i.pbrMetallicRoughness || {};
      if (a.color = new Be(1, 1, 1), a.opacity = 1, Array.isArray(h.baseColorFactor)) {
        const m = h.baseColorFactor;
        a.color.fromArray(m), a.opacity = m[3];
      }
      h.baseColorTexture !== void 0 && c.push(t.assignTexture(a, "map", h.baseColorTexture, 3001)), a.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1, a.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1, h.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(a, "metalnessMap", h.metallicRoughnessTexture)), c.push(t.assignTexture(a, "roughnessMap", h.metallicRoughnessTexture))), r = this._invokeOne(function(m) {
        return m.getMaterialType && m.getMaterialType(e);
      }), c.push(
        Promise.all(
          this._invokeAll(function(m) {
            return m.extendMaterialParams && m.extendMaterialParams(e, a);
          })
        )
      );
    }
    i.doubleSided === !0 && (a.side = wn);
    const u = i.alphaMode || gi.OPAQUE;
    if (u === gi.BLEND ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, u === gi.MASK && (a.alphaTest = i.alphaCutoff !== void 0 ? i.alphaCutoff : 0.5)), i.normalTexture !== void 0 && r !== Gt && (c.push(t.assignTexture(a, "normalMap", i.normalTexture)), a.normalScale = new le(1, 1), i.normalTexture.scale !== void 0)) {
      const h = i.normalTexture.scale;
      a.normalScale.set(h, h);
    }
    return i.occlusionTexture !== void 0 && r !== Gt && (c.push(t.assignTexture(a, "aoMap", i.occlusionTexture)), i.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = i.occlusionTexture.strength)), i.emissiveFactor !== void 0 && r !== Gt && (a.emissive = new Be().fromArray(i.emissiveFactor)), i.emissiveTexture !== void 0 && r !== Gt && c.push(t.assignTexture(a, "emissiveMap", i.emissiveTexture, 3001)), Promise.all(c).then(function() {
      const h = new r(a);
      return i.name && (h.name = i.name), an(h, i), t.associations.set(h, { materials: e }), i.extensions && pn(s, h, i), h;
    });
  }
  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(e) {
    const t = Yt.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(e) {
    const t = this, n = this.extensions, s = this.primitiveCache;
    function i(a) {
      return n[Ce.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function(l) {
        return jr(l, a, t);
      });
    }
    const r = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a], u = Ou(c), h = s[u];
      if (h)
        r.push(h.promise);
      else {
        let m;
        c.extensions && c.extensions[Ce.KHR_DRACO_MESH_COMPRESSION] ? m = i(c) : m = jr(new rt(), c, t), s[u] = { primitive: c, promise: m }, r.push(m);
      }
    }
    return Promise.all(r);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(e) {
    const t = this, n = this.json, s = this.extensions, i = n.meshes[e], r = i.primitives, a = [];
    for (let l = 0, c = r.length; l < c; l++) {
      const u = r[l].material === void 0 ? Iu(this.cache) : this.getDependency("material", r[l].material);
      a.push(u);
    }
    return a.push(t.loadGeometries(r)), Promise.all(a).then(function(l) {
      const c = l.slice(0, l.length - 1), u = l[l.length - 1], h = [];
      for (let p = 0, v = u.length; p < v; p++) {
        const _ = u[p], y = r[p];
        let E;
        const R = c[p];
        if (y.mode === vt.TRIANGLES || y.mode === vt.TRIANGLE_STRIP || y.mode === vt.TRIANGLE_FAN || y.mode === void 0)
          E = i.isSkinnedMesh === !0 ? new $o(_, R) : new ae(_, R), E.isSkinnedMesh === !0 && E.normalizeSkinWeights(), y.mode === vt.TRIANGLE_STRIP ? E.geometry = Rr(E.geometry, ko) : y.mode === vt.TRIANGLE_FAN && (E.geometry = Rr(E.geometry, Ni));
        else if (y.mode === vt.LINES)
          E = new ml(_, R);
        else if (y.mode === vt.LINE_STRIP)
          E = new Ie(_, R);
        else if (y.mode === vt.LINE_LOOP)
          E = new gl(_, R);
        else if (y.mode === vt.POINTS)
          E = new Zo(_, R);
        else
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + y.mode);
        Object.keys(E.geometry.morphAttributes).length > 0 && Lu(E, i), E.name = t.createUniqueName(i.name || "mesh_" + e), an(E, i), y.extensions && pn(s, E, y), t.assignFinalMaterial(E), h.push(E);
      }
      for (let p = 0, v = h.length; p < v; p++)
        t.associations.set(h[p], {
          meshes: e,
          primitives: p
        });
      if (h.length === 1)
        return i.extensions && pn(s, h[0], i), h[0];
      const m = new ns();
      i.extensions && pn(s, m, i), t.associations.set(m, { meshes: e });
      for (let p = 0, v = h.length; p < v; p++)
        m.add(h[p]);
      return m;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(e) {
    let t;
    const n = this.json.cameras[e], s = n[n.type];
    if (!s) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return n.type === "perspective" ? t = new Mt(
      We.radToDeg(s.yfov),
      s.aspectRatio || 1,
      s.znear || 1,
      s.zfar || 2e6
    ) : n.type === "orthographic" && (t = new jt(-s.xmag, s.xmag, s.ymag, -s.ymag, s.znear, s.zfar)), n.name && (t.name = this.createUniqueName(n.name)), an(t, n), Promise.resolve(t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(e) {
    const t = this.json.skins[e], n = [];
    for (let s = 0, i = t.joints.length; s < i; s++)
      n.push(this._loadNodeShallow(t.joints[s]));
    return t.inverseBindMatrices !== void 0 ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null), Promise.all(n).then(function(s) {
      const i = s.pop(), r = s, a = [], l = [];
      for (let c = 0, u = r.length; c < u; c++) {
        const h = r[c];
        if (h) {
          a.push(h);
          const m = new De();
          i !== null && m.fromArray(i.array, c * 16), l.push(m);
        } else
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[c]);
      }
      return new Ko(a, l);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(e) {
    const n = this.json.animations[e], s = n.name ? n.name : "animation_" + e, i = [], r = [], a = [], l = [], c = [];
    for (let u = 0, h = n.channels.length; u < h; u++) {
      const m = n.channels[u], p = n.samplers[m.sampler], v = m.target, _ = v.node, y = n.parameters !== void 0 ? n.parameters[p.input] : p.input, E = n.parameters !== void 0 ? n.parameters[p.output] : p.output;
      v.node !== void 0 && (i.push(this.getDependency("node", _)), r.push(this.getDependency("accessor", y)), a.push(this.getDependency("accessor", E)), l.push(p), c.push(v));
    }
    return Promise.all([
      Promise.all(i),
      Promise.all(r),
      Promise.all(a),
      Promise.all(l),
      Promise.all(c)
    ]).then(function(u) {
      const h = u[0], m = u[1], p = u[2], v = u[3], _ = u[4], y = [];
      for (let E = 0, R = h.length; E < R; E++) {
        const T = h[E], g = m[E], A = p[E], x = v[E], M = _[E];
        if (T === void 0)
          continue;
        T.updateMatrix();
        let d;
        switch (Qt[M.path]) {
          case Qt.weights:
            d = Jo;
            break;
          case Qt.rotation:
            d = Gi;
            break;
          case Qt.position:
          case Qt.scale:
          default:
            d = Qo;
            break;
        }
        const w = T.name ? T.name : T.uuid, f = x.interpolation !== void 0 ? Cu[x.interpolation] : or, P = [];
        Qt[M.path] === Qt.weights ? T.traverse(function(K) {
          K.morphTargetInfluences && P.push(K.name ? K.name : K.uuid);
        }) : P.push(w);
        let I = A.array;
        if (A.normalized) {
          const K = Ji(I.constructor), N = new Float32Array(I.length);
          for (let Z = 0, W = I.length; Z < W; Z++)
            N[Z] = I[Z] * K;
          I = N;
        }
        for (let K = 0, N = P.length; K < N; K++) {
          const Z = new d(
            P[K] + "." + Qt[M.path],
            g.array,
            I,
            f
          );
          x.interpolation === "CUBICSPLINE" && (Z.createInterpolant = function(X) {
            const V = this instanceof Gi ? Ru : ba;
            return new V(this.times, this.values, this.getValueSize() / 3, X);
          }, Z.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), y.push(Z);
        }
      }
      return new qo(s, void 0, y);
    });
  }
  createNodeMesh(e) {
    const t = this.json, n = this, s = t.nodes[e];
    return s.mesh === void 0 ? null : n.getDependency("mesh", s.mesh).then(function(i) {
      const r = n._getNodeRef(n.meshCache, s.mesh, i);
      return s.weights !== void 0 && r.traverse(function(a) {
        if (a.isMesh)
          for (let l = 0, c = s.weights.length; l < c; l++)
            a.morphTargetInfluences[l] = s.weights[l];
      }), r;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(e) {
    const t = this.json, n = this, s = t.nodes[e], i = n._loadNodeShallow(e), r = [], a = s.children || [];
    for (let c = 0, u = a.length; c < u; c++)
      r.push(n.getDependency("node", a[c]));
    const l = s.skin === void 0 ? Promise.resolve(null) : n.getDependency("skin", s.skin);
    return Promise.all([i, Promise.all(r), l]).then(function(c) {
      const u = c[0], h = c[1], m = c[2];
      m !== null && u.traverse(function(p) {
        p.isSkinnedMesh && p.bind(m, ku);
      });
      for (let p = 0, v = h.length; p < v; p++)
        u.add(h[p]);
      return u;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(e) {
    const t = this.json, n = this.extensions, s = this;
    if (this.nodeCache[e] !== void 0)
      return this.nodeCache[e];
    const i = t.nodes[e], r = i.name ? s.createUniqueName(i.name) : "", a = [], l = s._invokeOne(function(c) {
      return c.createNodeMesh && c.createNodeMesh(e);
    });
    return l && a.push(l), i.camera !== void 0 && a.push(
      s.getDependency("camera", i.camera).then(function(c) {
        return s._getNodeRef(s.cameraCache, i.camera, c);
      })
    ), s._invokeAll(function(c) {
      return c.createNodeAttachment && c.createNodeAttachment(e);
    }).forEach(function(c) {
      a.push(c);
    }), this.nodeCache[e] = Promise.all(a).then(function(c) {
      let u;
      if (i.isBone === !0 ? u = new Hi() : c.length > 1 ? u = new ns() : c.length === 1 ? u = c[0] : u = new St(), u !== c[0])
        for (let h = 0, m = c.length; h < m; h++)
          u.add(c[h]);
      if (i.name && (u.userData.name = i.name, u.name = r), an(u, i), i.extensions && pn(n, u, i), i.matrix !== void 0) {
        const h = new De();
        h.fromArray(i.matrix), u.applyMatrix4(h);
      } else
        i.translation !== void 0 && u.position.fromArray(i.translation), i.rotation !== void 0 && u.quaternion.fromArray(i.rotation), i.scale !== void 0 && u.scale.fromArray(i.scale);
      return s.associations.has(u) || s.associations.set(u, {}), s.associations.get(u).nodes = e, u;
    }), this.nodeCache[e];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(e) {
    const t = this.extensions, n = this.json.scenes[e], s = this, i = new ns();
    n.name && (i.name = s.createUniqueName(n.name)), an(i, n), n.extensions && pn(t, i, n);
    const r = n.nodes || [], a = [];
    for (let l = 0, c = r.length; l < c; l++)
      a.push(s.getDependency("node", r[l]));
    return Promise.all(a).then(function(l) {
      for (let u = 0, h = l.length; u < h; u++)
        i.add(l[u]);
      const c = (u) => {
        const h = /* @__PURE__ */ new Map();
        for (const [m, p] of s.associations)
          (m instanceof ri || m instanceof zn) && h.set(m, p);
        return u.traverse((m) => {
          const p = s.associations.get(m);
          p != null && h.set(m, p);
        }), h;
      };
      return s.associations = c(i), i;
    });
  }
}
function Bu(o, e, t) {
  const n = e.attributes, s = new hs();
  if (n.POSITION !== void 0) {
    const a = t.json.accessors[n.POSITION], l = a.min, c = a.max;
    if (l !== void 0 && c !== void 0) {
      if (s.set(new ee(l[0], l[1], l[2]), new ee(c[0], c[1], c[2])), a.normalized) {
        const u = Ji(Nn[a.componentType]);
        s.min.multiplyScalar(u), s.max.multiplyScalar(u);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else
    return;
  const i = e.targets;
  if (i !== void 0) {
    const a = new ee(), l = new ee();
    for (let c = 0, u = i.length; c < u; c++) {
      const h = i[c];
      if (h.POSITION !== void 0) {
        const m = t.json.accessors[h.POSITION], p = m.min, v = m.max;
        if (p !== void 0 && v !== void 0) {
          if (l.setX(Math.max(Math.abs(p[0]), Math.abs(v[0]))), l.setY(Math.max(Math.abs(p[1]), Math.abs(v[1]))), l.setZ(Math.max(Math.abs(p[2]), Math.abs(v[2]))), m.normalized) {
            const _ = Ji(Nn[m.componentType]);
            l.multiplyScalar(_);
          }
          a.max(l);
        } else
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    s.expandByVector(a);
  }
  o.boundingBox = s;
  const r = new Qs();
  s.getCenter(r.center), r.radius = s.min.distanceTo(s.max) / 2, o.boundingSphere = r;
}
function jr(o, e, t) {
  const n = e.attributes, s = [];
  function i(r, a) {
    return t.getDependency("accessor", r).then(function(l) {
      o.setAttribute(a, l);
    });
  }
  for (const r in n) {
    const a = Qi[r] || r.toLowerCase();
    a in o.attributes || s.push(i(n[r], a));
  }
  if (e.indices !== void 0 && !o.index) {
    const r = t.getDependency("accessor", e.indices).then(function(a) {
      o.setIndex(a);
    });
    s.push(r);
  }
  return an(o, e), Bu(o, e, t), Promise.all(s).then(function() {
    return e.targets !== void 0 ? Du(o, e.targets, t) : o;
  });
}
class Vr extends _l {
  constructor(e, t = {}) {
    const {
      bevelEnabled: n = !1,
      bevelSize: s = 8,
      bevelThickness: i = 10,
      font: r,
      height: a = 50,
      size: l = 100,
      lineHeight: c = 1,
      letterSpacing: u = 0,
      ...h
    } = t;
    if (r === void 0)
      super();
    else {
      const m = r.generateShapes(e, l, { lineHeight: c, letterSpacing: u });
      super(m, { ...h, bevelEnabled: n, bevelSize: s, bevelThickness: i, depth: a });
    }
    this.type = "TextGeometry";
  }
}
const Nu = {
  uniforms: {
    tDiffuse: { value: null },
    h: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `
      varying vec2 vUv;

      void main() {

        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

      }
  `
  ),
  fragmentShader: (
    /* glsl */
    `
    uniform sampler2D tDiffuse;
    uniform float h;

    varying vec2 vUv;

    void main() {

    	vec4 sum = vec4( 0.0 );

    	sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
    	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

    	gl_FragColor = sum;

    }
  `
  )
}, zu = {
  uniforms: {
    tDiffuse: { value: null },
    v: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `
    varying vec2 vUv;

    void main() {

      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }
  `
  ),
  fragmentShader: (
    /* glsl */
    `

  uniform sampler2D tDiffuse;
  uniform float v;

  varying vec2 vUv;

  void main() {

    vec4 sum = vec4( 0.0 );

    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

    gl_FragColor = sum;

  }
  `
  )
};
function Ea(o, e, t) {
  const n = t.length - o - 1;
  if (e >= t[n])
    return n - 1;
  if (e <= t[o])
    return o;
  let s = o, i = n, r = Math.floor((s + i) / 2);
  for (; e < t[r] || e >= t[r + 1]; )
    e < t[r] ? i = r : s = r, r = Math.floor((s + i) / 2);
  return r;
}
function Hu(o, e, t, n) {
  const s = [], i = [], r = [];
  s[0] = 1;
  for (let a = 1; a <= t; ++a) {
    i[a] = e - n[o + 1 - a], r[a] = n[o + a] - e;
    let l = 0;
    for (let c = 0; c < a; ++c) {
      const u = r[c + 1], h = i[a - c], m = s[c] / (u + h);
      s[c] = l + u * m, l = h * m;
    }
    s[a] = l;
  }
  return s;
}
function Gu(o, e, t, n) {
  const s = Ea(o, n, e), i = Hu(s, n, o, e), r = new ht(0, 0, 0, 0);
  for (let a = 0; a <= o; ++a) {
    const l = t[s - o + a], c = i[a], u = l.w * c;
    r.x += l.x * u, r.y += l.y * u, r.z += l.z * u, r.w += l.w * c;
  }
  return r;
}
function ju(o, e, t, n, s) {
  const i = [];
  for (let h = 0; h <= t; ++h)
    i[h] = 0;
  const r = [];
  for (let h = 0; h <= n; ++h)
    r[h] = i.slice(0);
  const a = [];
  for (let h = 0; h <= t; ++h)
    a[h] = i.slice(0);
  a[0][0] = 1;
  const l = i.slice(0), c = i.slice(0);
  for (let h = 1; h <= t; ++h) {
    l[h] = e - s[o + 1 - h], c[h] = s[o + h] - e;
    let m = 0;
    for (let p = 0; p < h; ++p) {
      const v = c[p + 1], _ = l[h - p];
      a[h][p] = v + _;
      const y = a[p][h - 1] / a[h][p];
      a[p][h] = m + v * y, m = _ * y;
    }
    a[h][h] = m;
  }
  for (let h = 0; h <= t; ++h)
    r[0][h] = a[h][t];
  for (let h = 0; h <= t; ++h) {
    let m = 0, p = 1;
    const v = [];
    for (let _ = 0; _ <= t; ++_)
      v[_] = i.slice(0);
    v[0][0] = 1;
    for (let _ = 1; _ <= n; ++_) {
      let y = 0;
      const E = h - _, R = t - _;
      h >= _ && (v[p][0] = v[m][0] / a[R + 1][E], y = v[p][0] * a[E][R]);
      const T = E >= -1 ? 1 : -E, g = h - 1 <= R ? _ - 1 : t - h;
      for (let x = T; x <= g; ++x)
        v[p][x] = (v[m][x] - v[m][x - 1]) / a[R + 1][E + x], y += v[p][x] * a[E + x][R];
      h <= R && (v[p][_] = -v[m][_ - 1] / a[R + 1][h], y += v[p][_] * a[h][R]), r[_][h] = y;
      const A = m;
      m = p, p = A;
    }
  }
  let u = t;
  for (let h = 1; h <= n; ++h) {
    for (let m = 0; m <= t; ++m)
      r[h][m] *= u;
    u *= t - h;
  }
  return r;
}
function Vu(o, e, t, n, s) {
  const i = s < o ? s : o, r = [], a = Ea(o, n, e), l = ju(a, n, o, i, e), c = [];
  for (let u = 0; u < t.length; ++u) {
    const h = t[u].clone(), m = h.w;
    h.x *= m, h.y *= m, h.z *= m, c[u] = h;
  }
  for (let u = 0; u <= i; ++u) {
    const h = c[a - o].clone().multiplyScalar(l[u][0]);
    for (let m = 1; m <= o; ++m)
      h.add(c[a - o + m].clone().multiplyScalar(l[u][m]));
    r[u] = h;
  }
  for (let u = i + 1; u <= s + 1; ++u)
    r[u] = new ht(0, 0, 0);
  return r;
}
function Yu(o, e) {
  let t = 1;
  for (let s = 2; s <= o; ++s)
    t *= s;
  let n = 1;
  for (let s = 2; s <= e; ++s)
    n *= s;
  for (let s = 2; s <= o - e; ++s)
    n *= s;
  return t / n;
}
function Xu(o) {
  const e = o.length, t = [], n = [];
  for (let i = 0; i < e; ++i) {
    const r = o[i];
    t[i] = new ee(r.x, r.y, r.z), n[i] = r.w;
  }
  const s = [];
  for (let i = 0; i < e; ++i) {
    const r = t[i].clone();
    for (let a = 1; a <= i; ++a)
      r.sub(s[i - a].clone().multiplyScalar(Yu(i, a) * n[a]));
    s[i] = r.divideScalar(n[0]);
  }
  return s;
}
function Wu(o, e, t, n, s) {
  const i = Vu(o, e, t, n, s);
  return Xu(i);
}
class Yr extends xl {
  constructor(e, t, n, s, i) {
    super(), this.degree = e, this.knots = t, this.controlPoints = [], this.startKnot = s || 0, this.endKnot = i || this.knots.length - 1;
    for (let r = 0; r < n.length; ++r) {
      const a = n[r];
      this.controlPoints[r] = new ht(a.x, a.y, a.z, a.w);
    }
  }
  getPoint(e, t) {
    const n = t || new ee(), s = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot]), i = Gu(this.degree, this.knots, this.controlPoints, s);
    return i.w != 1 && i.divideScalar(i.w), n.set(i.x, i.y, i.z);
  }
  getTangent(e, t) {
    const n = t || new ee(), s = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]), i = Wu(this.degree, this.knots, this.controlPoints, s, 1);
    return n.copy(i[1]).normalize(), n;
  }
}
let Ae, Xe, ut;
class $u extends cs {
  constructor(e) {
    super(e);
  }
  load(e, t, n, s) {
    const i = this, r = i.path === "" ? Ft.extractUrlBase(e) : i.path, a = new Tn(this.manager);
    a.setPath(i.path), a.setResponseType("arraybuffer"), a.setRequestHeader(i.requestHeader), a.setWithCredentials(i.withCredentials), a.load(
      e,
      function(l) {
        try {
          t(i.parse(l, r));
        } catch (c) {
          s ? s(c) : console.error(c), i.manager.itemError(e);
        }
      },
      n,
      s
    );
  }
  parse(e, t) {
    if (eh(e))
      Ae = new Ju().parse(e);
    else {
      const s = Pa(e);
      if (!th(s))
        throw new Error("THREE.FBXLoader: Unknown format.");
      if (Wr(s) < 7e3)
        throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + Wr(s));
      Ae = new Qu().parse(s);
    }
    const n = new cr(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);
    return new Zu(n, this.manager).parse(Ae);
  }
}
class Zu {
  constructor(e, t) {
    this.textureLoader = e, this.manager = t;
  }
  parse() {
    Xe = this.parseConnections();
    const e = this.parseImages(), t = this.parseTextures(e), n = this.parseMaterials(t), s = this.parseDeformers(), i = new Ku().parse(s);
    return this.parseScene(s, i, n), ut;
  }
  // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
  // and details the connection type
  parseConnections() {
    const e = /* @__PURE__ */ new Map();
    return "Connections" in Ae && Ae.Connections.connections.forEach(function(n) {
      const s = n[0], i = n[1], r = n[2];
      e.has(s) || e.set(s, {
        parents: [],
        children: []
      });
      const a = { ID: i, relationship: r };
      e.get(s).parents.push(a), e.has(i) || e.set(i, {
        parents: [],
        children: []
      });
      const l = { ID: s, relationship: r };
      e.get(i).children.push(l);
    }), e;
  }
  // Parse FBXTree.Objects.Video for embedded image data
  // These images are connected to textures in FBXTree.Objects.Textures
  // via FBXTree.Connections.
  parseImages() {
    const e = {}, t = {};
    if ("Video" in Ae.Objects) {
      const n = Ae.Objects.Video;
      for (const s in n) {
        const i = n[s], r = parseInt(s);
        if (e[r] = i.RelativeFilename || i.Filename, "Content" in i) {
          const a = i.Content instanceof ArrayBuffer && i.Content.byteLength > 0, l = typeof i.Content == "string" && i.Content !== "";
          if (a || l) {
            const c = this.parseImage(n[s]);
            t[i.RelativeFilename || i.Filename] = c;
          }
        }
      }
    }
    for (const n in e) {
      const s = e[n];
      t[s] !== void 0 ? e[n] = t[s] : e[n] = e[n].split("\\").pop();
    }
    return e;
  }
  // Parse embedded image data in FBXTree.Video.Content
  parseImage(e) {
    const t = e.Content, n = e.RelativeFilename || e.Filename, s = n.slice(n.lastIndexOf(".") + 1).toLowerCase();
    let i;
    switch (s) {
      case "bmp":
        i = "image/bmp";
        break;
      case "jpg":
      case "jpeg":
        i = "image/jpeg";
        break;
      case "png":
        i = "image/png";
        break;
      case "tif":
        i = "image/tiff";
        break;
      case "tga":
        this.manager.getHandler(".tga") === null && console.warn("FBXLoader: TGA loader not found, skipping ", n), i = "image/tga";
        break;
      default:
        console.warn('FBXLoader: Image type "' + s + '" is not supported.');
        return;
    }
    if (typeof t == "string")
      return "data:" + i + ";base64," + t;
    {
      const r = new Uint8Array(t);
      return window.URL.createObjectURL(new Blob([r], { type: i }));
    }
  }
  // Parse nodes in FBXTree.Objects.Texture
  // These contain details such as UV scaling, cropping, rotation etc and are connected
  // to images in FBXTree.Objects.Video
  parseTextures(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Texture" in Ae.Objects) {
      const n = Ae.Objects.Texture;
      for (const s in n) {
        const i = this.parseTexture(n[s], e);
        t.set(parseInt(s), i);
      }
    }
    return t;
  }
  // Parse individual node in FBXTree.Objects.Texture
  parseTexture(e, t) {
    const n = this.loadTexture(e, t);
    n.ID = e.id, n.name = e.attrName;
    const s = e.WrapModeU, i = e.WrapModeV, r = s !== void 0 ? s.value : 0, a = i !== void 0 ? i.value : 0;
    if (n.wrapS = r === 0 ? Gn : Hn, n.wrapT = a === 0 ? Gn : Hn, "Scaling" in e) {
      const l = e.Scaling.value;
      n.repeat.x = l[0], n.repeat.y = l[1];
    }
    return n;
  }
  // load a texture specified as a blob or data URI, or via an external URL using TextureLoader
  loadTexture(e, t) {
    let n;
    const s = this.textureLoader.path, i = Xe.get(e.id).children;
    i !== void 0 && i.length > 0 && t[i[0].ID] !== void 0 && (n = t[i[0].ID], (n.indexOf("blob:") === 0 || n.indexOf("data:") === 0) && this.textureLoader.setPath(void 0));
    let r;
    const a = e.FileName.slice(-3).toLowerCase();
    if (a === "tga") {
      const l = this.manager.getHandler(".tga");
      l === null ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", e.RelativeFilename), r = new zn()) : (l.setPath(this.textureLoader.path), r = l.load(n));
    } else
      a === "psd" ? (console.warn(
        "FBXLoader: PSD textures are not supported, creating placeholder texture for",
        e.RelativeFilename
      ), r = new zn()) : r = this.textureLoader.load(n);
    return this.textureLoader.setPath(s), r;
  }
  // Parse nodes in FBXTree.Objects.Material
  parseMaterials(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Material" in Ae.Objects) {
      const n = Ae.Objects.Material;
      for (const s in n) {
        const i = this.parseMaterial(n[s], e);
        i !== null && t.set(parseInt(s), i);
      }
    }
    return t;
  }
  // Parse single node in FBXTree.Objects.Material
  // Materials are connected to texture maps in FBXTree.Objects.Textures
  // FBX format currently only supports Lambert and Phong shading models
  parseMaterial(e, t) {
    const n = e.id, s = e.attrName;
    let i = e.ShadingModel;
    if (typeof i == "object" && (i = i.value), !Xe.has(n))
      return null;
    const r = this.parseParameters(e, t, n);
    let a;
    switch (i.toLowerCase()) {
      case "phong":
        a = new oi();
        break;
      case "lambert":
        a = new wl();
        break;
      default:
        console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', i), a = new oi();
        break;
    }
    return a.setValues(r), a.name = s, a;
  }
  // Parse FBX material and return parameters suitable for a three.js material
  // Also parse the texture map and return any textures associated with the material
  parseParameters(e, t, n) {
    const s = {};
    e.BumpFactor && (s.bumpScale = e.BumpFactor.value), e.Diffuse ? s.color = new Be().fromArray(e.Diffuse.value) : e.DiffuseColor && (e.DiffuseColor.type === "Color" || e.DiffuseColor.type === "ColorRGB") && (s.color = new Be().fromArray(e.DiffuseColor.value)), e.DisplacementFactor && (s.displacementScale = e.DisplacementFactor.value), e.Emissive ? s.emissive = new Be().fromArray(e.Emissive.value) : e.EmissiveColor && (e.EmissiveColor.type === "Color" || e.EmissiveColor.type === "ColorRGB") && (s.emissive = new Be().fromArray(e.EmissiveColor.value)), e.EmissiveFactor && (s.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (s.opacity = parseFloat(e.Opacity.value)), s.opacity < 1 && (s.transparent = !0), e.ReflectionFactor && (s.reflectivity = e.ReflectionFactor.value), e.Shininess && (s.shininess = e.Shininess.value), e.Specular ? s.specular = new Be().fromArray(e.Specular.value) : e.SpecularColor && e.SpecularColor.type === "Color" && (s.specular = new Be().fromArray(e.SpecularColor.value));
    const i = this;
    return Xe.get(n).children.forEach(function(r) {
      const a = r.relationship;
      switch (a) {
        case "Bump":
          s.bumpMap = i.getTexture(t, r.ID);
          break;
        case "Maya|TEX_ao_map":
          s.aoMap = i.getTexture(t, r.ID);
          break;
        case "DiffuseColor":
        case "Maya|TEX_color_map":
          s.map = i.getTexture(t, r.ID), s.map !== void 0 && ("colorSpace" in s.map ? s.map.colorSpace = "srgb" : s.map.encoding = 3001);
          break;
        case "DisplacementColor":
          s.displacementMap = i.getTexture(t, r.ID);
          break;
        case "EmissiveColor":
          s.emissiveMap = i.getTexture(t, r.ID), s.emissiveMap !== void 0 && ("colorSpace" in s.emissiveMap ? s.emissiveMap.colorSpace = "srgb" : s.emissiveMap.encoding = 3001);
          break;
        case "NormalMap":
        case "Maya|TEX_normal_map":
          s.normalMap = i.getTexture(t, r.ID);
          break;
        case "ReflectionColor":
          s.envMap = i.getTexture(t, r.ID), s.envMap !== void 0 && (s.envMap.mapping = ji, "colorSpace" in s.envMap ? s.envMap.colorSpace = "srgb" : s.envMap.encoding = 3001);
          break;
        case "SpecularColor":
          s.specularMap = i.getTexture(t, r.ID), s.specularMap !== void 0 && ("colorSpace" in s.specularMap ? s.specularMap.colorSpace = "srgb" : s.specularMap.encoding = 3001);
          break;
        case "TransparentColor":
        case "TransparencyFactor":
          s.alphaMap = i.getTexture(t, r.ID), s.transparent = !0;
          break;
        case "AmbientColor":
        case "ShininessExponent":
        case "SpecularFactor":
        case "VectorDisplacementColor":
        default:
          console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", a);
          break;
      }
    }), s;
  }
  // get a texture from the textureMap for use by a material.
  getTexture(e, t) {
    return "LayeredTexture" in Ae.Objects && t in Ae.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), t = Xe.get(t).children[0].ID), e.get(t);
  }
  // Parse nodes in FBXTree.Objects.Deformer
  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.
  parseDeformers() {
    const e = {}, t = {};
    if ("Deformer" in Ae.Objects) {
      const n = Ae.Objects.Deformer;
      for (const s in n) {
        const i = n[s], r = Xe.get(parseInt(s));
        if (i.attrType === "Skin") {
          const a = this.parseSkeleton(r, n);
          a.ID = s, r.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), a.geometryID = r.parents[0].ID, e[s] = a;
        } else if (i.attrType === "BlendShape") {
          const a = {
            id: s
          };
          a.rawTargets = this.parseMorphTargets(r, n), a.id = s, r.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), t[s] = a;
        }
      }
    }
    return {
      skeletons: e,
      morphTargets: t
    };
  }
  // Parse single nodes in FBXTree.Objects.Deformer
  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
  // Each skin node represents a skeleton and each cluster node represents a bone
  parseSkeleton(e, t) {
    const n = [];
    return e.children.forEach(function(s) {
      const i = t[s.ID];
      if (i.attrType !== "Cluster")
        return;
      const r = {
        ID: s.ID,
        indices: [],
        weights: [],
        transformLink: new De().fromArray(i.TransformLink.a)
        // transform: new Matrix4().fromArray( boneNode.Transform.a ),
        // linkMode: boneNode.Mode,
      };
      "Indexes" in i && (r.indices = i.Indexes.a, r.weights = i.Weights.a), n.push(r);
    }), {
      rawBones: n,
      bones: []
    };
  }
  // The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
  parseMorphTargets(e, t) {
    const n = [];
    for (let s = 0; s < e.children.length; s++) {
      const i = e.children[s], r = t[i.ID], a = {
        name: r.attrName,
        initialWeight: r.DeformPercent,
        id: r.id,
        fullWeights: r.FullWeights.a
      };
      if (r.attrType !== "BlendShapeChannel")
        return;
      a.geoID = Xe.get(parseInt(i.ID)).children.filter(function(l) {
        return l.relationship === void 0;
      })[0].ID, n.push(a);
    }
    return n;
  }
  // create the main Group() to be returned by the loader
  parseScene(e, t, n) {
    ut = new ns();
    const s = this.parseModels(e.skeletons, t, n), i = Ae.Objects.Model, r = this;
    s.forEach(function(l) {
      const c = i[l.ID];
      r.setLookAtProperties(l, c), Xe.get(l.ID).parents.forEach(function(h) {
        const m = s.get(h.ID);
        m !== void 0 && m.add(l);
      }), l.parent === null && ut.add(l);
    }), this.bindSkeleton(e.skeletons, t, s), this.createAmbientLight(), ut.traverse(function(l) {
      if (l.userData.transformData) {
        l.parent && (l.userData.transformData.parentMatrix = l.parent.matrix, l.userData.transformData.parentMatrixWorld = l.parent.matrixWorld);
        const c = Sa(l.userData.transformData);
        l.applyMatrix4(c), l.updateWorldMatrix();
      }
    });
    const a = new qu().parse();
    ut.children.length === 1 && ut.children[0].isGroup && (ut.children[0].animations = a, ut = ut.children[0]), ut.animations = a;
  }
  // parse nodes in FBXTree.Objects.Model
  parseModels(e, t, n) {
    const s = /* @__PURE__ */ new Map(), i = Ae.Objects.Model;
    for (const r in i) {
      const a = parseInt(r), l = i[r], c = Xe.get(a);
      let u = this.buildSkeleton(c, e, a, l.attrName);
      if (!u) {
        switch (l.attrType) {
          case "Camera":
            u = this.createCamera(c);
            break;
          case "Light":
            u = this.createLight(c);
            break;
          case "Mesh":
            u = this.createMesh(c, t, n);
            break;
          case "NurbsCurve":
            u = this.createCurve(c, t);
            break;
          case "LimbNode":
          case "Root":
            u = new Hi();
            break;
          case "Null":
          default:
            u = new ns();
            break;
        }
        u.name = l.attrName ? Yt.sanitizeNodeName(l.attrName) : "", u.ID = a;
      }
      this.getTransformData(u, l), s.set(a, u);
    }
    return s;
  }
  buildSkeleton(e, t, n, s) {
    let i = null;
    return e.parents.forEach(function(r) {
      for (const a in t) {
        const l = t[a];
        l.rawBones.forEach(function(c, u) {
          if (c.ID === r.ID) {
            const h = i;
            i = new Hi(), i.matrixWorld.copy(c.transformLink), i.name = s ? Yt.sanitizeNodeName(s) : "", i.ID = n, l.bones[u] = i, h !== null && i.add(h);
          }
        });
      }
    }), i;
  }
  // create a PerspectiveCamera or OrthographicCamera
  createCamera(e) {
    let t, n;
    if (e.children.forEach(function(s) {
      const i = Ae.Objects.NodeAttribute[s.ID];
      i !== void 0 && (n = i);
    }), n === void 0)
      t = new St();
    else {
      let s = 0;
      n.CameraProjectionType !== void 0 && n.CameraProjectionType.value === 1 && (s = 1);
      let i = 1;
      n.NearPlane !== void 0 && (i = n.NearPlane.value / 1e3);
      let r = 1e3;
      n.FarPlane !== void 0 && (r = n.FarPlane.value / 1e3);
      let a = window.innerWidth, l = window.innerHeight;
      n.AspectWidth !== void 0 && n.AspectHeight !== void 0 && (a = n.AspectWidth.value, l = n.AspectHeight.value);
      const c = a / l;
      let u = 45;
      n.FieldOfView !== void 0 && (u = n.FieldOfView.value);
      const h = n.FocalLength ? n.FocalLength.value : null;
      switch (s) {
        case 0:
          t = new Mt(u, c, i, r), h !== null && t.setFocalLength(h);
          break;
        case 1:
          t = new jt(
            -a / 2,
            a / 2,
            l / 2,
            -l / 2,
            i,
            r
          );
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown camera type " + s + "."), t = new St();
          break;
      }
    }
    return t;
  }
  // Create a DirectionalLight, PointLight or SpotLight
  createLight(e) {
    let t, n;
    if (e.children.forEach(function(s) {
      const i = Ae.Objects.NodeAttribute[s.ID];
      i !== void 0 && (n = i);
    }), n === void 0)
      t = new St();
    else {
      let s;
      n.LightType === void 0 ? s = 0 : s = n.LightType.value;
      let i = 16777215;
      n.Color !== void 0 && (i = new Be().fromArray(n.Color.value));
      let r = n.Intensity === void 0 ? 1 : n.Intensity.value / 100;
      n.CastLightOnObject !== void 0 && n.CastLightOnObject.value === 0 && (r = 0);
      let a = 0;
      n.FarAttenuationEnd !== void 0 && (n.EnableFarAttenuation !== void 0 && n.EnableFarAttenuation.value === 0 ? a = 0 : a = n.FarAttenuationEnd.value);
      const l = 1;
      switch (s) {
        case 0:
          t = new zi(i, r, a, l);
          break;
        case 1:
          t = new Wo(i, r);
          break;
        case 2:
          let c = Math.PI / 3;
          n.InnerAngle !== void 0 && (c = We.degToRad(n.InnerAngle.value));
          let u = 0;
          n.OuterAngle !== void 0 && (u = We.degToRad(n.OuterAngle.value), u = Math.max(u, 1)), t = new Xo(i, r, a, c, u, l);
          break;
        default:
          console.warn(
            "THREE.FBXLoader: Unknown light type " + n.LightType.value + ", defaulting to a PointLight."
          ), t = new zi(i, r);
          break;
      }
      n.CastShadows !== void 0 && n.CastShadows.value === 1 && (t.castShadow = !0);
    }
    return t;
  }
  createMesh(e, t, n) {
    let s, i = null, r = null;
    const a = [];
    return e.children.forEach(function(l) {
      t.has(l.ID) && (i = t.get(l.ID)), n.has(l.ID) && a.push(n.get(l.ID));
    }), a.length > 1 ? r = a : a.length > 0 ? r = a[0] : (r = new oi({ color: 13421772 }), a.push(r)), "color" in i.attributes && a.forEach(function(l) {
      l.vertexColors = !0;
    }), i.FBX_Deformer ? (s = new $o(i, r), s.normalizeSkinWeights()) : s = new ae(i, r), s;
  }
  createCurve(e, t) {
    const n = e.children.reduce(function(i, r) {
      return t.has(r.ID) && (i = t.get(r.ID)), i;
    }, null), s = new qs({ color: 3342591, linewidth: 1 });
    return new Ie(n, s);
  }
  // parse the model node for transform data
  getTransformData(e, t) {
    const n = {};
    "InheritType" in t && (n.inheritType = parseInt(t.InheritType.value)), "RotationOrder" in t ? n.eulerOrder = Aa(t.RotationOrder.value) : n.eulerOrder = "ZYX", "Lcl_Translation" in t && (n.translation = t.Lcl_Translation.value), "PreRotation" in t && (n.preRotation = t.PreRotation.value), "Lcl_Rotation" in t && (n.rotation = t.Lcl_Rotation.value), "PostRotation" in t && (n.postRotation = t.PostRotation.value), "Lcl_Scaling" in t && (n.scale = t.Lcl_Scaling.value), "ScalingOffset" in t && (n.scalingOffset = t.ScalingOffset.value), "ScalingPivot" in t && (n.scalingPivot = t.ScalingPivot.value), "RotationOffset" in t && (n.rotationOffset = t.RotationOffset.value), "RotationPivot" in t && (n.rotationPivot = t.RotationPivot.value), e.userData.transformData = n;
  }
  setLookAtProperties(e, t) {
    "LookAtProperty" in t && Xe.get(e.ID).children.forEach(function(s) {
      if (s.relationship === "LookAtProperty") {
        const i = Ae.Objects.Model[s.ID];
        if ("Lcl_Translation" in i) {
          const r = i.Lcl_Translation.value;
          e.target !== void 0 ? (e.target.position.fromArray(r), ut.add(e.target)) : e.lookAt(new ee().fromArray(r));
        }
      }
    });
  }
  bindSkeleton(e, t, n) {
    const s = this.parsePoseNodes();
    for (const i in e) {
      const r = e[i];
      Xe.get(parseInt(r.ID)).parents.forEach(function(l) {
        if (t.has(l.ID)) {
          const c = l.ID;
          Xe.get(c).parents.forEach(function(h) {
            n.has(h.ID) && n.get(h.ID).bind(new Ko(r.bones), s[h.ID]);
          });
        }
      });
    }
  }
  parsePoseNodes() {
    const e = {};
    if ("Pose" in Ae.Objects) {
      const t = Ae.Objects.Pose;
      for (const n in t)
        if (t[n].attrType === "BindPose" && t[n].NbPoseNodes > 0) {
          const s = t[n].PoseNode;
          Array.isArray(s) ? s.forEach(function(i) {
            e[i.Node] = new De().fromArray(i.Matrix.a);
          }) : e[s.Node] = new De().fromArray(s.Matrix.a);
        }
    }
    return e;
  }
  // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light
  createAmbientLight() {
    if ("GlobalSettings" in Ae && "AmbientColor" in Ae.GlobalSettings) {
      const e = Ae.GlobalSettings.AmbientColor.value, t = e[0], n = e[1], s = e[2];
      if (t !== 0 || n !== 0 || s !== 0) {
        const i = new Be(t, n, s);
        ut.add(new Tl(i, 1));
      }
    }
  }
}
class Ku {
  // Parse nodes in FBXTree.Objects.Geometry
  parse(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Geometry" in Ae.Objects) {
      const n = Ae.Objects.Geometry;
      for (const s in n) {
        const i = Xe.get(parseInt(s)), r = this.parseGeometry(i, n[s], e);
        t.set(parseInt(s), r);
      }
    }
    return t;
  }
  // Parse single node in FBXTree.Objects.Geometry
  parseGeometry(e, t, n) {
    switch (t.attrType) {
      case "Mesh":
        return this.parseMeshGeometry(e, t, n);
      case "NurbsCurve":
        return this.parseNurbsGeometry(t);
    }
  }
  // Parse single node mesh geometry in FBXTree.Objects.Geometry
  parseMeshGeometry(e, t, n) {
    const s = n.skeletons, i = [], r = e.parents.map(function(h) {
      return Ae.Objects.Model[h.ID];
    });
    if (r.length === 0)
      return;
    const a = e.children.reduce(function(h, m) {
      return s[m.ID] !== void 0 && (h = s[m.ID]), h;
    }, null);
    e.children.forEach(function(h) {
      n.morphTargets[h.ID] !== void 0 && i.push(n.morphTargets[h.ID]);
    });
    const l = r[0], c = {};
    "RotationOrder" in l && (c.eulerOrder = Aa(l.RotationOrder.value)), "InheritType" in l && (c.inheritType = parseInt(l.InheritType.value)), "GeometricTranslation" in l && (c.translation = l.GeometricTranslation.value), "GeometricRotation" in l && (c.rotation = l.GeometricRotation.value), "GeometricScaling" in l && (c.scale = l.GeometricScaling.value);
    const u = Sa(c);
    return this.genGeometry(t, a, i, u);
  }
  // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
  genGeometry(e, t, n, s) {
    const i = new rt();
    e.attrName && (i.name = e.attrName);
    const r = this.parseGeoNode(e, t), a = this.genBuffers(r), l = new it(a.vertex, 3);
    if (l.applyMatrix4(s), i.setAttribute("position", l), a.colors.length > 0 && i.setAttribute("color", new it(a.colors, 3)), t && (i.setAttribute("skinIndex", new bl(a.weightsIndices, 4)), i.setAttribute("skinWeight", new it(a.vertexWeights, 4)), i.FBX_Deformer = t), a.normal.length > 0) {
      const c = new vn().getNormalMatrix(s), u = new it(a.normal, 3);
      u.applyNormalMatrix(c), i.setAttribute("normal", u);
    }
    if (a.uvs.forEach(function(c, u) {
      let h = "uv" + (u + 1).toString();
      u === 0 && (h = "uv"), i.setAttribute(h, new it(a.uvs[u], 2));
    }), r.material && r.material.mappingType !== "AllSame") {
      let c = a.materialIndex[0], u = 0;
      if (a.materialIndex.forEach(function(h, m) {
        h !== c && (i.addGroup(u, m - u, c), c = h, u = m);
      }), i.groups.length > 0) {
        const h = i.groups[i.groups.length - 1], m = h.start + h.count;
        m !== a.materialIndex.length && i.addGroup(m, a.materialIndex.length - m, c);
      }
      i.groups.length === 0 && i.addGroup(0, a.materialIndex.length, a.materialIndex[0]);
    }
    return this.addMorphTargets(i, e, n, s), i;
  }
  parseGeoNode(e, t) {
    const n = {};
    if (n.vertexPositions = e.Vertices !== void 0 ? e.Vertices.a : [], n.vertexIndices = e.PolygonVertexIndex !== void 0 ? e.PolygonVertexIndex.a : [], e.LayerElementColor && (n.color = this.parseVertexColors(e.LayerElementColor[0])), e.LayerElementMaterial && (n.material = this.parseMaterialIndices(e.LayerElementMaterial[0])), e.LayerElementNormal && (n.normal = this.parseNormals(e.LayerElementNormal[0])), e.LayerElementUV) {
      n.uv = [];
      let s = 0;
      for (; e.LayerElementUV[s]; )
        e.LayerElementUV[s].UV && n.uv.push(this.parseUVs(e.LayerElementUV[s])), s++;
    }
    return n.weightTable = {}, t !== null && (n.skeleton = t, t.rawBones.forEach(function(s, i) {
      s.indices.forEach(function(r, a) {
        n.weightTable[r] === void 0 && (n.weightTable[r] = []), n.weightTable[r].push({
          id: i,
          weight: s.weights[a]
        });
      });
    })), n;
  }
  genBuffers(e) {
    const t = {
      vertex: [],
      normal: [],
      colors: [],
      uvs: [],
      materialIndex: [],
      vertexWeights: [],
      weightsIndices: []
    };
    let n = 0, s = 0, i = !1, r = [], a = [], l = [], c = [], u = [], h = [];
    const m = this;
    return e.vertexIndices.forEach(function(p, v) {
      let _, y = !1;
      p < 0 && (p = p ^ -1, y = !0);
      let E = [], R = [];
      if (r.push(p * 3, p * 3 + 1, p * 3 + 2), e.color) {
        const T = Ps(v, n, p, e.color);
        l.push(T[0], T[1], T[2]);
      }
      if (e.skeleton) {
        if (e.weightTable[p] !== void 0 && e.weightTable[p].forEach(function(T) {
          R.push(T.weight), E.push(T.id);
        }), R.length > 4) {
          i || (console.warn(
            "THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."
          ), i = !0);
          const T = [0, 0, 0, 0], g = [0, 0, 0, 0];
          R.forEach(function(A, x) {
            let M = A, d = E[x];
            g.forEach(function(w, f, P) {
              if (M > w) {
                P[f] = M, M = w;
                const I = T[f];
                T[f] = d, d = I;
              }
            });
          }), E = T, R = g;
        }
        for (; R.length < 4; )
          R.push(0), E.push(0);
        for (let T = 0; T < 4; ++T)
          u.push(R[T]), h.push(E[T]);
      }
      if (e.normal) {
        const T = Ps(v, n, p, e.normal);
        a.push(T[0], T[1], T[2]);
      }
      e.material && e.material.mappingType !== "AllSame" && (_ = Ps(v, n, p, e.material)[0]), e.uv && e.uv.forEach(function(T, g) {
        const A = Ps(v, n, p, T);
        c[g] === void 0 && (c[g] = []), c[g].push(A[0]), c[g].push(A[1]);
      }), s++, y && (m.genFace(
        t,
        e,
        r,
        _,
        a,
        l,
        c,
        u,
        h,
        s
      ), n++, s = 0, r = [], a = [], l = [], c = [], u = [], h = []);
    }), t;
  }
  // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
  genFace(e, t, n, s, i, r, a, l, c, u) {
    for (let h = 2; h < u; h++)
      e.vertex.push(t.vertexPositions[n[0]]), e.vertex.push(t.vertexPositions[n[1]]), e.vertex.push(t.vertexPositions[n[2]]), e.vertex.push(t.vertexPositions[n[(h - 1) * 3]]), e.vertex.push(t.vertexPositions[n[(h - 1) * 3 + 1]]), e.vertex.push(t.vertexPositions[n[(h - 1) * 3 + 2]]), e.vertex.push(t.vertexPositions[n[h * 3]]), e.vertex.push(t.vertexPositions[n[h * 3 + 1]]), e.vertex.push(t.vertexPositions[n[h * 3 + 2]]), t.skeleton && (e.vertexWeights.push(l[0]), e.vertexWeights.push(l[1]), e.vertexWeights.push(l[2]), e.vertexWeights.push(l[3]), e.vertexWeights.push(l[(h - 1) * 4]), e.vertexWeights.push(l[(h - 1) * 4 + 1]), e.vertexWeights.push(l[(h - 1) * 4 + 2]), e.vertexWeights.push(l[(h - 1) * 4 + 3]), e.vertexWeights.push(l[h * 4]), e.vertexWeights.push(l[h * 4 + 1]), e.vertexWeights.push(l[h * 4 + 2]), e.vertexWeights.push(l[h * 4 + 3]), e.weightsIndices.push(c[0]), e.weightsIndices.push(c[1]), e.weightsIndices.push(c[2]), e.weightsIndices.push(c[3]), e.weightsIndices.push(c[(h - 1) * 4]), e.weightsIndices.push(c[(h - 1) * 4 + 1]), e.weightsIndices.push(c[(h - 1) * 4 + 2]), e.weightsIndices.push(c[(h - 1) * 4 + 3]), e.weightsIndices.push(c[h * 4]), e.weightsIndices.push(c[h * 4 + 1]), e.weightsIndices.push(c[h * 4 + 2]), e.weightsIndices.push(c[h * 4 + 3])), t.color && (e.colors.push(r[0]), e.colors.push(r[1]), e.colors.push(r[2]), e.colors.push(r[(h - 1) * 3]), e.colors.push(r[(h - 1) * 3 + 1]), e.colors.push(r[(h - 1) * 3 + 2]), e.colors.push(r[h * 3]), e.colors.push(r[h * 3 + 1]), e.colors.push(r[h * 3 + 2])), t.material && t.material.mappingType !== "AllSame" && (e.materialIndex.push(s), e.materialIndex.push(s), e.materialIndex.push(s)), t.normal && (e.normal.push(i[0]), e.normal.push(i[1]), e.normal.push(i[2]), e.normal.push(i[(h - 1) * 3]), e.normal.push(i[(h - 1) * 3 + 1]), e.normal.push(i[(h - 1) * 3 + 2]), e.normal.push(i[h * 3]), e.normal.push(i[h * 3 + 1]), e.normal.push(i[h * 3 + 2])), t.uv && t.uv.forEach(function(m, p) {
        e.uvs[p] === void 0 && (e.uvs[p] = []), e.uvs[p].push(a[p][0]), e.uvs[p].push(a[p][1]), e.uvs[p].push(a[p][(h - 1) * 2]), e.uvs[p].push(a[p][(h - 1) * 2 + 1]), e.uvs[p].push(a[p][h * 2]), e.uvs[p].push(a[p][h * 2 + 1]);
      });
  }
  addMorphTargets(e, t, n, s) {
    if (n.length === 0)
      return;
    e.morphTargetsRelative = !0, e.morphAttributes.position = [];
    const i = this;
    n.forEach(function(r) {
      r.rawTargets.forEach(function(a) {
        const l = Ae.Objects.Geometry[a.geoID];
        l !== void 0 && i.genMorphGeometry(e, t, l, s, a.name);
      });
    });
  }
  // a morph geometry node is similar to a standard  node, and the node is also contained
  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
  // and a special attribute Index defining which vertices of the original geometry are affected
  // Normal and position attributes only have data for the vertices that are affected by the morph
  genMorphGeometry(e, t, n, s, i) {
    const r = t.PolygonVertexIndex !== void 0 ? t.PolygonVertexIndex.a : [], a = n.Vertices !== void 0 ? n.Vertices.a : [], l = n.Indexes !== void 0 ? n.Indexes.a : [], c = e.attributes.position.count * 3, u = new Float32Array(c);
    for (let v = 0; v < l.length; v++) {
      const _ = l[v] * 3;
      u[_] = a[v * 3], u[_ + 1] = a[v * 3 + 1], u[_ + 2] = a[v * 3 + 2];
    }
    const h = {
      vertexIndices: r,
      vertexPositions: u
    }, m = this.genBuffers(h), p = new it(m.vertex, 3);
    p.name = i || n.attrName, p.applyMatrix4(s), e.morphAttributes.position.push(p);
  }
  // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
  parseNormals(e) {
    const t = e.MappingInformationType, n = e.ReferenceInformationType, s = e.Normals.a;
    let i = [];
    return n === "IndexToDirect" && ("NormalIndex" in e ? i = e.NormalIndex.a : "NormalsIndex" in e && (i = e.NormalsIndex.a)), {
      dataSize: 3,
      buffer: s,
      indices: i,
      mappingType: t,
      referenceType: n
    };
  }
  // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
  parseUVs(e) {
    const t = e.MappingInformationType, n = e.ReferenceInformationType, s = e.UV.a;
    let i = [];
    return n === "IndexToDirect" && (i = e.UVIndex.a), {
      dataSize: 2,
      buffer: s,
      indices: i,
      mappingType: t,
      referenceType: n
    };
  }
  // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
  parseVertexColors(e) {
    const t = e.MappingInformationType, n = e.ReferenceInformationType, s = e.Colors.a;
    let i = [];
    return n === "IndexToDirect" && (i = e.ColorIndex.a), {
      dataSize: 4,
      buffer: s,
      indices: i,
      mappingType: t,
      referenceType: n
    };
  }
  // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
  parseMaterialIndices(e) {
    const t = e.MappingInformationType, n = e.ReferenceInformationType;
    if (t === "NoMappingInformation")
      return {
        dataSize: 1,
        buffer: [0],
        indices: [0],
        mappingType: "AllSame",
        referenceType: n
      };
    const s = e.Materials.a, i = [];
    for (let r = 0; r < s.length; ++r)
      i.push(r);
    return {
      dataSize: 1,
      buffer: s,
      indices: i,
      mappingType: t,
      referenceType: n
    };
  }
  // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
  parseNurbsGeometry(e) {
    if (Yr === void 0)
      return console.error(
        "THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."
      ), new rt();
    const t = parseInt(e.Order);
    if (isNaN(t))
      return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new rt();
    const n = t - 1, s = e.KnotVector.a, i = [], r = e.Points.a;
    for (let h = 0, m = r.length; h < m; h += 4)
      i.push(new ht().fromArray(r, h));
    let a, l;
    if (e.Form === "Closed")
      i.push(i[0]);
    else if (e.Form === "Periodic") {
      a = n, l = s.length - 1 - a;
      for (let h = 0; h < n; ++h)
        i.push(i[h]);
    }
    const u = new Yr(n, s, i, a, l).getPoints(i.length * 12);
    return new rt().setFromPoints(u);
  }
}
class qu {
  // take raw animation clips and turn them into three.js animation clips
  parse() {
    const e = [], t = this.parseClips();
    if (t !== void 0)
      for (const n in t) {
        const s = t[n], i = this.addClip(s);
        e.push(i);
      }
    return e;
  }
  parseClips() {
    if (Ae.Objects.AnimationCurve === void 0)
      return;
    const e = this.parseAnimationCurveNodes();
    this.parseAnimationCurves(e);
    const t = this.parseAnimationLayers(e);
    return this.parseAnimStacks(t);
  }
  // parse nodes in FBXTree.Objects.AnimationCurveNode
  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
  // and is referenced by an AnimationLayer
  parseAnimationCurveNodes() {
    const e = Ae.Objects.AnimationCurveNode, t = /* @__PURE__ */ new Map();
    for (const n in e) {
      const s = e[n];
      if (s.attrName.match(/S|R|T|DeformPercent/) !== null) {
        const i = {
          id: s.id,
          attr: s.attrName,
          curves: {}
        };
        t.set(i.id, i);
      }
    }
    return t;
  }
  // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
  // axis ( e.g. times and values of x rotation)
  parseAnimationCurves(e) {
    const t = Ae.Objects.AnimationCurve;
    for (const n in t) {
      const s = {
        id: t[n].id,
        times: t[n].KeyTime.a.map(nh),
        values: t[n].KeyValueFloat.a
      }, i = Xe.get(s.id);
      if (i !== void 0) {
        const r = i.parents[0].ID, a = i.parents[0].relationship;
        a.match(/X/) ? e.get(r).curves.x = s : a.match(/Y/) ? e.get(r).curves.y = s : a.match(/Z/) ? e.get(r).curves.z = s : a.match(/d|DeformPercent/) && e.has(r) && (e.get(r).curves.morph = s);
      }
    }
  }
  // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
  // to various AnimationCurveNodes and is referenced by an AnimationStack node
  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
  parseAnimationLayers(e) {
    const t = Ae.Objects.AnimationLayer, n = /* @__PURE__ */ new Map();
    for (const s in t) {
      const i = [], r = Xe.get(parseInt(s));
      r !== void 0 && (r.children.forEach(function(l, c) {
        if (e.has(l.ID)) {
          const u = e.get(l.ID);
          if (u.curves.x !== void 0 || u.curves.y !== void 0 || u.curves.z !== void 0) {
            if (i[c] === void 0) {
              const h = Xe.get(l.ID).parents.filter(function(m) {
                return m.relationship !== void 0;
              })[0].ID;
              if (h !== void 0) {
                const m = Ae.Objects.Model[h.toString()];
                if (m === void 0) {
                  console.warn("THREE.FBXLoader: Encountered a unused curve.", l);
                  return;
                }
                const p = {
                  modelName: m.attrName ? Yt.sanitizeNodeName(m.attrName) : "",
                  ID: m.id,
                  initialPosition: [0, 0, 0],
                  initialRotation: [0, 0, 0],
                  initialScale: [1, 1, 1]
                };
                ut.traverse(function(v) {
                  v.ID === m.id && (p.transform = v.matrix, v.userData.transformData && (p.eulerOrder = v.userData.transformData.eulerOrder));
                }), p.transform || (p.transform = new De()), "PreRotation" in m && (p.preRotation = m.PreRotation.value), "PostRotation" in m && (p.postRotation = m.PostRotation.value), i[c] = p;
              }
            }
            i[c] && (i[c][u.attr] = u);
          } else if (u.curves.morph !== void 0) {
            if (i[c] === void 0) {
              const h = Xe.get(l.ID).parents.filter(function(E) {
                return E.relationship !== void 0;
              })[0].ID, m = Xe.get(h).parents[0].ID, p = Xe.get(m).parents[0].ID, v = Xe.get(p).parents[0].ID, _ = Ae.Objects.Model[v], y = {
                modelName: _.attrName ? Yt.sanitizeNodeName(_.attrName) : "",
                morphName: Ae.Objects.Deformer[h].attrName
              };
              i[c] = y;
            }
            i[c][u.attr] = u;
          }
        }
      }), n.set(parseInt(s), i));
    }
    return n;
  }
  // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
  // hierarchy. Each Stack node will be used to create a AnimationClip
  parseAnimStacks(e) {
    const t = Ae.Objects.AnimationStack, n = {};
    for (const s in t) {
      const i = Xe.get(parseInt(s)).children;
      i.length > 1 && console.warn(
        "THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers."
      );
      const r = e.get(i[0].ID);
      n[s] = {
        name: t[s].attrName,
        layer: r
      };
    }
    return n;
  }
  addClip(e) {
    let t = [];
    const n = this;
    return e.layer.forEach(function(s) {
      t = t.concat(n.generateTracks(s));
    }), new qo(e.name, -1, t);
  }
  generateTracks(e) {
    const t = [];
    let n = new ee(), s = new He(), i = new ee();
    if (e.transform && e.transform.decompose(n, s, i), n = n.toArray(), s = new _n().setFromQuaternion(s, e.eulerOrder).toArray(), i = i.toArray(), e.T !== void 0 && Object.keys(e.T.curves).length > 0) {
      const r = this.generateVectorTrack(
        e.modelName,
        e.T.curves,
        n,
        "position"
      );
      r !== void 0 && t.push(r);
    }
    if (e.R !== void 0 && Object.keys(e.R.curves).length > 0) {
      const r = this.generateRotationTrack(
        e.modelName,
        e.R.curves,
        s,
        e.preRotation,
        e.postRotation,
        e.eulerOrder
      );
      r !== void 0 && t.push(r);
    }
    if (e.S !== void 0 && Object.keys(e.S.curves).length > 0) {
      const r = this.generateVectorTrack(e.modelName, e.S.curves, i, "scale");
      r !== void 0 && t.push(r);
    }
    if (e.DeformPercent !== void 0) {
      const r = this.generateMorphTrack(e);
      r !== void 0 && t.push(r);
    }
    return t;
  }
  generateVectorTrack(e, t, n, s) {
    const i = this.getTimesForAllAxes(t), r = this.getKeyframeTrackValues(i, t, n);
    return new Qo(e + "." + s, i, r);
  }
  generateRotationTrack(e, t, n, s, i, r) {
    t.x !== void 0 && (this.interpolateRotations(t.x), t.x.values = t.x.values.map(We.degToRad)), t.y !== void 0 && (this.interpolateRotations(t.y), t.y.values = t.y.values.map(We.degToRad)), t.z !== void 0 && (this.interpolateRotations(t.z), t.z.values = t.z.values.map(We.degToRad));
    const a = this.getTimesForAllAxes(t), l = this.getKeyframeTrackValues(a, t, n);
    s !== void 0 && (s = s.map(We.degToRad), s.push(r), s = new _n().fromArray(s), s = new He().setFromEuler(s)), i !== void 0 && (i = i.map(We.degToRad), i.push(r), i = new _n().fromArray(i), i = new He().setFromEuler(i).invert());
    const c = new He(), u = new _n(), h = [];
    for (let m = 0; m < l.length; m += 3)
      u.set(l[m], l[m + 1], l[m + 2], r), c.setFromEuler(u), s !== void 0 && c.premultiply(s), i !== void 0 && c.multiply(i), c.toArray(h, m / 3 * 4);
    return new Gi(e + ".quaternion", a, h);
  }
  generateMorphTrack(e) {
    const t = e.DeformPercent.curves.morph, n = t.values.map(function(i) {
      return i / 100;
    }), s = ut.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
    return new Jo(
      e.modelName + ".morphTargetInfluences[" + s + "]",
      t.times,
      n
    );
  }
  // For all animated objects, times are defined separately for each axis
  // Here we'll combine the times into one sorted array without duplicates
  getTimesForAllAxes(e) {
    let t = [];
    if (e.x !== void 0 && (t = t.concat(e.x.times)), e.y !== void 0 && (t = t.concat(e.y.times)), e.z !== void 0 && (t = t.concat(e.z.times)), t = t.sort(function(n, s) {
      return n - s;
    }), t.length > 1) {
      let n = 1, s = t[0];
      for (let i = 1; i < t.length; i++) {
        const r = t[i];
        r !== s && (t[n] = r, s = r, n++);
      }
      t = t.slice(0, n);
    }
    return t;
  }
  getKeyframeTrackValues(e, t, n) {
    const s = n, i = [];
    let r = -1, a = -1, l = -1;
    return e.forEach(function(c) {
      if (t.x && (r = t.x.times.indexOf(c)), t.y && (a = t.y.times.indexOf(c)), t.z && (l = t.z.times.indexOf(c)), r !== -1) {
        const u = t.x.values[r];
        i.push(u), s[0] = u;
      } else
        i.push(s[0]);
      if (a !== -1) {
        const u = t.y.values[a];
        i.push(u), s[1] = u;
      } else
        i.push(s[1]);
      if (l !== -1) {
        const u = t.z.values[l];
        i.push(u), s[2] = u;
      } else
        i.push(s[2]);
    }), i;
  }
  // Rotations are defined as Euler angles which can have values  of any size
  // These will be converted to quaternions which don't support values greater than
  // PI, so we'll interpolate large rotations
  interpolateRotations(e) {
    for (let t = 1; t < e.values.length; t++) {
      const n = e.values[t - 1], s = e.values[t] - n, i = Math.abs(s);
      if (i >= 180) {
        const r = i / 180, a = s / r;
        let l = n + a;
        const c = e.times[t - 1], h = (e.times[t] - c) / r;
        let m = c + h;
        const p = [], v = [];
        for (; m < e.times[t]; )
          p.push(m), m += h, v.push(l), l += a;
        e.times = $r(e.times, t, p), e.values = $r(e.values, t, v);
      }
    }
  }
}
class Qu {
  getPrevNode() {
    return this.nodeStack[this.currentIndent - 2];
  }
  getCurrentNode() {
    return this.nodeStack[this.currentIndent - 1];
  }
  getCurrentProp() {
    return this.currentProp;
  }
  pushStack(e) {
    this.nodeStack.push(e), this.currentIndent += 1;
  }
  popStack() {
    this.nodeStack.pop(), this.currentIndent -= 1;
  }
  setCurrentProp(e, t) {
    this.currentProp = e, this.currentPropName = t;
  }
  parse(e) {
    this.currentIndent = 0, this.allNodes = new Ma(), this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
    const t = this, n = e.split(/[\r\n]+/);
    return n.forEach(function(s, i) {
      const r = s.match(/^[\s\t]*;/), a = s.match(/^[\s\t]*$/);
      if (r || a)
        return;
      const l = s.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", ""), c = s.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"), u = s.match("^\\t{" + (t.currentIndent - 1) + "}}");
      l ? t.parseNodeBegin(s, l) : c ? t.parseNodeProperty(s, c, n[++i]) : u ? t.popStack() : s.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(s);
    }), this.allNodes;
  }
  parseNodeBegin(e, t) {
    const n = t[1].trim().replace(/^"/, "").replace(/"$/, ""), s = t[2].split(",").map(function(l) {
      return l.trim().replace(/^"/, "").replace(/"$/, "");
    }), i = { name: n }, r = this.parseNodeAttr(s), a = this.getCurrentNode();
    this.currentIndent === 0 ? this.allNodes.add(n, i) : n in a ? (n === "PoseNode" ? a.PoseNode.push(i) : a[n].id !== void 0 && (a[n] = {}, a[n][a[n].id] = a[n]), r.id !== "" && (a[n][r.id] = i)) : typeof r.id == "number" ? (a[n] = {}, a[n][r.id] = i) : n !== "Properties70" && (n === "PoseNode" ? a[n] = [i] : a[n] = i), typeof r.id == "number" && (i.id = r.id), r.name !== "" && (i.attrName = r.name), r.type !== "" && (i.attrType = r.type), this.pushStack(i);
  }
  parseNodeAttr(e) {
    let t = e[0];
    e[0] !== "" && (t = parseInt(e[0]), isNaN(t) && (t = e[0]));
    let n = "", s = "";
    return e.length > 1 && (n = e[1].replace(/^(\w+)::/, ""), s = e[2]), { id: t, name: n, type: s };
  }
  parseNodeProperty(e, t, n) {
    let s = t[1].replace(/^"/, "").replace(/"$/, "").trim(), i = t[2].replace(/^"/, "").replace(/"$/, "").trim();
    s === "Content" && i === "," && (i = n.replace(/"/g, "").replace(/,$/, "").trim());
    const r = this.getCurrentNode();
    if (r.name === "Properties70") {
      this.parseNodeSpecialProperty(e, s, i);
      return;
    }
    if (s === "C") {
      const l = i.split(",").slice(1), c = parseInt(l[0]), u = parseInt(l[1]);
      let h = i.split(",").slice(3);
      h = h.map(function(m) {
        return m.trim().replace(/^"/, "");
      }), s = "connections", i = [c, u], ih(i, h), r[s] === void 0 && (r[s] = []);
    }
    s === "Node" && (r.id = i), s in r && Array.isArray(r[s]) ? r[s].push(i) : s !== "a" ? r[s] = i : r.a = i, this.setCurrentProp(r, s), s === "a" && i.slice(-1) !== "," && (r.a = _i(i));
  }
  parseNodePropertyContinued(e) {
    const t = this.getCurrentNode();
    t.a += e, e.slice(-1) !== "," && (t.a = _i(t.a));
  }
  // parse "Property70"
  parseNodeSpecialProperty(e, t, n) {
    const s = n.split('",').map(function(u) {
      return u.trim().replace(/^\"/, "").replace(/\s/, "_");
    }), i = s[0], r = s[1], a = s[2], l = s[3];
    let c = s[4];
    switch (r) {
      case "int":
      case "enum":
      case "bool":
      case "ULongLong":
      case "double":
      case "Number":
      case "FieldOfView":
        c = parseFloat(c);
        break;
      case "Color":
      case "ColorRGB":
      case "Vector3D":
      case "Lcl_Translation":
      case "Lcl_Rotation":
      case "Lcl_Scaling":
        c = _i(c);
        break;
    }
    this.getPrevNode()[i] = {
      type: r,
      type2: a,
      flag: l,
      value: c
    }, this.setCurrentProp(this.getPrevNode(), i);
  }
}
class Ju {
  parse(e) {
    const t = new Xr(e);
    t.skip(23);
    const n = t.getUint32();
    if (n < 6400)
      throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + n);
    const s = new Ma();
    for (; !this.endOfContent(t); ) {
      const i = this.parseNode(t, n);
      i !== null && s.add(i.name, i);
    }
    return s;
  }
  // Check if reader has reached the end of content.
  endOfContent(e) {
    return e.size() % 16 === 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size();
  }
  // recursively parse nodes until the end of the file is reached
  parseNode(e, t) {
    const n = {}, s = t >= 7500 ? e.getUint64() : e.getUint32(), i = t >= 7500 ? e.getUint64() : e.getUint32();
    t >= 7500 ? e.getUint64() : e.getUint32();
    const r = e.getUint8(), a = e.getString(r);
    if (s === 0)
      return null;
    const l = [];
    for (let m = 0; m < i; m++)
      l.push(this.parseProperty(e));
    const c = l.length > 0 ? l[0] : "", u = l.length > 1 ? l[1] : "", h = l.length > 2 ? l[2] : "";
    for (n.singleProperty = i === 1 && e.getOffset() === s; s > e.getOffset(); ) {
      const m = this.parseNode(e, t);
      m !== null && this.parseSubNode(a, n, m);
    }
    return n.propertyList = l, typeof c == "number" && (n.id = c), u !== "" && (n.attrName = u), h !== "" && (n.attrType = h), a !== "" && (n.name = a), n;
  }
  parseSubNode(e, t, n) {
    if (n.singleProperty === !0) {
      const s = n.propertyList[0];
      Array.isArray(s) ? (t[n.name] = n, n.a = s) : t[n.name] = s;
    } else if (e === "Connections" && n.name === "C") {
      const s = [];
      n.propertyList.forEach(function(i, r) {
        r !== 0 && s.push(i);
      }), t.connections === void 0 && (t.connections = []), t.connections.push(s);
    } else if (n.name === "Properties70")
      Object.keys(n).forEach(function(i) {
        t[i] = n[i];
      });
    else if (e === "Properties70" && n.name === "P") {
      let s = n.propertyList[0], i = n.propertyList[1];
      const r = n.propertyList[2], a = n.propertyList[3];
      let l;
      s.indexOf("Lcl ") === 0 && (s = s.replace("Lcl ", "Lcl_")), i.indexOf("Lcl ") === 0 && (i = i.replace("Lcl ", "Lcl_")), i === "Color" || i === "ColorRGB" || i === "Vector" || i === "Vector3D" || i.indexOf("Lcl_") === 0 ? l = [n.propertyList[4], n.propertyList[5], n.propertyList[6]] : l = n.propertyList[4], t[s] = {
        type: i,
        type2: r,
        flag: a,
        value: l
      };
    } else
      t[n.name] === void 0 ? typeof n.id == "number" ? (t[n.name] = {}, t[n.name][n.id] = n) : t[n.name] = n : n.name === "PoseNode" ? (Array.isArray(t[n.name]) || (t[n.name] = [t[n.name]]), t[n.name].push(n)) : t[n.name][n.id] === void 0 && (t[n.name][n.id] = n);
  }
  parseProperty(e) {
    const t = e.getString(1);
    let n;
    switch (t) {
      case "C":
        return e.getBoolean();
      case "D":
        return e.getFloat64();
      case "F":
        return e.getFloat32();
      case "I":
        return e.getInt32();
      case "L":
        return e.getInt64();
      case "R":
        return n = e.getUint32(), e.getArrayBuffer(n);
      case "S":
        return n = e.getUint32(), e.getString(n);
      case "Y":
        return e.getInt16();
      case "b":
      case "c":
      case "d":
      case "f":
      case "i":
      case "l":
        const s = e.getUint32(), i = e.getUint32(), r = e.getUint32();
        if (i === 0)
          switch (t) {
            case "b":
            case "c":
              return e.getBooleanArray(s);
            case "d":
              return e.getFloat64Array(s);
            case "f":
              return e.getFloat32Array(s);
            case "i":
              return e.getInt32Array(s);
            case "l":
              return e.getInt64Array(s);
          }
        const a = Gc(new Uint8Array(e.getArrayBuffer(r))), l = new Xr(a.buffer);
        switch (t) {
          case "b":
          case "c":
            return l.getBooleanArray(s);
          case "d":
            return l.getFloat64Array(s);
          case "f":
            return l.getFloat32Array(s);
          case "i":
            return l.getInt32Array(s);
          case "l":
            return l.getInt64Array(s);
        }
      default:
        throw new Error("THREE.FBXLoader: Unknown property type " + t);
    }
  }
}
class Xr {
  constructor(e, t) {
    this.dv = new DataView(e), this.offset = 0, this.littleEndian = t !== void 0 ? t : !0;
  }
  getOffset() {
    return this.offset;
  }
  size() {
    return this.dv.buffer.byteLength;
  }
  skip(e) {
    this.offset += e;
  }
  // seems like true/false representation depends on exporter.
  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
  // then sees LSB.
  getBoolean() {
    return (this.getUint8() & 1) === 1;
  }
  getBooleanArray(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push(this.getBoolean());
    return t;
  }
  getUint8() {
    const e = this.dv.getUint8(this.offset);
    return this.offset += 1, e;
  }
  getInt16() {
    const e = this.dv.getInt16(this.offset, this.littleEndian);
    return this.offset += 2, e;
  }
  getInt32() {
    const e = this.dv.getInt32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getInt32Array(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push(this.getInt32());
    return t;
  }
  getUint32() {
    const e = this.dv.getUint32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  // JavaScript doesn't support 64-bit integer so calculate this here
  // 1 << 32 will return 1 so using multiply operation instead here.
  // There's a possibility that this method returns wrong value if the value
  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
  // TODO: safely handle 64-bit integer
  getInt64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t & 2147483648 ? (t = ~t & 4294967295, e = ~e & 4294967295, e === 4294967295 && (t = t + 1 & 4294967295), e = e + 1 & 4294967295, -(t * 4294967296 + e)) : t * 4294967296 + e;
  }
  getInt64Array(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push(this.getInt64());
    return t;
  }
  // Note: see getInt64() comment
  getUint64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t * 4294967296 + e;
  }
  getFloat32() {
    const e = this.dv.getFloat32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getFloat32Array(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push(this.getFloat32());
    return t;
  }
  getFloat64() {
    const e = this.dv.getFloat64(this.offset, this.littleEndian);
    return this.offset += 8, e;
  }
  getFloat64Array(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push(this.getFloat64());
    return t;
  }
  getArrayBuffer(e) {
    const t = this.dv.buffer.slice(this.offset, this.offset + e);
    return this.offset += e, t;
  }
  getString(e) {
    let t = [];
    for (let s = 0; s < e; s++)
      t[s] = this.getUint8();
    const n = t.indexOf(0);
    return n >= 0 && (t = t.slice(0, n)), Ft.decodeText(new Uint8Array(t));
  }
}
class Ma {
  add(e, t) {
    this[e] = t;
  }
}
function eh(o) {
  const e = "Kaydara FBX Binary  \0";
  return o.byteLength >= e.length && e === Pa(o, 0, e.length);
}
function th(o) {
  const e = [
    "K",
    "a",
    "y",
    "d",
    "a",
    "r",
    "a",
    "\\",
    "F",
    "B",
    "X",
    "\\",
    "B",
    "i",
    "n",
    "a",
    "r",
    "y",
    "\\",
    "\\"
  ];
  let t = 0;
  function n(s) {
    const i = o[s - 1];
    return o = o.slice(t + s), t++, i;
  }
  for (let s = 0; s < e.length; ++s)
    if (n(1) === e[s])
      return !1;
  return !0;
}
function Wr(o) {
  const e = /FBXVersion: (\d+)/, t = o.match(e);
  if (t)
    return parseInt(t[1]);
  throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
}
function nh(o) {
  return o / 46186158e3;
}
const sh = [];
function Ps(o, e, t, n) {
  let s;
  switch (n.mappingType) {
    case "ByPolygonVertex":
      s = o;
      break;
    case "ByPolygon":
      s = e;
      break;
    case "ByVertice":
      s = t;
      break;
    case "AllSame":
      s = n.indices[0];
      break;
    default:
      console.warn("THREE.FBXLoader: unknown attribute mapping type " + n.mappingType);
  }
  n.referenceType === "IndexToDirect" && (s = n.indices[s]);
  const i = s * n.dataSize, r = i + n.dataSize;
  return rh(sh, n.buffer, i, r);
}
const vi = new _n(), In = new ee();
function Sa(o) {
  const e = new De(), t = new De(), n = new De(), s = new De(), i = new De(), r = new De(), a = new De(), l = new De(), c = new De(), u = new De(), h = new De(), m = new De(), p = o.inheritType ? o.inheritType : 0;
  if (o.translation && e.setPosition(In.fromArray(o.translation)), o.preRotation) {
    const f = o.preRotation.map(We.degToRad);
    f.push(o.eulerOrder), t.makeRotationFromEuler(vi.fromArray(f));
  }
  if (o.rotation) {
    const f = o.rotation.map(We.degToRad);
    f.push(o.eulerOrder), n.makeRotationFromEuler(vi.fromArray(f));
  }
  if (o.postRotation) {
    const f = o.postRotation.map(We.degToRad);
    f.push(o.eulerOrder), s.makeRotationFromEuler(vi.fromArray(f)), s.invert();
  }
  o.scale && i.scale(In.fromArray(o.scale)), o.scalingOffset && a.setPosition(In.fromArray(o.scalingOffset)), o.scalingPivot && r.setPosition(In.fromArray(o.scalingPivot)), o.rotationOffset && l.setPosition(In.fromArray(o.rotationOffset)), o.rotationPivot && c.setPosition(In.fromArray(o.rotationPivot)), o.parentMatrixWorld && (h.copy(o.parentMatrix), u.copy(o.parentMatrixWorld));
  const v = t.clone().multiply(n).multiply(s), _ = new De();
  _.extractRotation(u);
  const y = new De();
  y.copyPosition(u);
  const E = y.clone().invert().multiply(u), R = _.clone().invert().multiply(E), T = i, g = new De();
  if (p === 0)
    g.copy(_).multiply(v).multiply(R).multiply(T);
  else if (p === 1)
    g.copy(_).multiply(R).multiply(v).multiply(T);
  else {
    const P = new De().scale(new ee().setFromMatrixScale(h)).clone().invert(), I = R.clone().multiply(P);
    g.copy(_).multiply(v).multiply(I).multiply(T);
  }
  const A = c.clone().invert(), x = r.clone().invert();
  let M = e.clone().multiply(l).multiply(c).multiply(t).multiply(n).multiply(s).multiply(A).multiply(a).multiply(r).multiply(i).multiply(x);
  const d = new De().copyPosition(M), w = u.clone().multiply(d);
  return m.copyPosition(w), M = m.clone().multiply(g), M.premultiply(u.invert()), M;
}
function Aa(o) {
  o = o || 0;
  const e = [
    "ZYX",
    // -> XYZ extrinsic
    "YZX",
    // -> XZY extrinsic
    "XZY",
    // -> YZX extrinsic
    "ZXY",
    // -> YXZ extrinsic
    "YXZ",
    // -> ZXY extrinsic
    "XYZ"
    // -> ZYX extrinsic
    //'SphericXYZ', // not possible to support
  ];
  return o === 6 ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), e[0]) : e[o];
}
function _i(o) {
  return o.split(",").map(function(t) {
    return parseFloat(t);
  });
}
function Pa(o, e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = o.byteLength), Ft.decodeText(new Uint8Array(o, e, t));
}
function ih(o, e) {
  for (let t = 0, n = o.length, s = e.length; t < s; t++, n++)
    o[n] = e[t];
}
function rh(o, e, t, n) {
  for (let s = t, i = 0; s < n; s++, i++)
    o[i] = e[s];
  return o;
}
function $r(o, e, t) {
  return o.slice(0, e).concat(t).concat(o.slice(e));
}
var oh = Object.defineProperty, ah = (o, e, t) => e in o ? oh(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, fr = (o, e, t) => (ah(o, typeof e != "symbol" ? e + "" : e, t), t);
class lh extends cs {
  constructor(e) {
    super(e);
  }
  load(e, t, n, s) {
    const i = new Tn(this.manager);
    i.setPath(this.path), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials), i.load(
      e,
      (r) => {
        if (typeof r != "string")
          throw new Error("unsupported data type");
        const a = JSON.parse(r), l = this.parse(a);
        t && t(l);
      },
      n,
      s
    );
  }
  loadAsync(e, t) {
    return super.loadAsync(e, t);
  }
  parse(e) {
    return new dr(e);
  }
}
class dr {
  constructor(e) {
    fr(this, "data"), this.data = e;
  }
  generateShapes(e, t = 100, n) {
    const s = [], i = { letterSpacing: 0, lineHeight: 1, ...n }, r = ch(e, t, this.data, i);
    for (let a = 0, l = r.length; a < l; a++)
      Array.prototype.push.apply(s, r[a].toShapes(!1));
    return s;
  }
}
fr(dr, "isFont");
fr(dr, "type");
function ch(o, e, t, n) {
  const s = Array.from(o), i = e / t.resolution, r = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * i, a = [];
  let l = 0, c = 0;
  for (let u = 0; u < s.length; u++) {
    const h = s[u];
    if (h === `
`)
      l = 0, c -= r * n.lineHeight;
    else {
      const m = uh(h, i, l, c, t);
      m && (l += m.offsetX + n.letterSpacing, a.push(m.path));
    }
  }
  return a;
}
function uh(o, e, t, n, s) {
  const i = s.glyphs[o] || s.glyphs["?"];
  if (!i) {
    console.error('THREE.Font: character "' + o + '" does not exists in font family ' + s.familyName + ".");
    return;
  }
  const r = new nn();
  let a, l, c, u, h, m, p, v;
  if (i.o) {
    const _ = i._cachedOutline || (i._cachedOutline = i.o.split(" "));
    for (let y = 0, E = _.length; y < E; )
      switch (_[y++]) {
        case "m":
          a = parseInt(_[y++]) * e + t, l = parseInt(_[y++]) * e + n, r.moveTo(a, l);
          break;
        case "l":
          a = parseInt(_[y++]) * e + t, l = parseInt(_[y++]) * e + n, r.lineTo(a, l);
          break;
        case "q":
          c = parseInt(_[y++]) * e + t, u = parseInt(_[y++]) * e + n, h = parseInt(_[y++]) * e + t, m = parseInt(_[y++]) * e + n, r.quadraticCurveTo(h, m, c, u);
          break;
        case "b":
          c = parseInt(_[y++]) * e + t, u = parseInt(_[y++]) * e + n, h = parseInt(_[y++]) * e + t, m = parseInt(_[y++]) * e + n, p = parseInt(_[y++]) * e + t, v = parseInt(_[y++]) * e + n, r.bezierCurveTo(h, m, p, v, c, u);
          break;
      }
  }
  return { offsetX: i.ha * e, path: r };
}
class Zr extends El {
  constructor(e) {
    super(e), this.type = un;
  }
  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html
  parse(e) {
    const a = function(T, g) {
      switch (T) {
        case 1:
          console.error("THREE.RGBELoader Read Error: " + (g || ""));
          break;
        case 2:
          console.error("THREE.RGBELoader Write Error: " + (g || ""));
          break;
        case 3:
          console.error("THREE.RGBELoader Bad File Format: " + (g || ""));
          break;
        default:
        case 4:
          console.error("THREE.RGBELoader: Error: " + (g || ""));
      }
      return -1;
    }, h = `
`, m = function(T, g, A) {
      g = g || 1024;
      let M = T.pos, d = -1, w = 0, f = "", P = String.fromCharCode.apply(null, new Uint16Array(T.subarray(M, M + 128)));
      for (; 0 > (d = P.indexOf(h)) && w < g && M < T.byteLength; )
        f += P, w += P.length, M += 128, P += String.fromCharCode.apply(null, new Uint16Array(T.subarray(M, M + 128)));
      return -1 < d ? (A !== !1 && (T.pos += w + d + 1), f + P.slice(0, d)) : !1;
    }, p = function(T) {
      const g = /^#\?(\S+)/, A = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, x = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, M = /^\s*FORMAT=(\S+)\s*$/, d = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, w = {
        valid: 0,
        string: "",
        comments: "",
        programtype: "RGBE",
        format: "",
        gamma: 1,
        exposure: 1,
        width: 0,
        height: 0
      };
      let f, P;
      if (T.pos >= T.byteLength || !(f = m(T)))
        return a(1, "no header found");
      if (!(P = f.match(g)))
        return a(3, "bad initial token");
      for (w.valid |= 1, w.programtype = P[1], w.string += f + `
`; f = m(T), f !== !1; ) {
        if (w.string += f + `
`, f.charAt(0) === "#") {
          w.comments += f + `
`;
          continue;
        }
        if ((P = f.match(A)) && (w.gamma = parseFloat(P[1])), (P = f.match(x)) && (w.exposure = parseFloat(P[1])), (P = f.match(M)) && (w.valid |= 2, w.format = P[1]), (P = f.match(d)) && (w.valid |= 4, w.height = parseInt(P[1], 10), w.width = parseInt(P[2], 10)), w.valid & 2 && w.valid & 4)
          break;
      }
      return w.valid & 2 ? w.valid & 4 ? w : a(3, "missing image size specifier") : a(3, "missing format specifier");
    }, v = function(T, g, A) {
      const x = g;
      if (
        // run length encoding is not allowed so read flat
        x < 8 || x > 32767 || // this file is not run length encoded
        T[0] !== 2 || T[1] !== 2 || T[2] & 128
      )
        return new Uint8Array(T);
      if (x !== (T[2] << 8 | T[3]))
        return a(3, "wrong scanline width");
      const M = new Uint8Array(4 * g * A);
      if (!M.length)
        return a(4, "unable to allocate buffer space");
      let d = 0, w = 0;
      const f = 4 * x, P = new Uint8Array(4), I = new Uint8Array(f);
      let K = A;
      for (; K > 0 && w < T.byteLength; ) {
        if (w + 4 > T.byteLength)
          return a(1);
        if (P[0] = T[w++], P[1] = T[w++], P[2] = T[w++], P[3] = T[w++], P[0] != 2 || P[1] != 2 || (P[2] << 8 | P[3]) != x)
          return a(3, "bad rgbe scanline format");
        let N = 0, Z;
        for (; N < f && w < T.byteLength; ) {
          Z = T[w++];
          const X = Z > 128;
          if (X && (Z -= 128), Z === 0 || N + Z > f)
            return a(3, "bad scanline data");
          if (X) {
            const V = T[w++];
            for (let ne = 0; ne < Z; ne++)
              I[N++] = V;
          } else
            I.set(T.subarray(w, w + Z), N), N += Z, w += Z;
        }
        const W = x;
        for (let X = 0; X < W; X++) {
          let V = 0;
          M[d] = I[X + V], V += x, M[d + 1] = I[X + V], V += x, M[d + 2] = I[X + V], V += x, M[d + 3] = I[X + V], d += 4;
        }
        K--;
      }
      return M;
    }, _ = function(T, g, A, x) {
      const M = T[g + 3], d = Math.pow(2, M - 128) / 255;
      A[x + 0] = T[g + 0] * d, A[x + 1] = T[g + 1] * d, A[x + 2] = T[g + 2] * d, A[x + 3] = 1;
    }, y = function(T, g, A, x) {
      const M = T[g + 3], d = Math.pow(2, M - 128) / 255;
      A[x + 0] = ws.toHalfFloat(Math.min(T[g + 0] * d, 65504)), A[x + 1] = ws.toHalfFloat(Math.min(T[g + 1] * d, 65504)), A[x + 2] = ws.toHalfFloat(Math.min(T[g + 2] * d, 65504)), A[x + 3] = ws.toHalfFloat(1);
    }, E = new Uint8Array(e);
    E.pos = 0;
    const R = p(E);
    if (R !== -1) {
      const T = R.width, g = R.height, A = v(E.subarray(E.pos), T, g);
      if (A !== -1) {
        let x, M, d;
        switch (this.type) {
          case Gs:
            d = A.length / 4;
            const w = new Float32Array(d * 4);
            for (let P = 0; P < d; P++)
              _(A, P * 4, w, P * 4);
            x = w, M = Gs;
            break;
          case un:
            d = A.length / 4;
            const f = new Uint16Array(d * 4);
            for (let P = 0; P < d; P++)
              y(A, P * 4, f, P * 4);
            x = f, M = un;
            break;
          default:
            console.error("THREE.RGBELoader: unsupported type: ", this.type);
            break;
        }
        return {
          width: T,
          height: g,
          data: x,
          header: R.string,
          gamma: R.gamma,
          exposure: R.exposure,
          type: M
        };
      }
    }
    return null;
  }
  setDataType(e) {
    return this.type = e, this;
  }
  load(e, t, n, s) {
    function i(r, a) {
      switch (r.type) {
        case Gs:
        case un:
          "colorSpace" in r ? r.colorSpace = "srgb-linear" : r.encoding = 3e3, r.minFilter = At, r.magFilter = At, r.generateMipmaps = !1, r.flipY = !0;
          break;
      }
      t && t(r, a);
    }
    return super.load(e, i, n, s);
  }
}
class is extends cs {
  constructor(e) {
    super(e), this.defaultDPI = 90, this.defaultUnit = "px";
  }
  load(e, t, n, s) {
    const i = this, r = new Tn(i.manager);
    r.setPath(i.path), r.setRequestHeader(i.requestHeader), r.setWithCredentials(i.withCredentials), r.load(
      e,
      function(a) {
        try {
          t(i.parse(a));
        } catch (l) {
          s ? s(l) : console.error(l), i.manager.itemError(e);
        }
      },
      n,
      s
    );
  }
  parse(e) {
    const t = this;
    function n(H, k) {
      if (H.nodeType !== 1)
        return;
      const b = g(H);
      let U = !0, J = null;
      switch (H.nodeName) {
        case "svg":
          break;
        case "style":
          i(H);
          break;
        case "g":
          k = v(H, k);
          break;
        case "path":
          k = v(H, k), H.hasAttribute("d") && (J = s(H));
          break;
        case "rect":
          k = v(H, k), J = l(H);
          break;
        case "polygon":
          k = v(H, k), J = c(H);
          break;
        case "polyline":
          k = v(H, k), J = u(H);
          break;
        case "circle":
          k = v(H, k), J = h(H);
          break;
        case "ellipse":
          k = v(H, k), J = m(H);
          break;
        case "line":
          k = v(H, k), J = p(H);
          break;
        case "defs":
          U = !1;
          break;
        case "mask":
          U = !1;
          break;
        case "use":
          k = v(H, k);
          const F = H.href.baseVal.substring(1), B = H.viewportElement.getElementById(F);
          B ? n(B, k) : console.warn("SVGLoader: 'use node' references non-existent node id: " + F);
          break;
      }
      if (J && (k.fill !== void 0 && k.fill !== "none" && J.color.setStyle(k.fill), x(J, ne), f.push(J), J.userData = { node: H, style: k }), U) {
        const F = H.childNodes;
        for (let B = 0; B < F.length; B++)
          n(F[B], k);
      }
      b && (I.pop(), I.length > 0 ? ne.copy(I[I.length - 1]) : ne.identity());
    }
    function s(H) {
      const k = new nn(), b = new le(), U = new le(), J = new le();
      let F = !0, B = !1;
      const C = H.getAttribute("d").match(/[a-df-z][^a-df-z]*/gi);
      for (let D = 0, G = C.length; D < G; D++) {
        const $ = C[D], Y = $.charAt(0), te = $.substr(1).trim();
        F === !0 && (B = !0, F = !1);
        let O;
        switch (Y) {
          case "M":
            O = y(te);
            for (let L = 0, re = O.length; L < re; L += 2)
              b.x = O[L + 0], b.y = O[L + 1], U.x = b.x, U.y = b.y, L === 0 ? k.moveTo(b.x, b.y) : k.lineTo(b.x, b.y), L === 0 && J.copy(b);
            break;
          case "H":
            O = y(te);
            for (let L = 0, re = O.length; L < re; L++)
              b.x = O[L], U.x = b.x, U.y = b.y, k.lineTo(b.x, b.y), L === 0 && B === !0 && J.copy(b);
            break;
          case "V":
            O = y(te);
            for (let L = 0, re = O.length; L < re; L++)
              b.y = O[L], U.x = b.x, U.y = b.y, k.lineTo(b.x, b.y), L === 0 && B === !0 && J.copy(b);
            break;
          case "L":
            O = y(te);
            for (let L = 0, re = O.length; L < re; L += 2)
              b.x = O[L + 0], b.y = O[L + 1], U.x = b.x, U.y = b.y, k.lineTo(b.x, b.y), L === 0 && B === !0 && J.copy(b);
            break;
          case "C":
            O = y(te);
            for (let L = 0, re = O.length; L < re; L += 6)
              k.bezierCurveTo(
                O[L + 0],
                O[L + 1],
                O[L + 2],
                O[L + 3],
                O[L + 4],
                O[L + 5]
              ), U.x = O[L + 2], U.y = O[L + 3], b.x = O[L + 4], b.y = O[L + 5], L === 0 && B === !0 && J.copy(b);
            break;
          case "S":
            O = y(te);
            for (let L = 0, re = O.length; L < re; L += 4)
              k.bezierCurveTo(
                _(b.x, U.x),
                _(b.y, U.y),
                O[L + 0],
                O[L + 1],
                O[L + 2],
                O[L + 3]
              ), U.x = O[L + 0], U.y = O[L + 1], b.x = O[L + 2], b.y = O[L + 3], L === 0 && B === !0 && J.copy(b);
            break;
          case "Q":
            O = y(te);
            for (let L = 0, re = O.length; L < re; L += 4)
              k.quadraticCurveTo(O[L + 0], O[L + 1], O[L + 2], O[L + 3]), U.x = O[L + 0], U.y = O[L + 1], b.x = O[L + 2], b.y = O[L + 3], L === 0 && B === !0 && J.copy(b);
            break;
          case "T":
            O = y(te);
            for (let L = 0, re = O.length; L < re; L += 2) {
              const ce = _(b.x, U.x), be = _(b.y, U.y);
              k.quadraticCurveTo(ce, be, O[L + 0], O[L + 1]), U.x = ce, U.y = be, b.x = O[L + 0], b.y = O[L + 1], L === 0 && B === !0 && J.copy(b);
            }
            break;
          case "A":
            O = y(te, [3, 4], 7);
            for (let L = 0, re = O.length; L < re; L += 7) {
              if (O[L + 5] == b.x && O[L + 6] == b.y)
                continue;
              const ce = b.clone();
              b.x = O[L + 5], b.y = O[L + 6], U.x = b.x, U.y = b.y, r(
                k,
                O[L],
                O[L + 1],
                O[L + 2],
                O[L + 3],
                O[L + 4],
                ce,
                b
              ), L === 0 && B === !0 && J.copy(b);
            }
            break;
          case "m":
            O = y(te);
            for (let L = 0, re = O.length; L < re; L += 2)
              b.x += O[L + 0], b.y += O[L + 1], U.x = b.x, U.y = b.y, L === 0 ? k.moveTo(b.x, b.y) : k.lineTo(b.x, b.y), L === 0 && J.copy(b);
            break;
          case "h":
            O = y(te);
            for (let L = 0, re = O.length; L < re; L++)
              b.x += O[L], U.x = b.x, U.y = b.y, k.lineTo(b.x, b.y), L === 0 && B === !0 && J.copy(b);
            break;
          case "v":
            O = y(te);
            for (let L = 0, re = O.length; L < re; L++)
              b.y += O[L], U.x = b.x, U.y = b.y, k.lineTo(b.x, b.y), L === 0 && B === !0 && J.copy(b);
            break;
          case "l":
            O = y(te);
            for (let L = 0, re = O.length; L < re; L += 2)
              b.x += O[L + 0], b.y += O[L + 1], U.x = b.x, U.y = b.y, k.lineTo(b.x, b.y), L === 0 && B === !0 && J.copy(b);
            break;
          case "c":
            O = y(te);
            for (let L = 0, re = O.length; L < re; L += 6)
              k.bezierCurveTo(
                b.x + O[L + 0],
                b.y + O[L + 1],
                b.x + O[L + 2],
                b.y + O[L + 3],
                b.x + O[L + 4],
                b.y + O[L + 5]
              ), U.x = b.x + O[L + 2], U.y = b.y + O[L + 3], b.x += O[L + 4], b.y += O[L + 5], L === 0 && B === !0 && J.copy(b);
            break;
          case "s":
            O = y(te);
            for (let L = 0, re = O.length; L < re; L += 4)
              k.bezierCurveTo(
                _(b.x, U.x),
                _(b.y, U.y),
                b.x + O[L + 0],
                b.y + O[L + 1],
                b.x + O[L + 2],
                b.y + O[L + 3]
              ), U.x = b.x + O[L + 0], U.y = b.y + O[L + 1], b.x += O[L + 2], b.y += O[L + 3], L === 0 && B === !0 && J.copy(b);
            break;
          case "q":
            O = y(te);
            for (let L = 0, re = O.length; L < re; L += 4)
              k.quadraticCurveTo(
                b.x + O[L + 0],
                b.y + O[L + 1],
                b.x + O[L + 2],
                b.y + O[L + 3]
              ), U.x = b.x + O[L + 0], U.y = b.y + O[L + 1], b.x += O[L + 2], b.y += O[L + 3], L === 0 && B === !0 && J.copy(b);
            break;
          case "t":
            O = y(te);
            for (let L = 0, re = O.length; L < re; L += 2) {
              const ce = _(b.x, U.x), be = _(b.y, U.y);
              k.quadraticCurveTo(ce, be, b.x + O[L + 0], b.y + O[L + 1]), U.x = ce, U.y = be, b.x = b.x + O[L + 0], b.y = b.y + O[L + 1], L === 0 && B === !0 && J.copy(b);
            }
            break;
          case "a":
            O = y(te, [3, 4], 7);
            for (let L = 0, re = O.length; L < re; L += 7) {
              if (O[L + 5] == 0 && O[L + 6] == 0)
                continue;
              const ce = b.clone();
              b.x += O[L + 5], b.y += O[L + 6], U.x = b.x, U.y = b.y, r(
                k,
                O[L],
                O[L + 1],
                O[L + 2],
                O[L + 3],
                O[L + 4],
                ce,
                b
              ), L === 0 && B === !0 && J.copy(b);
            }
            break;
          case "Z":
          case "z":
            k.currentPath.autoClose = !0, k.currentPath.curves.length > 0 && (b.copy(J), k.currentPath.currentPoint.copy(b), F = !0);
            break;
          default:
            console.warn($);
        }
        B = !1;
      }
      return k;
    }
    function i(H) {
      if (!(!H.sheet || !H.sheet.cssRules || !H.sheet.cssRules.length))
        for (let k = 0; k < H.sheet.cssRules.length; k++) {
          const b = H.sheet.cssRules[k];
          if (b.type !== 1)
            continue;
          const U = b.selectorText.split(/,/gm).filter(Boolean).map((J) => J.trim());
          for (let J = 0; J < U.length; J++)
            P[U[J]] = Object.assign(P[U[J]] || {}, b.style);
        }
    }
    function r(H, k, b, U, J, F, B, S) {
      if (k == 0 || b == 0) {
        H.lineTo(S.x, S.y);
        return;
      }
      U = U * Math.PI / 180, k = Math.abs(k), b = Math.abs(b);
      const C = (B.x - S.x) / 2, D = (B.y - S.y) / 2, G = Math.cos(U) * C + Math.sin(U) * D, $ = -Math.sin(U) * C + Math.cos(U) * D;
      let Y = k * k, te = b * b;
      const O = G * G, L = $ * $, re = O / Y + L / te;
      if (re > 1) {
        const An = Math.sqrt(re);
        k = An * k, b = An * b, Y = k * k, te = b * b;
      }
      const ce = Y * L + te * O, be = (Y * te - ce) / ce;
      let Me = Math.sqrt(Math.max(0, be));
      J === F && (Me = -Me);
      const Se = Me * k * $ / b, qe = -Me * b * G / k, kt = Math.cos(U) * Se - Math.sin(U) * qe + (B.x + S.x) / 2, jn = Math.sin(U) * Se + Math.cos(U) * qe + (B.y + S.y) / 2, Sn = a(1, 0, (G - Se) / k, ($ - qe) / b), gt = a((G - Se) / k, ($ - qe) / b, (-G - Se) / k, (-$ - qe) / b) % (Math.PI * 2);
      H.currentPath.absellipse(kt, jn, k, b, Sn, Sn + gt, F === 0, U);
    }
    function a(H, k, b, U) {
      const J = H * b + k * U, F = Math.sqrt(H * H + k * k) * Math.sqrt(b * b + U * U);
      let B = Math.acos(Math.max(-1, Math.min(1, J / F)));
      return H * U - k * b < 0 && (B = -B), B;
    }
    function l(H) {
      const k = T(H.getAttribute("x") || 0), b = T(H.getAttribute("y") || 0), U = T(H.getAttribute("rx") || H.getAttribute("ry") || 0), J = T(H.getAttribute("ry") || H.getAttribute("rx") || 0), F = T(H.getAttribute("width")), B = T(H.getAttribute("height")), S = 1 - 0.551915024494, C = new nn();
      return C.moveTo(k + U, b), C.lineTo(k + F - U, b), (U !== 0 || J !== 0) && C.bezierCurveTo(k + F - U * S, b, k + F, b + J * S, k + F, b + J), C.lineTo(k + F, b + B - J), (U !== 0 || J !== 0) && C.bezierCurveTo(k + F, b + B - J * S, k + F - U * S, b + B, k + F - U, b + B), C.lineTo(k + U, b + B), (U !== 0 || J !== 0) && C.bezierCurveTo(k + U * S, b + B, k, b + B - J * S, k, b + B - J), C.lineTo(k, b + J), (U !== 0 || J !== 0) && C.bezierCurveTo(k, b + J * S, k + U * S, b, k + U, b), C;
    }
    function c(H) {
      function k(F, B, S) {
        const C = T(B), D = T(S);
        J === 0 ? U.moveTo(C, D) : U.lineTo(C, D), J++;
      }
      const b = /(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g, U = new nn();
      let J = 0;
      return H.getAttribute("points").replace(b, k), U.currentPath.autoClose = !0, U;
    }
    function u(H) {
      function k(F, B, S) {
        const C = T(B), D = T(S);
        J === 0 ? U.moveTo(C, D) : U.lineTo(C, D), J++;
      }
      const b = /(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g, U = new nn();
      let J = 0;
      return H.getAttribute("points").replace(b, k), U.currentPath.autoClose = !1, U;
    }
    function h(H) {
      const k = T(H.getAttribute("cx") || 0), b = T(H.getAttribute("cy") || 0), U = T(H.getAttribute("r") || 0), J = new ai();
      J.absarc(k, b, U, 0, Math.PI * 2);
      const F = new nn();
      return F.subPaths.push(J), F;
    }
    function m(H) {
      const k = T(H.getAttribute("cx") || 0), b = T(H.getAttribute("cy") || 0), U = T(H.getAttribute("rx") || 0), J = T(H.getAttribute("ry") || 0), F = new ai();
      F.absellipse(k, b, U, J, 0, Math.PI * 2);
      const B = new nn();
      return B.subPaths.push(F), B;
    }
    function p(H) {
      const k = T(H.getAttribute("x1") || 0), b = T(H.getAttribute("y1") || 0), U = T(H.getAttribute("x2") || 0), J = T(H.getAttribute("y2") || 0), F = new nn();
      return F.moveTo(k, b), F.lineTo(U, J), F.currentPath.autoClose = !1, F;
    }
    function v(H, k) {
      k = Object.assign({}, k);
      let b = {};
      if (H.hasAttribute("class")) {
        const B = H.getAttribute("class").split(/\s/).filter(Boolean).map((S) => S.trim());
        for (let S = 0; S < B.length; S++)
          b = Object.assign(b, P["." + B[S]]);
      }
      H.hasAttribute("id") && (b = Object.assign(b, P["#" + H.getAttribute("id")]));
      function U(B, S, C) {
        C === void 0 && (C = function(G) {
          return G.startsWith("url") && console.warn("SVGLoader: url access in attributes is not implemented."), G;
        }), H.hasAttribute(B) && (k[S] = C(H.getAttribute(B))), b[B] && (k[S] = C(b[B])), H.style && H.style[B] !== "" && (k[S] = C(H.style[B]));
      }
      function J(B) {
        return Math.max(0, Math.min(1, T(B)));
      }
      function F(B) {
        return Math.max(0, T(B));
      }
      return U("fill", "fill"), U("fill-opacity", "fillOpacity", J), U("fill-rule", "fillRule"), U("opacity", "opacity", J), U("stroke", "stroke"), U("stroke-opacity", "strokeOpacity", J), U("stroke-width", "strokeWidth", F), U("stroke-linejoin", "strokeLineJoin"), U("stroke-linecap", "strokeLineCap"), U("stroke-miterlimit", "strokeMiterLimit", F), U("visibility", "visibility"), k;
    }
    function _(H, k) {
      return H - (k - H);
    }
    function y(H, k, b) {
      if (typeof H != "string")
        throw new TypeError("Invalid input: " + typeof H);
      const U = {
        SEPARATOR: /[ \t\r\n\,.\-+]/,
        WHITESPACE: /[ \t\r\n]/,
        DIGIT: /[\d]/,
        SIGN: /[-+]/,
        POINT: /\./,
        COMMA: /,/,
        EXP: /e/i,
        FLAGS: /[01]/
      }, J = 0, F = 1, B = 2, S = 3;
      let C = J, D = !0, G = "", $ = "";
      const Y = [];
      function te(ce, be, Me) {
        const Se = new SyntaxError('Unexpected character "' + ce + '" at index ' + be + ".");
        throw Se.partial = Me, Se;
      }
      function O() {
        G !== "" && ($ === "" ? Y.push(Number(G)) : Y.push(Number(G) * Math.pow(10, Number($)))), G = "", $ = "";
      }
      let L;
      const re = H.length;
      for (let ce = 0; ce < re; ce++) {
        if (L = H[ce], Array.isArray(k) && k.includes(Y.length % b) && U.FLAGS.test(L)) {
          C = F, G = L, O();
          continue;
        }
        if (C === J) {
          if (U.WHITESPACE.test(L))
            continue;
          if (U.DIGIT.test(L) || U.SIGN.test(L)) {
            C = F, G = L;
            continue;
          }
          if (U.POINT.test(L)) {
            C = B, G = L;
            continue;
          }
          U.COMMA.test(L) && (D && te(L, ce, Y), D = !0);
        }
        if (C === F) {
          if (U.DIGIT.test(L)) {
            G += L;
            continue;
          }
          if (U.POINT.test(L)) {
            G += L, C = B;
            continue;
          }
          if (U.EXP.test(L)) {
            C = S;
            continue;
          }
          U.SIGN.test(L) && G.length === 1 && U.SIGN.test(G[0]) && te(L, ce, Y);
        }
        if (C === B) {
          if (U.DIGIT.test(L)) {
            G += L;
            continue;
          }
          if (U.EXP.test(L)) {
            C = S;
            continue;
          }
          U.POINT.test(L) && G[G.length - 1] === "." && te(L, ce, Y);
        }
        if (C === S) {
          if (U.DIGIT.test(L)) {
            $ += L;
            continue;
          }
          if (U.SIGN.test(L)) {
            if ($ === "") {
              $ += L;
              continue;
            }
            $.length === 1 && U.SIGN.test($) && te(L, ce, Y);
          }
        }
        U.WHITESPACE.test(L) ? (O(), C = J, D = !1) : U.COMMA.test(L) ? (O(), C = J, D = !0) : U.SIGN.test(L) ? (O(), C = F, G = L) : U.POINT.test(L) ? (O(), C = B, G = L) : te(L, ce, Y);
      }
      return O(), Y;
    }
    const E = ["mm", "cm", "in", "pt", "pc", "px"], R = {
      mm: {
        mm: 1,
        cm: 0.1,
        in: 1 / 25.4,
        pt: 72 / 25.4,
        pc: 6 / 25.4,
        px: -1
      },
      cm: {
        mm: 10,
        cm: 1,
        in: 1 / 2.54,
        pt: 72 / 2.54,
        pc: 6 / 2.54,
        px: -1
      },
      in: {
        mm: 25.4,
        cm: 2.54,
        in: 1,
        pt: 72,
        pc: 6,
        px: -1
      },
      pt: {
        mm: 25.4 / 72,
        cm: 2.54 / 72,
        in: 1 / 72,
        pt: 1,
        pc: 6 / 72,
        px: -1
      },
      pc: {
        mm: 25.4 / 6,
        cm: 2.54 / 6,
        in: 1 / 6,
        pt: 72 / 6,
        pc: 1,
        px: -1
      },
      px: {
        px: 1
      }
    };
    function T(H) {
      let k = "px";
      if (typeof H == "string" || H instanceof String)
        for (let U = 0, J = E.length; U < J; U++) {
          const F = E[U];
          if (H.endsWith(F)) {
            k = F, H = H.substring(0, H.length - F.length);
            break;
          }
        }
      let b;
      return k === "px" && t.defaultUnit !== "px" ? b = R.in[t.defaultUnit] / t.defaultDPI : (b = R[k][t.defaultUnit], b < 0 && (b = R[k].in * t.defaultDPI)), b * parseFloat(H);
    }
    function g(H) {
      if (!(H.hasAttribute("transform") || H.nodeName === "use" && (H.hasAttribute("x") || H.hasAttribute("y"))))
        return null;
      const k = A(H);
      return I.length > 0 && k.premultiply(I[I.length - 1]), ne.copy(k), I.push(k), k;
    }
    function A(H) {
      const k = new vn(), b = K;
      if (H.nodeName === "use" && (H.hasAttribute("x") || H.hasAttribute("y"))) {
        const U = T(H.getAttribute("x")), J = T(H.getAttribute("y"));
        k.translate(U, J);
      }
      if (H.hasAttribute("transform")) {
        const U = H.getAttribute("transform").split(")");
        for (let J = U.length - 1; J >= 0; J--) {
          const F = U[J].trim();
          if (F === "")
            continue;
          const B = F.indexOf("("), S = F.length;
          if (B > 0 && B < S) {
            const C = F.substr(0, B), D = y(F.substr(B + 1, S - B - 1));
            switch (b.identity(), C) {
              case "translate":
                if (D.length >= 1) {
                  const G = D[0];
                  let $ = G;
                  D.length >= 2 && ($ = D[1]), b.translate(G, $);
                }
                break;
              case "rotate":
                if (D.length >= 1) {
                  let G = 0, $ = 0, Y = 0;
                  G = -D[0] * Math.PI / 180, D.length >= 3 && ($ = D[1], Y = D[2]), N.identity().translate(-$, -Y), Z.identity().rotate(G), W.multiplyMatrices(Z, N), N.identity().translate($, Y), b.multiplyMatrices(N, W);
                }
                break;
              case "scale":
                if (D.length >= 1) {
                  const G = D[0];
                  let $ = G;
                  D.length >= 2 && ($ = D[1]), b.scale(G, $);
                }
                break;
              case "skewX":
                D.length === 1 && b.set(1, Math.tan(D[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);
                break;
              case "skewY":
                D.length === 1 && b.set(1, 0, 0, Math.tan(D[0] * Math.PI / 180), 1, 0, 0, 0, 1);
                break;
              case "matrix":
                D.length === 6 && b.set(D[0], D[2], D[4], D[1], D[3], D[5], 0, 0, 1);
                break;
            }
          }
          k.premultiply(b);
        }
      }
      return k;
    }
    function x(H, k) {
      function b(F) {
        V.set(F.x, F.y, 1).applyMatrix3(k), F.set(V.x, V.y);
      }
      const U = M(k), J = H.subPaths;
      for (let F = 0, B = J.length; F < B; F++) {
        const C = J[F].curves;
        for (let D = 0; D < C.length; D++) {
          const G = C[D];
          G.isLineCurve ? (b(G.v1), b(G.v2)) : G.isCubicBezierCurve ? (b(G.v0), b(G.v1), b(G.v2), b(G.v3)) : G.isQuadraticBezierCurve ? (b(G.v0), b(G.v1), b(G.v2)) : G.isEllipseCurve && (U && console.warn("SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented."), X.set(G.aX, G.aY), b(X), G.aX = X.x, G.aY = X.y, G.xRadius *= d(k), G.yRadius *= w(k));
        }
      }
    }
    function M(H) {
      return H.elements[1] !== 0 || H.elements[3] !== 0;
    }
    function d(H) {
      const k = H.elements;
      return Math.sqrt(k[0] * k[0] + k[1] * k[1]);
    }
    function w(H) {
      const k = H.elements;
      return Math.sqrt(k[3] * k[3] + k[4] * k[4]);
    }
    const f = [], P = {}, I = [], K = new vn(), N = new vn(), Z = new vn(), W = new vn(), X = new le(), V = new ee(), ne = new vn(), se = new DOMParser().parseFromString(e, "image/svg+xml");
    return n(se.documentElement, {
      fill: "#000",
      fillOpacity: 1,
      strokeOpacity: 1,
      strokeWidth: 1,
      strokeLineJoin: "miter",
      strokeLineCap: "butt",
      strokeMiterLimit: 4
    }), { paths: f, xml: se.documentElement };
  }
  static createShapes(e) {
    const n = {
      ORIGIN: 0,
      DESTINATION: 1,
      BETWEEN: 2,
      LEFT: 3,
      RIGHT: 4,
      BEHIND: 5,
      BEYOND: 6
    }, s = {
      loc: n.ORIGIN,
      t: 0
    };
    function i(y, E, R, T) {
      const g = y.x, A = E.x, x = R.x, M = T.x, d = y.y, w = E.y, f = R.y, P = T.y, I = (M - x) * (d - f) - (P - f) * (g - x), K = (A - g) * (d - f) - (w - d) * (g - x), N = (P - f) * (A - g) - (M - x) * (w - d), Z = I / N, W = K / N;
      if (N === 0 && I !== 0 || Z <= 0 || Z >= 1 || W < 0 || W > 1)
        return null;
      if (I === 0 && N === 0) {
        for (let X = 0; X < 2; X++)
          if (r(X === 0 ? R : T, y, E), s.loc == n.ORIGIN) {
            const V = X === 0 ? R : T;
            return { x: V.x, y: V.y, t: s.t };
          } else if (s.loc == n.BETWEEN) {
            const V = +(g + s.t * (A - g)).toPrecision(10), ne = +(d + s.t * (w - d)).toPrecision(10);
            return { x: V, y: ne, t: s.t };
          }
        return null;
      } else {
        for (let ne = 0; ne < 2; ne++)
          if (r(ne === 0 ? R : T, y, E), s.loc == n.ORIGIN) {
            const se = ne === 0 ? R : T;
            return { x: se.x, y: se.y, t: s.t };
          }
        const X = +(g + Z * (A - g)).toPrecision(10), V = +(d + Z * (w - d)).toPrecision(10);
        return { x: X, y: V, t: Z };
      }
    }
    function r(y, E, R) {
      const T = R.x - E.x, g = R.y - E.y, A = y.x - E.x, x = y.y - E.y, M = T * x - A * g;
      if (y.x === E.x && y.y === E.y) {
        s.loc = n.ORIGIN, s.t = 0;
        return;
      }
      if (y.x === R.x && y.y === R.y) {
        s.loc = n.DESTINATION, s.t = 1;
        return;
      }
      if (M < -Number.EPSILON) {
        s.loc = n.LEFT;
        return;
      }
      if (M > Number.EPSILON) {
        s.loc = n.RIGHT;
        return;
      }
      if (T * A < 0 || g * x < 0) {
        s.loc = n.BEHIND;
        return;
      }
      if (Math.sqrt(T * T + g * g) < Math.sqrt(A * A + x * x)) {
        s.loc = n.BEYOND;
        return;
      }
      let d;
      T !== 0 ? d = A / T : d = x / g, s.loc = n.BETWEEN, s.t = d;
    }
    function a(y, E) {
      const R = [], T = [];
      for (let g = 1; g < y.length; g++) {
        const A = y[g - 1], x = y[g];
        for (let M = 1; M < E.length; M++) {
          const d = E[M - 1], w = E[M], f = i(A, x, d, w);
          f !== null && R.find(
            (P) => P.t <= f.t + Number.EPSILON && P.t >= f.t - Number.EPSILON
          ) === void 0 && (R.push(f), T.push(new le(f.x, f.y)));
        }
      }
      return T;
    }
    function l(y, E, R) {
      const T = new le();
      E.getCenter(T);
      const g = [];
      return R.forEach((A) => {
        A.boundingBox.containsPoint(T) && a(y, A.points).forEach((M) => {
          g.push({ identifier: A.identifier, isCW: A.isCW, point: M });
        });
      }), g.sort((A, x) => A.point.x - x.point.x), g;
    }
    function c(y, E, R, T, g) {
      (g == null || g === "") && (g = "nonzero");
      const A = new le();
      y.boundingBox.getCenter(A);
      const x = [new le(R, A.y), new le(T, A.y)], M = l(x, y.boundingBox, E);
      M.sort((K, N) => K.point.x - N.point.x);
      const d = [], w = [];
      M.forEach((K) => {
        K.identifier === y.identifier ? d.push(K) : w.push(K);
      });
      const f = d[0].point.x, P = [];
      let I = 0;
      for (; I < w.length && w[I].point.x < f; )
        P.length > 0 && P[P.length - 1] === w[I].identifier ? P.pop() : P.push(w[I].identifier), I++;
      if (P.push(y.identifier), g === "evenodd") {
        const K = P.length % 2 === 0, N = P[P.length - 2];
        return { identifier: y.identifier, isHole: K, for: N };
      } else if (g === "nonzero") {
        let K = !0, N = null, Z = null;
        for (let W = 0; W < P.length; W++) {
          const X = P[W];
          K ? (Z = E[X].isCW, K = !1, N = X) : Z !== E[X].isCW && (Z = E[X].isCW, K = !0);
        }
        return { identifier: y.identifier, isHole: K, for: N };
      } else
        console.warn('fill-rule: "' + g + '" is currently not implemented.');
    }
    let u = 0, h = 999999999, m = -999999999, p = e.subPaths.map((y) => {
      const E = y.getPoints();
      let R = -999999999, T = 999999999, g = -999999999, A = 999999999;
      for (let x = 0; x < E.length; x++) {
        const M = E[x];
        M.y > R && (R = M.y), M.y < T && (T = M.y), M.x > g && (g = M.x), M.x < A && (A = M.x);
      }
      return m <= g && (m = g + 1), h >= A && (h = A - 1), {
        curves: y.curves,
        points: E,
        isCW: Ml.isClockWise(E),
        identifier: u++,
        boundingBox: new ea(new le(A, T), new le(g, R))
      };
    });
    p = p.filter((y) => y.points.length > 1);
    const v = p.map(
      (y) => c(y, p, h, m, e.userData.style.fillRule)
    ), _ = [];
    return p.forEach((y) => {
      if (!v[y.identifier].isHole) {
        const R = new Sl();
        R.curves = y.curves, v.filter((g) => g.isHole && g.for === y.identifier).forEach((g) => {
          const A = p[g.identifier], x = new ai();
          x.curves = A.curves, R.holes.push(x);
        }), _.push(R);
      }
    }), _;
  }
  static getStrokeStyle(e, t, n, s, i) {
    return e = e !== void 0 ? e : 1, t = t !== void 0 ? t : "#000", n = n !== void 0 ? n : "miter", s = s !== void 0 ? s : "butt", i = i !== void 0 ? i : 4, {
      strokeColor: t,
      strokeWidth: e,
      strokeLineJoin: n,
      strokeLineCap: s,
      strokeMiterLimit: i
    };
  }
  static pointsToStroke(e, t, n, s) {
    const i = [], r = [], a = [];
    if (is.pointsToStrokeWithBuffers(e, t, n, s, i, r, a) === 0)
      return null;
    const l = new rt();
    return l.setAttribute("position", new it(i, 3)), l.setAttribute("normal", new it(r, 3)), l.setAttribute("uv", new it(a, 2)), l;
  }
  static pointsToStrokeWithBuffers(e, t, n, s, i, r, a, l) {
    const c = new le(), u = new le(), h = new le(), m = new le(), p = new le(), v = new le(), _ = new le(), y = new le(), E = new le(), R = new le(), T = new le(), g = new le(), A = new le(), x = new le(), M = new le(), d = new le(), w = new le();
    n = n !== void 0 ? n : 12, s = s !== void 0 ? s : 1e-3, l = l !== void 0 ? l : 0, e = $(e);
    const f = e.length;
    if (f < 2)
      return 0;
    const P = e[0].equals(e[f - 1]);
    let I, K = e[0], N;
    const Z = t.strokeWidth / 2, W = 1 / (f - 1);
    let X = 0, V, ne, se, he, H = !1, k = 0, b = l * 3, U = l * 2;
    J(e[0], e[1], c).multiplyScalar(Z), y.copy(e[0]).sub(c), E.copy(e[0]).add(c), R.copy(y), T.copy(E);
    for (let Y = 1; Y < f; Y++) {
      I = e[Y], Y === f - 1 ? P ? N = e[1] : N = void 0 : N = e[Y + 1];
      const te = c;
      if (J(K, I, te), h.copy(te).multiplyScalar(Z), g.copy(I).sub(h), A.copy(I).add(h), V = X + W, ne = !1, N !== void 0) {
        J(I, N, u), h.copy(u).multiplyScalar(Z), x.copy(I).sub(h), M.copy(I).add(h), se = !0, h.subVectors(N, K), te.dot(h) < 0 && (se = !1), Y === 1 && (H = se), h.subVectors(N, I), h.normalize();
        const O = Math.abs(te.dot(h));
        if (O !== 0) {
          const L = Z / O;
          h.multiplyScalar(-L), m.subVectors(I, K), p.copy(m).setLength(L).add(h), d.copy(p).negate();
          const re = p.length(), ce = m.length();
          m.divideScalar(ce), v.subVectors(N, I);
          const be = v.length();
          switch (v.divideScalar(be), m.dot(d) < ce && v.dot(d) < be && (ne = !0), w.copy(p).add(I), d.add(I), he = !1, ne ? se ? (M.copy(d), A.copy(d)) : (x.copy(d), g.copy(d)) : S(), t.strokeLineJoin) {
            case "bevel":
              C(se, ne, V);
              break;
            case "round":
              D(se, ne), se ? B(I, g, x, V, 0) : B(I, M, A, V, 1);
              break;
            case "miter":
            case "miter-clip":
            default:
              const Me = Z * t.strokeMiterLimit / re;
              if (Me < 1)
                if (t.strokeLineJoin !== "miter-clip") {
                  C(se, ne, V);
                  break;
                } else
                  D(se, ne), se ? (v.subVectors(w, g).multiplyScalar(Me).add(g), _.subVectors(w, x).multiplyScalar(Me).add(x), F(g, V, 0), F(v, V, 0), F(I, V, 0.5), F(I, V, 0.5), F(v, V, 0), F(_, V, 0), F(I, V, 0.5), F(_, V, 0), F(x, V, 0)) : (v.subVectors(w, A).multiplyScalar(Me).add(A), _.subVectors(w, M).multiplyScalar(Me).add(M), F(A, V, 1), F(v, V, 1), F(I, V, 0.5), F(I, V, 0.5), F(v, V, 1), F(_, V, 1), F(I, V, 0.5), F(_, V, 1), F(M, V, 1));
              else
                ne ? (se ? (F(E, X, 1), F(y, X, 0), F(w, V, 0), F(E, X, 1), F(w, V, 0), F(d, V, 1)) : (F(E, X, 1), F(y, X, 0), F(w, V, 1), F(y, X, 0), F(d, V, 0), F(w, V, 1)), se ? x.copy(w) : M.copy(w)) : se ? (F(g, V, 0), F(w, V, 0), F(I, V, 0.5), F(I, V, 0.5), F(w, V, 0), F(x, V, 0)) : (F(A, V, 1), F(w, V, 1), F(I, V, 0.5), F(I, V, 0.5), F(w, V, 1), F(M, V, 1)), he = !0;
              break;
          }
        } else
          S();
      } else
        S();
      !P && Y === f - 1 && G(e[0], R, T, se, !0, X), X = V, K = I, y.copy(x), E.copy(M);
    }
    if (!P)
      G(I, g, A, se, !1, V);
    else if (ne && i) {
      let Y = w, te = d;
      H !== se && (Y = d, te = w), se ? (he || H) && (te.toArray(i, 0 * 3), te.toArray(i, 3 * 3), he && Y.toArray(i, 1 * 3)) : (he || !H) && (te.toArray(i, 1 * 3), te.toArray(i, 3 * 3), he && Y.toArray(i, 0 * 3));
    }
    return k;
    function J(Y, te, O) {
      return O.subVectors(te, Y), O.set(-O.y, O.x).normalize();
    }
    function F(Y, te, O) {
      i && (i[b] = Y.x, i[b + 1] = Y.y, i[b + 2] = 0, r && (r[b] = 0, r[b + 1] = 0, r[b + 2] = 1), b += 3, a && (a[U] = te, a[U + 1] = O, U += 2)), k += 3;
    }
    function B(Y, te, O, L, re) {
      c.copy(te).sub(Y).normalize(), u.copy(O).sub(Y).normalize();
      let ce = Math.PI;
      const be = c.dot(u);
      Math.abs(be) < 1 && (ce = Math.abs(Math.acos(be))), ce /= n, h.copy(te);
      for (let Me = 0, Se = n - 1; Me < Se; Me++)
        m.copy(h).rotateAround(Y, ce), F(h, L, re), F(m, L, re), F(Y, L, 0.5), h.copy(m);
      F(m, L, re), F(O, L, re), F(Y, L, 0.5);
    }
    function S() {
      F(E, X, 1), F(y, X, 0), F(g, V, 0), F(E, X, 1), F(g, V, 1), F(A, V, 0);
    }
    function C(Y, te, O) {
      te ? Y ? (F(E, X, 1), F(y, X, 0), F(g, V, 0), F(E, X, 1), F(g, V, 0), F(d, V, 1), F(g, O, 0), F(x, O, 0), F(d, O, 0.5)) : (F(E, X, 1), F(y, X, 0), F(A, V, 1), F(y, X, 0), F(d, V, 0), F(A, V, 1), F(A, O, 1), F(M, O, 0), F(d, O, 0.5)) : Y ? (F(g, O, 0), F(x, O, 0), F(I, O, 0.5)) : (F(A, O, 1), F(M, O, 0), F(I, O, 0.5));
    }
    function D(Y, te) {
      te && (Y ? (F(E, X, 1), F(y, X, 0), F(g, V, 0), F(E, X, 1), F(g, V, 0), F(d, V, 1), F(g, X, 0), F(I, V, 0.5), F(d, V, 1), F(I, V, 0.5), F(x, X, 0), F(d, V, 1)) : (F(E, X, 1), F(y, X, 0), F(A, V, 1), F(y, X, 0), F(d, V, 0), F(A, V, 1), F(A, X, 1), F(d, V, 0), F(I, V, 0.5), F(I, V, 0.5), F(d, V, 0), F(M, X, 1)));
    }
    function G(Y, te, O, L, re, ce) {
      switch (t.strokeLineCap) {
        case "round":
          re ? B(Y, O, te, ce, 0.5) : B(Y, te, O, ce, 0.5);
          break;
        case "square":
          if (re)
            c.subVectors(te, Y), u.set(c.y, -c.x), h.addVectors(c, u).add(Y), m.subVectors(u, c).add(Y), L ? (h.toArray(i, 1 * 3), m.toArray(i, 0 * 3), m.toArray(i, 3 * 3)) : (h.toArray(i, 1 * 3), h.toArray(i, 3 * 3), m.toArray(i, 0 * 3));
          else {
            c.subVectors(O, Y), u.set(c.y, -c.x), h.addVectors(c, u).add(Y), m.subVectors(u, c).add(Y);
            const be = i.length;
            L ? (h.toArray(i, be - 1 * 3), m.toArray(i, be - 2 * 3), m.toArray(i, be - 4 * 3)) : (h.toArray(i, be - 2 * 3), m.toArray(i, be - 1 * 3), m.toArray(i, be - 4 * 3));
          }
          break;
      }
    }
    function $(Y) {
      let te = !1;
      for (let L = 1, re = Y.length - 1; L < re; L++)
        if (Y[L].distanceTo(Y[L + 1]) < s) {
          te = !0;
          break;
        }
      if (!te)
        return Y;
      const O = [];
      O.push(Y[0]);
      for (let L = 1, re = Y.length - 1; L < re; L++)
        Y[L].distanceTo(Y[L + 1]) >= s && O.push(Y[L]);
      return O.push(Y[Y.length - 1]), O;
    }
  }
}
const xi = /* @__PURE__ */ new WeakMap();
class hh extends cs {
  constructor(e) {
    super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    }, this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(e) {
    return this.decoderPath = e, this;
  }
  setDecoderConfig(e) {
    return this.decoderConfig = e, this;
  }
  setWorkerLimit(e) {
    return this.workerLimit = e, this;
  }
  load(e, t, n, s) {
    const i = new Tn(this.manager);
    i.setPath(this.path), i.setResponseType("arraybuffer"), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials), i.load(
      e,
      (r) => {
        const a = {
          attributeIDs: this.defaultAttributeIDs,
          attributeTypes: this.defaultAttributeTypes,
          useUniqueIDs: !1
        };
        this.decodeGeometry(r, a).then(t).catch(s);
      },
      n,
      s
    );
  }
  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */
  decodeDracoFile(e, t, n, s) {
    const i = {
      attributeIDs: n || this.defaultAttributeIDs,
      attributeTypes: s || this.defaultAttributeTypes,
      useUniqueIDs: !!n
    };
    this.decodeGeometry(e, i).then(t);
  }
  decodeGeometry(e, t) {
    for (const l in t.attributeTypes) {
      const c = t.attributeTypes[l];
      c.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[l] = c.name);
    }
    const n = JSON.stringify(t);
    if (xi.has(e)) {
      const l = xi.get(e);
      if (l.key === n)
        return l.promise;
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let s;
    const i = this.workerNextTaskID++, r = e.byteLength, a = this._getWorker(i, r).then((l) => (s = l, new Promise((c, u) => {
      s._callbacks[i] = { resolve: c, reject: u }, s.postMessage({ type: "decode", id: i, taskConfig: t, buffer: e }, [e]);
    }))).then((l) => this._createGeometry(l.geometry));
    return a.catch(() => !0).then(() => {
      s && i && this._releaseTask(s, i);
    }), xi.set(e, {
      key: n,
      promise: a
    }), a;
  }
  _createGeometry(e) {
    const t = new rt();
    e.index && t.setIndex(new pt(e.index.array, 1));
    for (let n = 0; n < e.attributes.length; n++) {
      const s = e.attributes[n], i = s.name, r = s.array, a = s.itemSize;
      t.setAttribute(i, new pt(r, a));
    }
    return t;
  }
  _loadLibrary(e, t) {
    const n = new Tn(this.manager);
    return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise((s, i) => {
      n.load(e, s, void 0, i);
    });
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending)
      return this.decoderPending;
    const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js", t = [];
    return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((n) => {
      const s = n[0];
      e || (this.decoderConfig.wasmBinary = n[1]);
      const i = fh.toString(), r = [
        "/* draco decoder */",
        s,
        "",
        "/* worker */",
        i.substring(i.indexOf("{") + 1, i.lastIndexOf("}"))
      ].join(`
`);
      this.workerSourceURL = URL.createObjectURL(new Blob([r]));
    }), this.decoderPending;
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const s = new Worker(this.workerSourceURL);
        s._callbacks = {}, s._taskCosts = {}, s._taskLoad = 0, s.postMessage({ type: "init", decoderConfig: this.decoderConfig }), s.onmessage = function(i) {
          const r = i.data;
          switch (r.type) {
            case "decode":
              s._callbacks[r.id].resolve(r);
              break;
            case "error":
              s._callbacks[r.id].reject(r);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + r.type + '"');
          }
        }, this.workerPool.push(s);
      } else
        this.workerPool.sort(function(s, i) {
          return s._taskLoad > i._taskLoad ? -1 : 1;
        });
      const n = this.workerPool[this.workerPool.length - 1];
      return n._taskCosts[e] = t, n._taskLoad += t, n;
    });
  }
  _releaseTask(e, t) {
    e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t];
  }
  debug() {
    console.log(
      "Task load: ",
      this.workerPool.map((e) => e._taskLoad)
    );
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return this.workerPool.length = 0, this;
  }
}
function fh() {
  let o, e;
  onmessage = function(r) {
    const a = r.data;
    switch (a.type) {
      case "init":
        o = a.decoderConfig, e = new Promise(function(u) {
          o.onModuleLoaded = function(h) {
            u({ draco: h });
          }, DracoDecoderModule(o);
        });
        break;
      case "decode":
        const l = a.buffer, c = a.taskConfig;
        e.then((u) => {
          const h = u.draco, m = new h.Decoder(), p = new h.DecoderBuffer();
          p.Init(new Int8Array(l), l.byteLength);
          try {
            const v = t(h, m, p, c), _ = v.attributes.map((y) => y.array.buffer);
            v.index && _.push(v.index.array.buffer), self.postMessage({ type: "decode", id: a.id, geometry: v }, _);
          } catch (v) {
            console.error(v), self.postMessage({ type: "error", id: a.id, error: v.message });
          } finally {
            h.destroy(p), h.destroy(m);
          }
        });
        break;
    }
  };
  function t(r, a, l, c) {
    const u = c.attributeIDs, h = c.attributeTypes;
    let m, p;
    const v = a.GetEncodedGeometryType(l);
    if (v === r.TRIANGULAR_MESH)
      m = new r.Mesh(), p = a.DecodeBufferToMesh(l, m);
    else if (v === r.POINT_CLOUD)
      m = new r.PointCloud(), p = a.DecodeBufferToPointCloud(l, m);
    else
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!p.ok() || m.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + p.error_msg());
    const _ = { index: null, attributes: [] };
    for (const y in u) {
      const E = self[h[y]];
      let R, T;
      if (c.useUniqueIDs)
        T = u[y], R = a.GetAttributeByUniqueId(m, T);
      else {
        if (T = a.GetAttributeId(m, r[u[y]]), T === -1)
          continue;
        R = a.GetAttribute(m, T);
      }
      _.attributes.push(s(r, a, m, y, E, R));
    }
    return v === r.TRIANGULAR_MESH && (_.index = n(r, a, m)), r.destroy(m), _;
  }
  function n(r, a, l) {
    const u = l.num_faces() * 3, h = u * 4, m = r._malloc(h);
    a.GetTrianglesUInt32Array(l, h, m);
    const p = new Uint32Array(r.HEAPF32.buffer, m, u).slice();
    return r._free(m), { array: p, itemSize: 1 };
  }
  function s(r, a, l, c, u, h) {
    const m = h.num_components(), v = l.num_points() * m, _ = v * u.BYTES_PER_ELEMENT, y = i(r, u), E = r._malloc(_);
    a.GetAttributeDataArrayForAllPoints(l, h, y, _, E);
    const R = new u(r.HEAPF32.buffer, E, v).slice();
    return r._free(E), {
      name: c,
      array: R,
      itemSize: m
    };
  }
  function i(r, a) {
    switch (a) {
      case Float32Array:
        return r.DT_FLOAT32;
      case Int8Array:
        return r.DT_INT8;
      case Int16Array:
        return r.DT_INT16;
      case Int32Array:
        return r.DT_INT32;
      case Uint8Array:
        return r.DT_UINT8;
      case Uint16Array:
        return r.DT_UINT16;
      case Uint32Array:
        return r.DT_UINT32;
    }
  }
}
class Ra extends Ie {
  constructor(e, t) {
    const n = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], s = new rt();
    s.setAttribute("position", new it(n, 3)), s.computeBoundingSphere();
    const i = new qs({ fog: !1 });
    super(s, i), this.light = e, this.color = t, this.type = "RectAreaLightHelper";
    const r = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], a = new rt();
    a.setAttribute("position", new it(r, 3)), a.computeBoundingSphere(), this.add(new ae(a, new Gt({ side: ta, fog: !1 })));
  }
  updateMatrixWorld() {
    if (this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1), this.color !== void 0)
      this.material.color.set(this.color), this.children[0].material.color.set(this.color);
    else {
      this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      const e = this.material.color, t = Math.max(e.r, e.g, e.b);
      t > 1 && e.multiplyScalar(1 / t), this.children[0].material.color.copy(this.material.color);
    }
    this.matrixWorld.extractRotation(this.light.matrixWorld).scale(this.scale).copyPosition(this.light.matrixWorld), this.children[0].matrixWorld.copy(this.matrixWorld);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}
const dh = ["args", "center"], Lm = /* @__PURE__ */ pe({
  __name: "Text3D",
  props: {
    font: {},
    text: {},
    size: { default: 0.5 },
    height: { default: 0.2 },
    curveSegments: { default: 5 },
    bevelEnabled: { type: Boolean, default: !0 },
    bevelThickness: { default: 0.05 },
    bevelSize: { default: 0.02 },
    bevelOffset: { default: 0 },
    bevelSegments: { default: 4 },
    center: { type: Boolean, default: !1 },
    needUpdates: { type: Boolean, default: !1 }
  },
  async setup(o, { expose: e }) {
    let t, n;
    const s = o, {
      center: i,
      font: r,
      text: a,
      needUpdates: l,
      size: c,
      height: u,
      curveSegments: h,
      bevelEnabled: m,
      bevelThickness: p,
      bevelSize: v,
      bevelOffset: _,
      bevelSegments: y
    } = Fe(s), { extend: E } = je();
    E({ TextGeometry: Vr });
    const R = new lh(), T = ra(), g = Ne(() => {
      var d;
      return a != null && a.value ? a.value : T.default ? (d = T.default()[0].children) == null ? void 0 : d.trim() : l.value ? "" : "TresJS";
    }), A = xe();
    e({
      value: A
    });
    const x = ([t, n] = fs(() => new Promise((d, w) => {
      try {
        typeof r.value == "string" ? R.load(r.value, (f) => {
          d(f);
        }) : d(r.value);
      } catch (f) {
        w(console.error("cientos", f));
      }
    })), t = await t, n(), t), M = Ne(() => ({
      font: x,
      size: Kt(c),
      height: Kt(u),
      curveSegments: Kt(h),
      bevelEnabled: Kt(m),
      bevelThickness: Kt(p),
      bevelSize: Kt(v),
      bevelOffset: Kt(_),
      bevelSegments: Kt(y)
    }));
    return ft(() => {
      A.value && l.value && (A.value.geometry.dispose(), A.value.geometry = new Vr(g.value, M.value), i.value && A.value.geometry.center());
    }), (d, w) => z(r) ? (fe(), de("TresMesh", {
      key: 0,
      ref_key: "text3DRef",
      ref: A
    }, [
      g.value ? (fe(), de("TresTextGeometry", {
        key: 0,
        args: [g.value, M.value],
        center: z(i)
      }, null, 8, dh)) : Wt("", !0),
      $e(d.$slots, "default")
    ], 512)) : Wt("", !0);
  }
});
function Om(o, e) {
  const t = ue(e), n = new Al(t.value), s = Ql({});
  o.forEach((r) => {
    const a = n.clipAction(r, t.value);
    s[r.name] = a;
  });
  const { onLoop: i } = Ke();
  return i(({ delta: r }) => {
    n.update(r);
  }), {
    actions: s,
    mixer: n
  };
}
const Fm = /* @__PURE__ */ pe({
  __name: "Levioso",
  props: {
    speed: { default: 1 },
    rotationFactor: { default: 1 },
    floatFactor: { default: 1 },
    range: { default: () => [-0.1, 0.1] }
  },
  setup(o, { expose: e }) {
    const t = o, n = xe();
    e({
      value: n
    });
    {
      const l = Math.random() * 1e4, { onLoop: c } = Ke();
      let u = l;
      c(({ delta: h }) => {
        if (!n.value)
          return;
        u += h * t.speed;
        const m = u * 0.25, p = n.value;
        p.rotation.x = Math.cos(m) * 0.125 * t.rotationFactor, p.rotation.y = Math.sin(m) * 0.125 * t.rotationFactor, p.rotation.z = Math.sin(m) * 0.05 * t.rotationFactor, p.position.y = We.mapLinear(Math.sin(m), -1, 1, t.range[0], t.range[1]) * t.floatFactor;
      });
    }
    return (s, i) => (fe(), de("TresGroup", Ye(s.$attrs, {
      ref_key: "groupRef",
      ref: n
    }), [
      $e(s.$slots, "default")
    ], 16));
  }
});
class os extends ae {
  constructor(e, t = {}) {
    super(e), this.isReflector = !0, this.type = "Reflector", this.camera = new Mt();
    const n = this, s = t.color !== void 0 ? new Be(t.color) : new Be(8355711), i = t.textureWidth || 512, r = t.textureHeight || 512, a = t.clipBias || 0, l = t.shader || os.ReflectorShader, c = t.multisample !== void 0 ? t.multisample : 4, u = new lr(), h = new ee(), m = new ee(), p = new ee(), v = new De(), _ = new ee(0, 0, -1), y = new ht(), E = new ee(), R = new ee(), T = new ht(), g = new De(), A = this.camera, x = new bn(i, r, { samples: c, type: un }), M = new Xt({
      name: l.name !== void 0 ? l.name : "unspecified",
      uniforms: Js.clone(l.uniforms),
      fragmentShader: l.fragmentShader,
      vertexShader: l.vertexShader
    });
    M.uniforms.tDiffuse.value = x.texture, M.uniforms.color.value = s, M.uniforms.textureMatrix.value = g, this.material = M, this.onBeforeRender = function(d, w, f) {
      if (m.setFromMatrixPosition(n.matrixWorld), p.setFromMatrixPosition(f.matrixWorld), v.extractRotation(n.matrixWorld), h.set(0, 0, 1), h.applyMatrix4(v), E.subVectors(m, p), E.dot(h) > 0)
        return;
      E.reflect(h).negate(), E.add(m), v.extractRotation(f.matrixWorld), _.set(0, 0, -1), _.applyMatrix4(v), _.add(p), R.subVectors(m, _), R.reflect(h).negate(), R.add(m), A.position.copy(E), A.up.set(0, 1, 0), A.up.applyMatrix4(v), A.up.reflect(h), A.lookAt(R), A.far = f.far, A.updateMatrixWorld(), A.projectionMatrix.copy(f.projectionMatrix), g.set(
        0.5,
        0,
        0,
        0.5,
        0,
        0.5,
        0,
        0.5,
        0,
        0,
        0.5,
        0.5,
        0,
        0,
        0,
        1
      ), g.multiply(A.projectionMatrix), g.multiply(A.matrixWorldInverse), g.multiply(n.matrixWorld), u.setFromNormalAndCoplanarPoint(h, m), u.applyMatrix4(A.matrixWorldInverse), y.set(u.normal.x, u.normal.y, u.normal.z, u.constant);
      const P = A.projectionMatrix;
      T.x = (Math.sign(y.x) + P.elements[8]) / P.elements[0], T.y = (Math.sign(y.y) + P.elements[9]) / P.elements[5], T.z = -1, T.w = (1 + P.elements[10]) / P.elements[14], y.multiplyScalar(2 / y.dot(T)), P.elements[2] = y.x, P.elements[6] = y.y, P.elements[10] = y.z + 1 - a, P.elements[14] = y.w, n.visible = !1;
      const I = d.getRenderTarget(), K = d.xr.enabled, N = d.shadowMap.autoUpdate;
      d.xr.enabled = !1, d.shadowMap.autoUpdate = !1, d.setRenderTarget(x), d.state.buffers.depth.setMask(!0), d.autoClear === !1 && d.clear(), d.render(w, A), d.xr.enabled = K, d.shadowMap.autoUpdate = N, d.setRenderTarget(I);
      const Z = f.viewport;
      Z !== void 0 && d.state.viewport(Z), n.visible = !0;
    }, this.getRenderTarget = function() {
      return x;
    }, this.dispose = function() {
      x.dispose(), n.material.dispose();
    };
  }
}
os.ReflectorShader = {
  name: "ReflectorShader",
  uniforms: {
    color: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    textureMatrix: {
      value: null
    }
  },
  vertexShader: (
    /* glsl */
    `
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		#include <common>
		#include <logdepthbuf_pars_vertex>

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			#include <logdepthbuf_vertex>

		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		varying vec4 vUv;

		#include <logdepthbuf_pars_fragment>

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			#include <logdepthbuf_fragment>

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`
  )
};
const ph = ["args", "material-uniforms-color-value"], mh = /* @__PURE__ */ Te("TresPlaneGeometry", { args: [5, 5] }, null, -1), km = /* @__PURE__ */ pe({
  __name: "Reflector",
  props: {
    color: { default: "#333" },
    textureWidth: { default: 512 },
    textureHeight: { default: 512 },
    clipBias: { default: 0 },
    multisample: { default: 4 },
    shader: { default: os.ReflectorShader }
  },
  setup(o, { expose: e }) {
    const t = o, { extend: n } = je(), s = xe();
    n({ Reflector: os });
    const { color: i, textureWidth: r, textureHeight: a, clipBias: l, multisample: c, shader: u } = Fe(t);
    return e({
      reflectorRef: s
    }), (h, m) => (fe(), de("TresReflector", {
      ref_key: "reflectorRef",
      ref: s,
      args: [void 0, { textureWidth: z(r), textureHeight: z(a), clipBias: z(l), multisample: z(c), shader: z(u) }],
      "material-uniforms-color-value": z(i)
    }, [
      $e(h.$slots, "default", {}, () => [
        mh
      ])
    ], 8, ph));
  }
});
function Ca(o) {
  return Jl() ? (ec(o), !0) : !1;
}
function dt(o) {
  return typeof o == "function" ? o() : z(o);
}
const gh = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const yh = Object.prototype.toString, vh = (o) => yh.call(o) === "[object Object]", En = () => {
};
function pr(o, e) {
  function t(...n) {
    return new Promise((s, i) => {
      Promise.resolve(o(() => e.apply(this, n), { fn: e, thisArg: this, args: n })).then(s).catch(i);
    });
  }
  return t;
}
const _h = (o) => o();
function xh(o, e = {}) {
  let t, n, s = En;
  const i = (a) => {
    clearTimeout(a), s(), s = En;
  };
  return (a) => {
    const l = dt(o), c = dt(e.maxWait);
    return t && i(t), l <= 0 || c !== void 0 && c <= 0 ? (n && (i(n), n = null), Promise.resolve(a())) : new Promise((u, h) => {
      s = e.rejectOnCancel ? h : u, c && !n && (n = setTimeout(() => {
        t && i(t), n = null, u(a());
      }, c)), t = setTimeout(() => {
        n && i(n), n = null, u(a());
      }, l);
    });
  };
}
function Ia(o, e = !0, t = !0, n = !1) {
  let s = 0, i, r = !0, a = En, l;
  const c = () => {
    i && (clearTimeout(i), i = void 0, a(), a = En);
  };
  return (h) => {
    const m = dt(o), p = Date.now() - s, v = () => l = h();
    return c(), m <= 0 ? (s = Date.now(), v()) : (p > m && (t || !r) ? (s = Date.now(), v()) : e && (l = new Promise((_, y) => {
      a = n ? y : _, i = setTimeout(() => {
        s = Date.now(), r = !0, _(v()), c();
      }, Math.max(0, m - p));
    })), !t && !i && (i = setTimeout(() => r = !0, m)), r = !1, l);
  };
}
function wh(o) {
  return o || oa();
}
function Th(o, e = 200, t = {}) {
  return pr(
    xh(e, t),
    o
  );
}
function bh(o, e = 200, t = !1, n = !0, s = !1) {
  return pr(
    Ia(e, t, n, s),
    o
  );
}
function Eh(o, e, t = {}) {
  const {
    eventFilter: n = _h,
    ...s
  } = t;
  return we(
    o,
    pr(
      n,
      e
    ),
    s
  );
}
function Da(o, e = !0, t) {
  wh() ? ds(o, t) : e ? o() : tc(o);
}
function Mh(o, e, t = {}) {
  const {
    throttle: n = 0,
    trailing: s = !0,
    leading: i = !0,
    ...r
  } = t;
  return Eh(
    o,
    e,
    {
      ...r,
      eventFilter: Ia(n, s, i)
    }
  );
}
function Sh(o) {
  var e;
  const t = dt(o);
  return (e = t == null ? void 0 : t.$el) != null ? e : t;
}
const Mn = gh ? window : void 0;
function Ve(...o) {
  let e, t, n, s;
  if (typeof o[0] == "string" || Array.isArray(o[0]) ? ([t, n, s] = o, e = Mn) : [e, t, n, s] = o, !e)
    return En;
  Array.isArray(t) || (t = [t]), Array.isArray(n) || (n = [n]);
  const i = [], r = () => {
    i.forEach((u) => u()), i.length = 0;
  }, a = (u, h, m, p) => (u.addEventListener(h, m, p), () => u.removeEventListener(h, m, p)), l = we(
    () => [Sh(e), dt(s)],
    ([u, h]) => {
      if (r(), !u)
        return;
      const m = vh(h) ? { ...h } : h;
      i.push(
        ...t.flatMap((p) => n.map((v) => a(u, p, v, m)))
      );
    },
    { immediate: !0, flush: "post" }
  ), c = () => {
    l(), r();
  };
  return Ca(c), c;
}
function Ah(o) {
  return typeof o == "function" ? o : typeof o == "string" ? (e) => e.key === o : Array.isArray(o) ? (e) => o.includes(e.key) : () => !0;
}
function mn(...o) {
  let e, t, n = {};
  o.length === 3 ? (e = o[0], t = o[1], n = o[2]) : o.length === 2 ? typeof o[1] == "object" ? (e = !0, t = o[0], n = o[1]) : (e = o[0], t = o[1]) : (e = !0, t = o[0]);
  const {
    target: s = Mn,
    eventName: i = "keydown",
    passive: r = !1,
    dedupe: a = !1
  } = n, l = Ah(e);
  return Ve(s, i, (u) => {
    u.repeat && dt(a) || l(u) && t(u);
  }, r);
}
function Ph() {
  const o = ue(!1);
  return oa() && ds(() => {
    o.value = !0;
  }), o;
}
function Rh(o) {
  const e = Ph();
  return Ne(() => (e.value, !!o()));
}
function Ch(o, e = {}) {
  const { window: t = Mn } = e, n = Rh(() => t && "matchMedia" in t && typeof t.matchMedia == "function");
  let s;
  const i = ue(!1), r = (c) => {
    i.value = c.matches;
  }, a = () => {
    s && ("removeEventListener" in s ? s.removeEventListener("change", r) : s.removeListener(r));
  }, l = ft(() => {
    n.value && (a(), s = t.matchMedia(dt(o)), "addEventListener" in s ? s.addEventListener("change", r) : s.addListener(r), i.value = s.matches);
  });
  return Ca(() => {
    l(), a(), s = void 0;
  }), i;
}
const Kr = 1;
function Ih(o, e = {}) {
  const {
    throttle: t = 0,
    idle: n = 200,
    onStop: s = En,
    onScroll: i = En,
    offset: r = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    },
    eventListenerOptions: a = {
      capture: !1,
      passive: !0
    },
    behavior: l = "auto",
    window: c = Mn
  } = e, u = ue(0), h = ue(0), m = Ne({
    get() {
      return u.value;
    },
    set(x) {
      v(x, void 0);
    }
  }), p = Ne({
    get() {
      return h.value;
    },
    set(x) {
      v(void 0, x);
    }
  });
  function v(x, M) {
    var d, w, f;
    if (!c)
      return;
    const P = dt(o);
    P && ((f = P instanceof Document ? c.document.body : P) == null || f.scrollTo({
      top: (d = dt(M)) != null ? d : p.value,
      left: (w = dt(x)) != null ? w : m.value,
      behavior: dt(l)
    }));
  }
  const _ = ue(!1), y = Xi({
    left: !0,
    right: !1,
    top: !0,
    bottom: !1
  }), E = Xi({
    left: !1,
    right: !1,
    top: !1,
    bottom: !1
  }), R = (x) => {
    _.value && (_.value = !1, E.left = !1, E.right = !1, E.top = !1, E.bottom = !1, s(x));
  }, T = Th(R, t + n), g = (x) => {
    var M;
    if (!c)
      return;
    const d = x.document ? x.document.documentElement : (M = x.documentElement) != null ? M : x, { display: w, flexDirection: f } = getComputedStyle(d), P = d.scrollLeft;
    E.left = P < u.value, E.right = P > u.value;
    const I = Math.abs(P) <= 0 + (r.left || 0), K = Math.abs(P) + d.clientWidth >= d.scrollWidth - (r.right || 0) - Kr;
    w === "flex" && f === "row-reverse" ? (y.left = K, y.right = I) : (y.left = I, y.right = K), u.value = P;
    let N = d.scrollTop;
    x === c.document && !N && (N = c.document.body.scrollTop), E.top = N < h.value, E.bottom = N > h.value;
    const Z = Math.abs(N) <= 0 + (r.top || 0), W = Math.abs(N) + d.clientHeight >= d.scrollHeight - (r.bottom || 0) - Kr;
    w === "flex" && f === "column-reverse" ? (y.top = W, y.bottom = Z) : (y.top = Z, y.bottom = W), h.value = N;
  }, A = (x) => {
    var M;
    if (!c)
      return;
    const d = (M = x.target.documentElement) != null ? M : x.target;
    g(d), _.value = !0, T(x), i(x);
  };
  return Ve(
    o,
    "scroll",
    t ? bh(A, t, !0, !1) : A,
    a
  ), Da(() => {
    const x = dt(o);
    x && g(x);
  }), Ve(
    o,
    "scrollend",
    R,
    a
  ), {
    x: m,
    y: p,
    isScrolling: _,
    arrivedState: y,
    directions: E,
    measure() {
      const x = dt(o);
      c && x && g(x);
    }
  };
}
const Dh = {
  page: (o) => [o.pageX, o.pageY],
  client: (o) => [o.clientX, o.clientY],
  screen: (o) => [o.screenX, o.screenY],
  movement: (o) => o instanceof Touch ? null : [o.movementX, o.movementY]
};
function Lh(o = {}) {
  const {
    type: e = "page",
    touch: t = !0,
    resetOnTouchEnds: n = !1,
    initialValue: s = { x: 0, y: 0 },
    window: i = Mn,
    target: r = i,
    scroll: a = !0,
    eventFilter: l
  } = o;
  let c = null;
  const u = ue(s.x), h = ue(s.y), m = ue(null), p = typeof e == "function" ? e : Dh[e], v = (A) => {
    const x = p(A);
    c = A, x && ([u.value, h.value] = x, m.value = "mouse");
  }, _ = (A) => {
    if (A.touches.length > 0) {
      const x = p(A.touches[0]);
      x && ([u.value, h.value] = x, m.value = "touch");
    }
  }, y = () => {
    if (!c || !i)
      return;
    const A = p(c);
    c instanceof MouseEvent && A && (u.value = A[0] + i.scrollX, h.value = A[1] + i.scrollY);
  }, E = () => {
    u.value = s.x, h.value = s.y;
  }, R = l ? (A) => l(() => v(A), {}) : (A) => v(A), T = l ? (A) => l(() => _(A), {}) : (A) => _(A), g = l ? () => l(() => y(), {}) : () => y();
  if (r) {
    const A = { passive: !0 };
    Ve(r, ["mousemove", "dragover"], R, A), t && e !== "movement" && (Ve(r, ["touchstart", "touchmove"], T, A), n && Ve(r, "touchend", E, A)), a && e === "page" && Ve(i, "scroll", g, { passive: !0 });
  }
  return {
    x: u,
    y: h,
    sourceType: m
  };
}
function Oh(o = {}) {
  const { window: e = Mn, behavior: t = "auto" } = o;
  if (!e)
    return {
      x: ue(0),
      y: ue(0)
    };
  const n = ue(e.scrollX), s = ue(e.scrollY), i = Ne({
    get() {
      return n.value;
    },
    set(a) {
      scrollTo({ left: a, behavior: t });
    }
  }), r = Ne({
    get() {
      return s.value;
    },
    set(a) {
      scrollTo({ top: a, behavior: t });
    }
  });
  return Ve(
    e,
    "scroll",
    () => {
      n.value = e.scrollX, s.value = e.scrollY;
    },
    {
      capture: !1,
      passive: !0
    }
  ), { x: i, y: r };
}
function La(o = {}) {
  const {
    window: e = Mn,
    initialWidth: t = Number.POSITIVE_INFINITY,
    initialHeight: n = Number.POSITIVE_INFINITY,
    listenOrientation: s = !0,
    includeScrollbar: i = !0
  } = o, r = ue(t), a = ue(n), l = () => {
    e && (i ? (r.value = e.innerWidth, a.value = e.innerHeight) : (r.value = e.document.documentElement.clientWidth, a.value = e.document.documentElement.clientHeight));
  };
  if (l(), Da(l), Ve("resize", l, { passive: !0 }), s) {
    const c = Ch("(orientation: portrait)");
    we(c, () => l());
  }
  return { width: r, height: a };
}
const Um = /* @__PURE__ */ pe({
  __name: "MouseParallax",
  props: {
    disabled: { type: Boolean, default: !1 },
    factor: { default: 2.5 },
    ease: { default: 0.1 }
  },
  setup(o) {
    const e = o, { camera: t } = je(), { disabled: n, factor: s, ease: i } = Fe(e), { x: r, y: a } = Lh(), { width: l, height: c } = La(), u = ue(), h = Ne(() => (r.value / l.value - 0.5) * s.value), m = Ne(() => -(a.value / c.value - 0.5) * s.value), { onLoop: p } = Ke();
    return p(({ delta: v }) => {
      n.value || !u.value || (u.value.position.x += (h.value - u.value.position.x) * i.value * v, u.value.position.y += (m.value - u.value.position.y) * i.value * v);
    }), we(
      () => u.value,
      (v) => v == null ? void 0 : v.add(t.value)
    ), (v, _) => (fe(), de("TresGroup", {
      ref_key: "cameraGroupRef",
      ref: u
    }, null, 512));
  }
}), Bm = pe({
  name: "GlobalAudio",
  props: [
    "src",
    "loop",
    "volume",
    "playbackRate",
    "playTrigger",
    "stopTrigger"
  ],
  async setup(o, { expose: e, emit: t }) {
    var h;
    const { camera: n, renderer: s } = je(), i = new Pl();
    (h = n.value) == null || h.add(i);
    const r = new Rl(i), a = new Cl();
    e({ sound: r }), ot(() => {
      r && r.disconnect();
    }), we(() => [o.playbackRate], () => r.setPlaybackRate(o.playbackRate ?? 1), { immediate: !0 }), we(() => [o.volume], () => r.setVolume(o.volume ?? 0.5), { immediate: !0 }), we(() => [o.loop], () => r.setLoop(o.loop ?? !1), { immediate: !0 }), we(() => [o.src], async () => {
      const m = await a.loadAsync(o.src);
      r.setBuffer(m);
    }, { immediate: !0 });
    const l = document.getElementById(o.playTrigger ?? ""), c = l || s.value.domElement;
    Ve(c, "click", () => {
      r.isPlaying ? r.pause() : r.play(), t("isPlaying", r.isPlaying);
    });
    const u = document.getElementById(o.stopTrigger ?? "");
    return u && Ve(u, "click", () => {
      r.stop(), t("isPlaying", r.isPlaying);
    }), null;
  }
});
class as extends ae {
  constructor() {
    super(as.Geometry, new Gt({ opacity: 0, transparent: !0 })), this.isLensflare = !0, this.type = "Lensflare", this.frustumCulled = !1, this.renderOrder = 1 / 0;
    const e = new ee(), t = new ee(), n = new Pr(16, 16), s = new Pr(16, 16);
    let i = Vi;
    const r = as.Geometry, a = new li({
      uniforms: {
        scale: { value: null },
        screenPosition: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				precision highp float;

				uniform vec3 screenPosition;
				uniform vec2 scale;

				attribute vec3 position;

				void main() {

					gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );

				}`
      ),
      fragmentShader: (
        /* glsl */
        `

				precision highp float;

				void main() {

					gl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );

				}`
      ),
      depthTest: !0,
      depthWrite: !1,
      transparent: !1
    }), l = new li({
      uniforms: {
        map: { value: n },
        scale: { value: null },
        screenPosition: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				precision highp float;

				uniform vec3 screenPosition;
				uniform vec2 scale;

				attribute vec3 position;
				attribute vec2 uv;

				varying vec2 vUV;

				void main() {

					vUV = uv;

					gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );

				}`
      ),
      fragmentShader: (
        /* glsl */
        `

				precision highp float;

				uniform sampler2D map;

				varying vec2 vUV;

				void main() {

					gl_FragColor = texture2D( map, vUV );

				}`
      ),
      depthTest: !1,
      depthWrite: !1,
      transparent: !1
    }), c = new ae(r, a), u = [], h = Oa.Shader, m = new li({
      name: h.name,
      uniforms: {
        map: { value: null },
        occlusionMap: { value: s },
        color: { value: new Be(16777215) },
        scale: { value: new le() },
        screenPosition: { value: new ee() }
      },
      vertexShader: h.vertexShader,
      fragmentShader: h.fragmentShader,
      blending: na,
      transparent: !0,
      depthWrite: !1
    }), p = new ae(r, m);
    this.addElement = function(R) {
      u.push(R);
    };
    const v = new le(), _ = new le(), y = new ea(), E = new ht();
    this.onBeforeRender = function(R, T, g) {
      R.getCurrentViewport(E);
      const A = R.getRenderTarget(), x = A !== null ? A.texture.type : Vi;
      i !== x && (n.dispose(), s.dispose(), n.type = s.type = x, i = x);
      const M = E.w / E.z, d = E.z / 2, w = E.w / 2;
      let f = 16 / E.w;
      if (v.set(f * M, f), y.min.set(E.x, E.y), y.max.set(E.x + (E.z - 16), E.y + (E.w - 16)), t.setFromMatrixPosition(this.matrixWorld), t.applyMatrix4(g.matrixWorldInverse), !(t.z > 0) && (e.copy(t).applyMatrix4(g.projectionMatrix), _.x = E.x + e.x * d + d - 8, _.y = E.y + e.y * w + w - 8, y.containsPoint(_))) {
        R.copyFramebufferToTexture(_, n);
        let P = a.uniforms;
        P.scale.value = v, P.screenPosition.value = e, R.renderBufferDirect(g, null, r, a, c, null), R.copyFramebufferToTexture(_, s), P = l.uniforms, P.scale.value = v, P.screenPosition.value = e, R.renderBufferDirect(g, null, r, l, c, null);
        const I = -e.x * 2, K = -e.y * 2;
        for (let N = 0, Z = u.length; N < Z; N++) {
          const W = u[N], X = m.uniforms;
          X.color.value.copy(W.color), X.map.value = W.texture, X.screenPosition.value.x = e.x + I * W.distance, X.screenPosition.value.y = e.y + K * W.distance, f = W.size / E.w;
          const V = E.w / E.z;
          X.scale.value.set(f * V, f), m.uniformsNeedUpdate = !0, R.renderBufferDirect(g, null, r, m, p, null);
        }
      }
    }, this.dispose = function() {
      a.dispose(), l.dispose(), m.dispose(), n.dispose(), s.dispose();
      for (let R = 0, T = u.length; R < T; R++)
        u[R].texture.dispose();
    };
  }
}
class Oa {
  constructor(e, t = 1, n = 0, s = new Be(16777215)) {
    this.texture = e, this.size = t, this.distance = n, this.color = s;
  }
}
Oa.Shader = {
  name: "LensflareElementShader",
  uniforms: {
    map: { value: null },
    occlusionMap: { value: null },
    color: { value: null },
    scale: { value: null },
    screenPosition: { value: null }
  },
  vertexShader: (
    /* glsl */
    `

		precision highp float;

		uniform vec3 screenPosition;
		uniform vec2 scale;

		uniform sampler2D occlusionMap;

		attribute vec3 position;
		attribute vec2 uv;

		varying vec2 vUV;
		varying float vVisibility;

		void main() {

			vUV = uv;

			vec2 pos = position.xy;

			vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );

			vVisibility =        visibility.r / 9.0;
			vVisibility *= 1.0 - visibility.g / 9.0;
			vVisibility *=       visibility.b / 9.0;

			gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		precision highp float;

		uniform sampler2D map;
		uniform vec3 color;

		varying vec2 vUV;
		varying float vVisibility;

		void main() {

			vec4 texture = texture2D( map, vUV );
			texture.a *= vVisibility;
			gl_FragColor = texture;
			gl_FragColor.rgb *= color;

		}`
  )
};
as.Geometry = function() {
  const o = new rt(), e = new Float32Array([
    -1,
    -1,
    0,
    0,
    0,
    1,
    -1,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    -1,
    1,
    0,
    0,
    1
  ]), t = new ur(e, 5);
  return o.setIndex([0, 1, 2, 0, 2, 3]), o.setAttribute("position", new Vt(t, 3, 0, !1)), o.setAttribute("uv", new Vt(t, 2, 3, !1)), o;
}();
function Fh(o) {
  return o;
}
function kh(o) {
  return o * o * o;
}
function Uh(o) {
  return o < 0.5 ? 4 * o * o * o : 1 - (-2 * o + 2) ** 3 / 2;
}
function Bh(o) {
  return o * o * o * o;
}
function Nh(o) {
  return o < 1 / 2.75 ? 7.5625 * o * o : o < 2 / 2.75 ? 7.5625 * (o -= 1.5 / 2.75) * o + 0.75 : o < 2.5 / 2.75 ? 7.5625 * (o -= 2.25 / 2.75) * o + 0.9375 : 7.5625 * (o -= 2.625 / 2.75) * o + 0.984375;
}
const qr = We.clamp;
class Qr {
  /**
   * Create a new seeded pseudorandom number generator.
   * @param [seed=0] - the seed for the generator
   * @param [getSeededRandomGenerator=getMulberry32] - a function that returns a pseudorandom number generator
   * @constructor
   */
  constructor(e = 0, t) {
    oe(this, "_getNext");
    oe(this, "_getGenerator");
    this._getGenerator = t ?? this.getMulberry32, this._getNext = this._getGenerator(e);
  }
  /**
   * Reseed the pseudorandom number generator
   */
  seed(e) {
    this._getNext = this._getGenerator(e);
  }
  /**
   * Return the next pseudorandom number in the interval [0, 1]
   */
  rand() {
    return this._getNext();
  }
  /**
   * Random float from <low, high> interval
   * @param low - Low value of the interval
   * @param high - High value of the interval
   */
  float(e, t) {
    return e + this._getNext() * (t - e);
  }
  /**
   * Random float from <-range/2, range/2> interval
   * @param range - Interval range
   */
  floatSpread(e) {
    return this.float(-0.5 * e, 0.5 * e);
  }
  /**
   * Random integer from <low, high> interval
   * @param low Low value of the interval
   * @param high High value of the interval
   */
  int(e, t) {
    return e + Math.floor(this._getNext() * (t - e + 1));
  }
  /**
   * Choose an element from an array.
   * @param array The array to choose from
   * @returns An element from the array or null if the array is empty
   */
  choice(e) {
    return e.length ? e[Math.floor(this._getNext() * e.length)] : null;
  }
  /**
   * Choose an element from an array or return defaultValue if array is empty.
   * @param array The array to choose from
   * @param defaultValue The value to return if the array is empty
   * @returns An element from the array or defaultValue if the array is empty
   */
  defaultChoice(e, t) {
    return e.length ? e[Math.floor(this._getNext() * e.length)] : t;
  }
  /**
   * Return n elements from an array.
   * @param array The array to sample
   * @param sampleSizeMin The minimum sample size
   * @param sampleSizeMax The maximum sample size
   */
  sample(e, t, n) {
    const s = e.length;
    t = qr(t, 0, s - 1), n = qr(n ?? s - 1, 0, s - 1);
    const i = this.int(t, n), r = this.shuffle(e.map((l, c) => c)), a = Math.min(e.length, i);
    return r.slice(0, a).sort().map((l) => e[l]);
  }
  /**
   * Shuffle an array. Not in-place.
   * @param array The array to shuffle
   */
  shuffle(e) {
    return e.map((t) => ({ value: t, sort: this._getNext() })).sort((t, n) => t.sort - n.sort).map(({ value: t }) => t);
  }
  /**
   * The default pseudorandom generator.
   */
  getMulberry32(e = 0) {
    return 0 < e && e < 1 && (e = Math.floor(e * 2 ** 16)), () => {
      e += 1831565813;
      let t = e;
      return t = Math.imul(t ^ t >>> 15, t | 1), t ^= t + Math.imul(t ^ t >>> 7, t | 61), ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }
}
const $t = "https://raw.githubusercontent.com/Tresjs/assets/93976c7d63ac83d4a254a41a10b2362bc17e90c9/textures/lensflare/", mr = `${$t}circle.png`, ei = `${$t}circleBlur.png`, zh = `${$t}circleRainbow.png`, Hh = `${$t}line.png`, Fa = `${$t}poly6.png`, ka = `${$t}polyStroke6.png`, Gh = `${$t}rays.png`, ti = `${$t}ring.png`, jh = `${$t}starThin6.png`, Vh = {
  texture: [Hh, ti],
  color: ["white"],
  distance: [0, 0],
  size: [750, 1024],
  length: [0, 2]
}, Yh = {
  texture: [ei],
  color: ["white"],
  distance: [0, 0],
  size: [180, 512],
  length: [1, 1]
}, Xh = {
  texture: [Gh],
  color: ["white"],
  distance: [0, 0],
  size: [180, 512],
  length: [1, 1]
}, Wh = {
  texture: [mr, zh, ti, jh],
  color: ["white"],
  distance: [0, 0],
  size: [180, 512],
  length: [2, 3]
}, [Ua, Ba] = [3679071, 132442], $h = {
  texture: [ei, mr, ti, Fa, ka],
  color: ["dimgray", "gray", "darkgray", Ua, Ba],
  distance: [0.5, 2.5],
  size: [20, 180],
  length: [5, 21]
}, Zh = {
  texture: [ei, mr, ti, Fa, ka],
  color: ["dimgray", "gray", "darkgray", Ua, Ba],
  distance: [-0.6, -0.1],
  size: [180, 360],
  length: [0, 5]
}, er = [Vh, Yh, Xh, Wh, $h, Zh], $s = {
  color: "white",
  distance: 0,
  size: 512,
  texture: ei
}, Jr = (o, e, t = void 0, n = void 0, s = $s) => {
  if (o !== void 0 && o.length > 0 && (typeof t == "number" || typeof n < "u")) {
    const a = to(t ?? 0, n ?? er), l = a.length, c = o.length;
    return l >= c ? a.map(
      (u, h) => Object.assign(u, e, h < c ? o[h] : {})
    ) : o.map(
      (u, h) => Object.assign({}, s, h < l ? a[h] : {}, e, u)
    );
  }
  if (o !== void 0 && o.length > 0) {
    const a = Object.assign({}, s, e);
    return o.map((l) => Object.assign({}, a, l));
  }
  const i = n === void 0 || n.length === 0 ? er : n;
  return to(t ?? 0, i).map((a) => Object.assign({}, a, e));
}, Kh = [
  Fh,
  kh,
  Uh,
  Bh,
  Nh
], eo = We.lerp, to = (o = 0, e = er) => {
  const n = new Qr(o).choice(Kh);
  return e.map((s, i) => {
    const r = new Qr(
      o * (i * 7907 + 1) + (typeof s.seed == "number" ? s.seed : 0)
    ), a = r.int(s.length[0], s.length[1]);
    return new Array(a).fill(0).map(() => {
      const l = n(r.rand());
      return {
        texture: r.defaultChoice(
          s.texture,
          $s.texture
        ),
        size: eo(s.size[0], s.size[1], n(1 - l)),
        distance: eo(s.distance[0], s.distance[1], l),
        color: r.defaultChoice(
          s.color,
          $s.color
        )
      };
    });
  }).flat();
};
function qh(o) {
  return Qh(o, (e, t) => t in $s && e !== void 0);
}
function Qh(o, e) {
  const t = {};
  return Object.keys(o).forEach((n) => {
    e(o[n], n) && (t[n] = o[n]);
  }), t;
}
const Nm = /* @__PURE__ */ pe({
  __name: "component",
  props: {
    scale: { default: 1 },
    elements: { default: void 0 },
    seed: { default: void 0 },
    seedProps: { default: void 0 },
    color: { default: void 0 },
    distance: { default: void 0 },
    size: { default: void 0 },
    texture: { default: void 0 }
  },
  setup(o, { expose: e }) {
    const t = o, n = xe(), s = xe([]), i = xe(qh(t));
    e({
      value: n
    });
    const r = new cr(), a = new as(), l = [], c = () => {
      var p, v, _;
      for (; l.length; )
        l.pop();
      (p = n.value) == null || p.children.forEach((y) => {
        "dispose" in y && y.dispose();
      }), (v = n.value) == null || v.remove(...n.value.children), (_ = n.value) == null || _.dispose();
    }, u = (p) => {
      if (typeof p.texture == "string") {
        const v = p.texture;
        p.texture = r.load(v), p.texture.name = v;
      }
      return p.color = ln(p.color), p;
    }, h = () => {
      for (; s.value.length > l.length; ) {
        const v = { ...u(s.value[l.length]) };
        l.push(v), a.addElement(v);
      }
      s.value.forEach((p, v) => {
        const _ = l[v], { texture: y, size: E, distance: R, color: T } = p;
        if (typeof y == "string") {
          if (_.texture.name !== y) {
            _.texture.dispose();
            const g = y;
            _.texture = r.load(g), _.texture.name = g;
          }
        } else
          _.texture !== y && (_.texture.dispose(), _.texture = y);
        _.size = E, _.distance = R, _.color = ln(T);
      }), m();
    }, m = () => {
      for (let p = s.value.length - 1; p < l.length; p++)
        l[p].size = 0;
      s.value.forEach((p, v) => {
        l[v].size = p.size * t.scale;
      });
    };
    return ot(() => {
      c();
    }), ds(() => {
      var p;
      (p = n.value) == null || p.add(a), s.value = Jr(t.elements, i.value, t.seed, t.seedProps);
    }), we(() => [t.color, t.distance, t.size, t.texture], () => {
      i.value = {
        color: t.color,
        distance: t.distance,
        size: t.size,
        texture: t.texture
      };
    }), we(() => [i.value, t.elements, t.seed, t.seedProps], () => {
      s.value = Jr(t.elements, i.value, t.seed, t.seedProps);
    }), we(() => t.scale, () => {
      m();
    }), we(() => s.value, () => {
      h();
    }), (p, v) => (fe(), de("TresGroup", {
      ref_key: "lensflareRef",
      ref: n
    }, null, 512));
  }
});
function Jh(o) {
  const e = ue(null), { height: t, width: n, settings: s, depth: i } = nc(o) ? Fe(o) : Fe(Xi(o)), { onLoop: r } = Ke(), { camera: a, renderer: l, scene: c, sizes: u } = je();
  return ft(() => {
    var h;
    (h = e.value) == null || h.dispose(), e.value = new bn((n == null ? void 0 : n.value) || u.width.value, (t == null ? void 0 : t.value) || u.height.value, {
      minFilter: At,
      magFilter: At,
      type: un,
      ...s == null ? void 0 : s.value
    }), i != null && i.value && (e.value.depthTexture = new sa(
      (n == null ? void 0 : n.value) || u.width.value,
      (t == null ? void 0 : t.value) || u.height.value,
      Gs
    ));
  }), r(() => {
    l.value.setRenderTarget(e.value), l.value.clear(), l.value.render(c.value, a.value), l.value.setRenderTarget(null);
  }), aa(() => {
    var h;
    (h = e.value) == null || h.dispose();
  }), e;
}
const zm = /* @__PURE__ */ pe({
  __name: "component",
  props: {
    width: {},
    height: {},
    depth: { type: Boolean, default: !1 },
    settings: { default: void 0 }
  },
  setup(o, { expose: e }) {
    const n = Jh(o);
    return e({
      value: n
    }), () => {
    };
  }
}), ef = (o, e = 16, t, n, s) => {
  const i = new Float32Array(e * 16), r = ue(new ur(i, 16));
  return (() => {
    if (!o)
      return;
    const l = new Yc(o);
    n && l.setWeightAttribute(n), l.build();
    const c = new ee(), u = new ee(), h = new Be(), m = new St();
    o.updateMatrixWorld(!0);
    for (let p = 0; p < e; p++)
      l.sample(c, u, h), typeof s == "function" ? s(
        {
          dummy: m,
          sampledMesh: o,
          position: c,
          normal: u,
          color: h
        },
        p
      ) : m.position.copy(c), m.updateMatrix(), t && t.setMatrixAt(p, m.matrix), m.matrix.toArray(r.value.array, p * 16);
    t && (t.instanceMatrix.needsUpdate = !0), r.value.needsUpdate = !0;
  })(), { buffer: r };
}, Hm = /* @__PURE__ */ pe({
  __name: "component",
  props: {
    transform: { type: Function },
    weight: {},
    count: {},
    mesh: {},
    instanceMesh: {}
  },
  setup(o, { expose: e }) {
    const t = o, n = ue(), s = ue(), i = ue();
    return ft(() => {
      var r, a;
      s.value = t.instanceMesh ?? ((r = n.value) == null ? void 0 : r.children.find((l) => l.hasOwnProperty("instanceMatrix"))), i.value = t.mesh ?? ((a = n.value) == null ? void 0 : a.children.find((l) => l.type === "Mesh")), ef(i.value, t.count, s.value, t.weight, t.transform);
    }), e({
      samplerRef: n
    }), (r, a) => (fe(), de("TresGroup", {
      ref_key: "samplerRef",
      ref: n
    }, [
      $e(r.$slots, "default")
    ], 512));
  }
}), Rs = {
  sunset: "venice/venice_sunset_1k.hdr",
  studio: "studio/poly_haven_studio_1k.hdr",
  city: "city/canary_wharf_1k.hdr",
  umbrellas: "outdoor/outdoor_umbrellas_1k.hdr",
  night: "outdoor/satara_night_1k.hdr",
  forest: "outood/mossy_forest_1k.hdr",
  snow: "outdoor/snowy_forest_path_01_1k.hdr",
  dawn: "kiara/kiara_1_dawn_1k.hdr",
  hangar: "indoor/small_hangar_01_1k.hdr",
  urban: "indoor/abandoned_games_room_02_1k.hdr",
  modern: "city/modern_buildings_2_1k.hdr",
  shangai: "city/shanghai_bund_1k.hdr"
}, tf = "https://raw.githubusercontent.com/Tresjs/assets/main/textures/hdr/";
async function nf(o) {
  const { scene: e } = je(), {
    preset: t,
    blur: n,
    files: s = [],
    path: i = "",
    background: r
  } = Fe(o), a = ue(), l = Ne(() => Array.isArray(s.value)), c = Ne(() => l.value ? Il : Zr), u = ue(null);
  return we(() => [s, i], async ([h, m]) => {
    if (h.value.length > 0 && !t.value) {
      try {
        u.value = await rs(
          z(c),
          l.value ? [z(h)] : z(h),
          (p) => {
            m.value && p.setPath(z(m));
          }
        );
      } catch (p) {
        throw new Error(`Failed to load environment map: ${p}`);
      }
      u.value && (a.value = l.value ? u.value[0] : u.value, a.value.mapping = l.value ? Dl : ji);
    }
  }, {
    immediate: !0
  }), we(() => a.value, (h) => {
    e.value && (e.value.environment = h);
  }, {
    immediate: !0
  }), we(() => [r.value, a.value], ([h, m]) => {
    e.value && (e.value.background = h ? m : void 0);
  }, {
    immediate: !0
  }), we(() => n == null ? void 0 : n.value, (h) => {
    e.value && (e.value.backgroundBlurriness = h);
  }, {
    immediate: !0
  }), we(t, async (h) => {
    if (h && h in Rs) {
      const m = tf, p = Rs[h];
      try {
        u.value = await rs(
          Zr,
          p,
          (v) => {
            m && v.setPath(m);
          }
        );
      } catch (v) {
        throw new Error(`Failed to load environment map: ${v}`);
      }
      u.value && (a.value = u.value, a.value.mapping = ji);
    } else if (h && !(h in Rs))
      throw new Error(`Preset must be one of: ${Object.keys(Rs).join(", ")}`);
  }, {
    immediate: !0
  }), { texture: a };
}
let Cs = null;
function sf(o, e) {
  return (t) => {
    e && e(t), o.draco && (Cs || (Cs = new hh()), Cs.setDecoderPath(o.decoderPath || "https://www.gstatic.com/draco/versioned/decoders/1.4.3/"), t.setDRACOLoader(Cs));
  };
}
async function rf(o, e = {
  draco: !1
}, t) {
  return await rs(
    ou,
    o,
    sf(e, t)
  );
}
const of = ["object"], Gm = /* @__PURE__ */ pe({
  __name: "component",
  props: {
    path: {},
    draco: { type: Boolean, default: !1 },
    decoderPath: { default: "https://www.gstatic.com/draco/versioned/decoders/1.4.1/" },
    castShadow: { type: Boolean, default: !1 },
    receiveShadow: { type: Boolean, default: !1 }
  },
  async setup(o, { expose: e }) {
    let t, n;
    const s = o, i = ue();
    e({
      value: i
    });
    const { scene: r } = ([t, n] = fs(() => rf(s.path, {
      draco: s.draco,
      decoderPath: s.decoderPath
    })), t = await t, n(), t);
    return (s.castShadow || s.receiveShadow) && r.traverse((a) => {
      a.isMesh && (a.castShadow = s.castShadow, a.receiveShadow = s.receiveShadow);
    }), (a, l) => (fe(), de("primitive", Ye({
      ref_key: "modelRef",
      ref: i,
      object: z(r)
    }, a.$attrs), null, 16, of));
  }
});
async function af(o) {
  return await rs($u, o);
}
const lf = ["object"], jm = /* @__PURE__ */ pe({
  __name: "component",
  props: {
    path: {},
    castShadow: { type: Boolean, default: !1 },
    receiveShadow: { type: Boolean, default: !1 }
  },
  async setup(o, { expose: e }) {
    let t, n;
    const s = o, i = ue();
    e({
      value: i
    });
    const r = ([t, n] = fs(() => af(s.path)), t = await t, n(), t);
    return (s.castShadow || s.receiveShadow) && r.traverse((a) => {
      a.isMesh && (a.castShadow = s.castShadow, a.receiveShadow = s.receiveShadow);
    }), (a, l) => (fe(), de("primitive", Ye({
      ref_key: "modelRef",
      ref: i,
      object: z(r)
    }, a.$attrs), null, 16, lf));
  }
}), cf = ["geometry", "render-order"], Vm = /* @__PURE__ */ pe({
  __name: "component",
  props: {
    src: {},
    skipStrokes: { type: Boolean, default: !1 },
    skipFills: { type: Boolean, default: !1 },
    fillMaterial: {},
    strokeMaterial: {},
    fillMeshProps: {},
    strokeMeshProps: {},
    depth: { default: "renderOrder" }
  },
  setup(o, { expose: e }) {
    const t = o, {
      src: n,
      skipStrokes: s,
      skipFills: i,
      fillMaterial: r,
      strokeMaterial: a,
      fillMeshProps: l,
      strokeMeshProps: c,
      depth: u
    } = Fe(t), h = xe(), m = xe([]), p = xe([]);
    e({ value: h }), ft(async () => v(n.value).then((E) => p.value = E.paths)), we([i, s, r, a, p], y);
    async function v(E) {
      const R = E.startsWith("<svg") ? encodeURI(`data:image/svg+xml;utf8,${E}`) : E;
      return rs(is, R);
    }
    ot(_);
    function _() {
      m.value.forEach((E) => E.geometry.dispose());
    }
    function y() {
      var A, x, M;
      _();
      const E = [], [R, T] = (() => {
        const d = { flat: !1, renderOrder: !1, offsetZ: !0 }, w = { flat: 0, renderOrder: 0, offsetZ: 0.025 }, f = u.value;
        return typeof f == "number" ? [!0, f] : [d[f], w[f]];
      })();
      let g = 0;
      for (const d of p.value) {
        const w = ((A = d.userData) == null ? void 0 : A.style) ?? {}, f = Object.assign(
          {
            color: w.fill,
            opacity: w.fillOpacity,
            transparent: !0,
            side: wn,
            depthWrite: R
          },
          t.fillMaterial
        );
        if (!i.value && w.fill !== void 0 && w.fill !== "none")
          for (const P of is.createShapes(d)) {
            const I = new Ll(P);
            I.scale(1, -1, 1), T && I.translate(0, 0, g++ * T), E.push({
              geometry: I,
              material: f,
              isStroke: !1
            });
          }
        if (!s.value && w.stroke !== void 0 && w.stroke !== "none") {
          const P = Object.assign(
            {
              color: (x = d.userData) == null ? void 0 : x.style.stroke,
              opacity: (M = d.userData) == null ? void 0 : M.style.strokeOpacity,
              transparent: !0,
              side: wn,
              depthWrite: R
            },
            t.strokeMaterial
          );
          for (const I of d.subPaths) {
            const K = I.getPoints().map((Z) => new le(Z.x, -Z.y)), N = is.pointsToStroke(K, w || "none");
            T && N.translate(0, 0, g++ * T), E.push({
              geometry: N,
              material: P,
              isStroke: !0
            });
          }
        }
      }
      m.value = E;
    }
    return (E, R) => (fe(), de("TresGroup", {
      ref_key: "svgRef",
      ref: h
    }, [
      (fe(!0), de(la, null, ca(m.value, ({ geometry: T, material: g, isStroke: A }, x) => (fe(), de("TresMesh", Ye({
        key: `${x}`
      }, A ? z(c) : z(l), {
        geometry: T,
        "render-order": z(u) === "renderOrder" ? x : 0
      }), [
        Te("TresMeshBasicMaterial", ua(ha(g)), null, 16)
      ], 16, cf))), 128))
    ], 512));
  }
}), no = "[TresJS - Cientos ▲ ■ ♥] ";
function gr() {
  function o(n, s) {
    console.error(`${no} ${n}`, s || "");
  }
  function e(n) {
    console.warn(`${no} ${n}`);
  }
  function t(n, s) {
  }
  return {
    logError: o,
    logWarning: e,
    logMessage: t
  };
}
let wi = 0;
function Ym() {
  const o = ue(!1), e = ue(0), t = ue([]), { logError: n } = gr();
  return new Promise((s) => {
    Ts.onStart = () => {
      o.value = !1;
    }, Ts.onLoad = () => {
      o.value = !0;
    }, Ts.onProgress = (i, r, a) => {
      r === a && (wi = a, o.value = !0, t.value.push(i)), e.value = Math.round((r - wi) / (a - wi) * 100 || 100, 2);
    }, Ts.onError = (i) => {
      n("Error loading assets", new Error(i)), o.value = !0;
    }, s({
      items: t,
      hasFinishLoading: o,
      progress: e
    });
  });
}
async function Xm(o, e) {
  const { logError: t } = gr();
  if (!o)
    return t("Error no path provided");
  const { unsuspend: n, start: s, crossOrigin: i, muted: r, loop: a, ...l } = {
    unsuspend: "loadedmetadata",
    crossOrigin: "Anonymous",
    muted: !0,
    loop: !0,
    start: !0,
    playsInline: !0,
    ...e
  };
  function c() {
    return new Promise((u, h) => {
      const m = Object.assign(document.createElement("video"), {
        src: typeof o == "string" && o || void 0,
        crossOrigin: i,
        loop: a,
        muted: r,
        autoplay: !0,
        ...l
      }), p = new Ol(m);
      return m.addEventListener(n, () => u(p)), m.addEventListener("error", () => h()), p;
    });
  }
  try {
    const u = await c();
    return s && u.image && u.image.play(), u;
  } catch {
    t("Error loading resource");
  }
}
const uf = ["target", "auto-rotate", "auto-rotate-speed", "enable-damping", "damping-factor", "enable-pan", "key-pan-speed", "keys", "max-azimuth-angle", "min-azimuth-angle", "max-polar-angle", "min-polar-angle", "min-distance", "max-distance", "min-zoom", "max-zoom", "touches", "enable-zoom", "zoom-speed", "enable-rotate", "rotate-speed", "args"], Wm = /* @__PURE__ */ pe({
  __name: "OrbitControls",
  props: {
    makeDefault: { type: Boolean, default: !1 },
    camera: {},
    domElement: {},
    target: { default: () => [0, 0, 0] },
    enableDamping: { type: Boolean, default: !0 },
    dampingFactor: { default: 0.05 },
    autoRotate: { type: Boolean, default: !1 },
    autoRotateSpeed: { default: 2 },
    enablePan: { type: Boolean, default: !0 },
    keyPanSpeed: { default: 7 },
    keys: {},
    maxAzimuthAngle: { default: 1 / 0 },
    minAzimuthAngle: { default: -1 / 0 },
    maxPolarAngle: { default: Math.PI },
    minPolarAngle: { default: 0 },
    minDistance: { default: 0 },
    maxDistance: { default: 1 / 0 },
    minZoom: { default: 0 },
    maxZoom: { default: 1 / 0 },
    touches: { default: () => ({ ONE: Lt.ROTATE, TWO: Lt.DOLLY_PAN }) },
    enableZoom: { type: Boolean, default: !0 },
    zoomSpeed: { default: 1 },
    enableRotate: { type: Boolean, default: !0 },
    rotateSpeed: { default: 1 }
  },
  emits: ["change", "start", "end"],
  setup(o, { expose: e, emit: t }) {
    const n = o, s = t, {
      makeDefault: i,
      autoRotate: r,
      autoRotateSpeed: a,
      enableDamping: l,
      dampingFactor: c,
      enablePan: u,
      keyPanSpeed: h,
      maxAzimuthAngle: m,
      minAzimuthAngle: p,
      maxPolarAngle: v,
      minPolarAngle: _,
      minDistance: y,
      maxDistance: E,
      minZoom: R,
      maxZoom: T,
      enableZoom: g,
      zoomSpeed: A,
      enableRotate: x,
      touches: M,
      rotateSpeed: d,
      target: w
    } = Fe(n), { camera: f, renderer: P, extend: I, controls: K } = je(), N = ue(null);
    I({ OrbitControls: wa }), we(N, (X) => {
      Z(), X && i.value ? K.value = X : K.value = null;
    });
    function Z() {
      Ve(N.value, "change", () => s("change", N.value)), Ve(N.value, "start", () => s("start", N.value)), Ve(N.value, "end", () => s("end", N.value));
    }
    const { onLoop: W } = Ke();
    return W(() => {
      N.value && (l.value || r.value) && N.value.update();
    }), ot(() => {
      N.value && N.value.dispose();
    }), e({ value: N }), (X, V) => (X.camera || z(f)) && (X.domElement || z(P)) ? (fe(), de("TresOrbitControls", {
      key: 0,
      ref_key: "controlsRef",
      ref: N,
      target: z(w),
      "auto-rotate": z(r),
      "auto-rotate-speed": z(a),
      "enable-damping": z(l),
      "damping-factor": z(c),
      "enable-pan": z(u),
      "key-pan-speed": z(h),
      keys: X.keys,
      "max-azimuth-angle": z(m),
      "min-azimuth-angle": z(p),
      "max-polar-angle": z(v),
      "min-polar-angle": z(_),
      "min-distance": z(y),
      "max-distance": z(E),
      "min-zoom": z(R),
      "max-zoom": z(T),
      touches: z(M),
      "enable-zoom": z(g),
      "zoom-speed": z(A),
      "enable-rotate": z(x),
      "rotate-speed": z(d),
      args: [X.camera || z(f), X.domElement || z(P).domElement]
    }, null, 8, uf)) : Wt("", !0);
  }
}), hf = 5, ff = 6, df = 0.3, $m = /* @__PURE__ */ pe({
  __name: "KeyboardControls",
  props: {
    forward: { default: () => ["w", "W"] },
    back: { default: () => ["s", "S"] },
    left: { default: () => ["a", "A"] },
    right: { default: () => ["d", "D"] },
    jump: { default: () => [" "] },
    gravity: { default: 9.8 },
    moveSpeed: { default: 0.1 },
    headBobbing: { type: Boolean, default: !1 },
    is2D: { type: Boolean, default: !1 }
  },
  setup(o) {
    var f;
    const e = o, { forward: t, back: n, left: s, right: i, jump: r, gravity: a, moveSpeed: l, headBobbing: c, is2D: u } = Fe(e), { camera: h, controls: m } = je(), p = ue(0), v = ue(0), _ = ue(!1), y = ue(!1), E = ue(0), R = xe(), T = u.value ? "y" : "z", g = ((f = h.value.position) == null ? void 0 : f.y) || 0;
    mn(
      t.value,
      () => {
        _.value = !0, v.value = l.value;
      },
      { eventName: "keydown" }
    ), mn(
      n.value,
      () => {
        _.value = !0, v.value = -l.value;
      },
      { eventName: "keydown" }
    ), mn(
      [...t.value, ...n.value],
      () => {
        _.value = !1, v.value = 0;
      },
      { eventName: "keyup" }
    ), mn(
      s.value,
      () => {
        _.value = !0, p.value = -l.value;
      },
      { eventName: "keydown" }
    ), mn(
      i.value,
      () => {
        _.value = !0, p.value = l.value;
      },
      { eventName: "keydown" }
    ), mn(
      [...s.value, ...i.value],
      () => {
        _.value = !1, p.value = 0;
      },
      { eventName: "keyup" }
    ), mn(r.value, () => {
      y.value || (E.value = Date.now()), y.value = !0;
    });
    const A = (P) => _.value ? Math.sin(P * hf) * df + g : g, x = () => (Date.now() - E.value) / 1e3 * 3, M = (P) => g + ff * P - 0.5 * a.value * P ** 2, d = () => {
      if (y.value) {
        const P = M(x());
        return P <= g && (y.value = !1), P;
      }
      return 0;
    }, { onLoop: w } = Ke();
    return w(({ elapsed: P }) => {
      var I;
      m.value instanceof qi && ((I = m.value) != null && I.isLocked) ? (m.value.moveForward(v.value), m.value.moveRight(p.value), h.value.position && (h.value.position.y = c.value ? A(P) : g, h.value.position.y += d())) : R.value.children.length > 0 && !(m.value instanceof qi) && (R.value.position.x += p.value, R.value.position[T] += u.value ? v.value : -v.value);
    }), (P, I) => (fe(), de("TresGroup", {
      ref_key: "wrapperRef",
      ref: R
    }, [
      $e(P.$slots, "default")
    ], 512));
  }
}), pf = ["object", "args", "mode", "enabled", "axis", "translation-snap", "rotation-snap", "scale-snap", "space", "size", "show-x", "show-y", "show-z"], Zm = /* @__PURE__ */ pe({
  __name: "TransformControls",
  props: {
    object: {},
    mode: { default: "translate" },
    enabled: { type: Boolean, default: !0 },
    axis: { default: "XYZ" },
    translationSnap: {},
    rotationSnap: {},
    scaleSnap: {},
    space: { default: "world" },
    size: { default: 1 },
    showX: { type: Boolean, default: !0 },
    showY: { type: Boolean, default: !0 },
    showZ: { type: Boolean, default: !0 }
  },
  emits: ["dragging", "change", "mouseDown", "mouseUp", "objectChange"],
  setup(o, { emit: e }) {
    const t = o, n = e, { object: s, mode: i, enabled: r, axis: a, translationSnap: l, rotationSnap: c, scaleSnap: u, space: h, size: m, showX: p, showY: v, showZ: _ } = Fe(t), y = xe(), { controls: E, camera: R, renderer: T, extend: g } = je();
    g({ TransformControls: $c });
    const A = (M) => {
      E.value && (E.value.enabled = !M.value), n("dragging", M.value);
    };
    function x() {
      Ve(y.value, "change", () => n("change")), Ve(y.value, "dragging-changed", A), Ve(y.value, "mouseDown", () => n("mouseDown")), Ve(y.value, "mouseUp", () => n("mouseUp")), Ve(y.value, "objectChange", () => n("objectChange"));
    }
    return ft(() => {
      y.value && x();
    }), ot(() => {
      y.value && y.value.dispose();
    }), (M, d) => z(R) && z(T) ? (fe(), de("TresTransformControls", {
      key: 0,
      ref_key: "controlsRef",
      ref: y,
      object: z(s),
      args: [z(R), z(T).domElement],
      mode: z(i),
      enabled: z(r),
      axis: z(a),
      "translation-snap": z(l),
      "rotation-snap": z(c),
      "scale-snap": z(u),
      space: z(h),
      size: z(m),
      "show-x": z(p),
      "show-y": z(v),
      "show-z": z(_),
      visible: !0
    }, null, 8, pf)) : Wt("", !0);
  }
}), mf = ["args"], Km = /* @__PURE__ */ pe({
  __name: "PointerLockControls",
  props: {
    makeDefault: { type: Boolean, default: !1 },
    camera: {},
    domElement: {},
    selector: {}
  },
  emits: ["isLock", "change"],
  setup(o, { expose: e, emit: t }) {
    const n = o, s = t, { camera: i, renderer: r, extend: a, controls: l } = je(), c = ue(null);
    let u;
    a({ PointerLockControls: qi });
    const h = (m) => {
      s("isLock", m);
    };
    return we(c, (m) => {
      m && n.makeDefault ? l.value = m : l.value = null;
      const p = document.getElementById(n.selector || "");
      u = p || r.value.domElement, Ve(l.value, "change", () => s("change", l.value)), Ve(u, "click", () => {
        var v, _, y;
        (v = l.value) == null || v.lock(), (_ = l.value) == null || _.addEventListener("lock", () => h(!0)), (y = l.value) == null || y.addEventListener("unlock", () => h(!1));
      });
    }), ot(() => {
      var m, p;
      (m = l.value) == null || m.removeEventListener("lock", () => h(!0)), (p = l.value) == null || p.removeEventListener("unlock", () => h(!1)), c.value && c.value.dispose();
    }), e({
      value: l
    }), (m, p) => (m.camera || z(i)) && (m.domElement || z(r)) ? (fe(), de("TresPointerLockControls", {
      key: 0,
      ref_key: "controlsRef",
      ref: c,
      args: [m.camera || z(i), m.domElement || z(r).domElement]
    }, null, 8, mf)) : Wt("", !0);
  }
}), gf = ["args"], qm = /* @__PURE__ */ pe({
  __name: "MapControls",
  props: {
    makeDefault: { type: Boolean, default: !1 },
    camera: {},
    domElement: {}
  },
  setup(o) {
    const e = o, { camera: t, renderer: n, extend: s, controls: i } = je(), r = ue(null);
    return s({ MapControls: ru }), we(i, (a) => {
      a && e.makeDefault ? i.value = a : i.value = null;
    }), ot(() => {
      r.value && r.value.dispose();
    }), (a, l) => (a.camera || z(t)) && (a.domElement || z(n)) ? (fe(), de("TresMapControls", {
      key: 0,
      ref_key: "controlsRef",
      ref: r,
      args: [a.camera || z(t), a.domElement || z(n).domElement]
    }, null, 8, gf)) : Wt("", !0);
  }
}), Qm = /* @__PURE__ */ pe({
  __name: "ScrollControls",
  props: {
    pages: { default: 4 },
    distance: { default: 4 },
    smoothScroll: { default: 0.1 },
    horizontal: { type: Boolean, default: !1 },
    htmlScroll: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(o, { emit: e }) {
    const t = o, n = e, { logWarning: s } = ps();
    t.smoothScroll < 0 && s("SmoothControl must be greater than zero"), t.pages < 0 && s("Pages must be greater than zero");
    const { camera: i, controls: r, renderer: a } = je(), l = xe(), c = document.createElement("div"), { y: u } = Oh(), { x: h, y: m, isScrolling: p } = Ih(c), { height: v, width: _ } = La();
    let y = 0;
    const E = ue(!1), R = ue(0), T = ue(0), g = ue(0), A = t.horizontal ? "x" : "y", x = we(
      i,
      (d) => {
        if (E.value) {
          x();
          return;
        }
        y = t.horizontal ? (d == null ? void 0 : d.position.x) || 0 : (d == null ? void 0 : d.position.y) || 0, E.value = !0;
      },
      {
        immediate: !0
      }
    );
    we(
      p,
      (d) => {
        r.value && (r.value.enabled = !d);
      },
      {
        immediate: !0
      }
    ), we(u, (d) => {
      !p.value && !t.htmlScroll || (T.value = d / v.value / (g.value / v.value - 1), R.value = -1 * T.value, n("update:modelValue", T.value));
    }), we(m, (d) => {
      T.value = d / v.value / (g.value / v.value), R.value = -1 * T.value, n("update:modelValue", T.value);
    }), we(h, (d) => {
      T.value = d / _.value / (g.value / _.value - 1), R.value = +T.value, n("update:modelValue", T.value);
    }), we(
      a,
      (d) => {
        var f, P;
        const w = d == null ? void 0 : d.domElement;
        if (t.htmlScroll && (d != null && d.domElement))
          w != null && w.style.width && (w != null && w.style.position) && (w != null && w.style.top) && (w != null && w.style.left) && (w.style.width = "100%", w.style.position = "fixed", w.style.zIndex = " -99999", w.style.top = "0", w.style.left = "0"), g.value = document.body.scrollHeight;
        else {
          const I = document.createElement("div"), K = document.createElement("div");
          c.style[t.horizontal ? "overflowX" : "overflowY"] = "auto", c.style[t.horizontal ? "overflowY" : "overflowX"] = "hidden", c.style.position = "absolute", c.style.width = "100%", c.style.height = " 100%", c.style.top = "0", c.style.left = "0", c.classList.add("scrollContainer"), I.style.position = "sticky", I.style.top = "0px", I.style.left = "0px", I.style.width = "100%", I.style.height = "100%", I.style.overflow = "hidden", c.appendChild(I), K.style.height = t.horizontal ? "100%" : `${v.value * t.pages}px`, K.style.width = t.horizontal ? `${_.value * t.pages}px` : "100vw", K.style.pointerEvents = "none", w.style.position = "fixed", w.style.zIndex = "0", w != null && w.style.width && (w.style.width = "100%"), c.appendChild(K), d.domElement.parentNode.style.position = "relative", (P = (f = d == null ? void 0 : d.domElement) == null ? void 0 : f.parentNode) == null || P.appendChild(c), g.value = t.horizontal ? _.value * t.pages : v.value * t.pages;
        }
      },
      {
        immediate: !0
      }
    );
    const { onLoop: M } = Ke();
    return M(() => {
      var d;
      if ((d = i.value) != null && d.position) {
        const w = (R.value * t.distance - i.value.position[A] + y) * t.smoothScroll;
        i.value.position[A] += w, l.value.children.length > 0 && (l.value.position[A] += w);
      }
    }), (d, w) => (fe(), de("TresGroup", {
      ref_key: "wrapperRef",
      ref: l
    }, [
      $e(d.$slots, "default")
    ], 512));
  }
});
/*!
 * camera-controls
 * https://github.com/yomotsu/camera-controls
 * (c) 2017 @yomotsu
 * Released under the MIT License.
 */
const ye = {
  LEFT: 1,
  RIGHT: 2,
  MIDDLE: 4
}, Q = Object.freeze({
  NONE: 0,
  ROTATE: 1,
  TRUCK: 2,
  OFFSET: 4,
  DOLLY: 8,
  ZOOM: 16,
  TOUCH_ROTATE: 32,
  TOUCH_TRUCK: 64,
  TOUCH_OFFSET: 128,
  TOUCH_DOLLY: 256,
  TOUCH_ZOOM: 512,
  TOUCH_DOLLY_TRUCK: 1024,
  TOUCH_DOLLY_OFFSET: 2048,
  TOUCH_DOLLY_ROTATE: 4096,
  TOUCH_ZOOM_TRUCK: 8192,
  TOUCH_ZOOM_OFFSET: 16384,
  TOUCH_ZOOM_ROTATE: 32768
}), Dn = {
  NONE: 0,
  IN: 1,
  OUT: -1
};
function gn(o) {
  return o.isPerspectiveCamera;
}
function sn(o) {
  return o.isOrthographicCamera;
}
const Ln = Math.PI * 2, so = Math.PI / 2, Na = 1e-5, $n = Math.PI / 180;
function Et(o, e, t) {
  return Math.max(e, Math.min(t, o));
}
function ze(o, e = Na) {
  return Math.abs(o) < e;
}
function ke(o, e, t = Na) {
  return ze(o - e, t);
}
function io(o, e) {
  return Math.round(o / e) * e;
}
function Zn(o) {
  return isFinite(o) ? o : o < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
}
function Kn(o) {
  return Math.abs(o) < Number.MAX_VALUE ? o : o * (1 / 0);
}
function Is(o, e, t, n, s = 1 / 0, i) {
  n = Math.max(1e-4, n);
  const r = 2 / n, a = r * i, l = 1 / (1 + a + 0.48 * a * a + 0.235 * a * a * a);
  let c = o - e;
  const u = e, h = s * n;
  c = Et(c, -h, h), e = o - c;
  const m = (t.value + r * c) * i;
  t.value = (t.value - r * m) * l;
  let p = e + (c + m) * l;
  return u - o > 0 == p > u && (p = u, t.value = (p - u) / i), p;
}
function ro(o, e, t, n, s = 1 / 0, i, r) {
  n = Math.max(1e-4, n);
  const a = 2 / n, l = a * i, c = 1 / (1 + l + 0.48 * l * l + 0.235 * l * l * l);
  let u = e.x, h = e.y, m = e.z, p = o.x - u, v = o.y - h, _ = o.z - m;
  const y = u, E = h, R = m, T = s * n, g = T * T, A = p * p + v * v + _ * _;
  if (A > g) {
    const Z = Math.sqrt(A);
    p = p / Z * T, v = v / Z * T, _ = _ / Z * T;
  }
  u = o.x - p, h = o.y - v, m = o.z - _;
  const x = (t.x + a * p) * i, M = (t.y + a * v) * i, d = (t.z + a * _) * i;
  t.x = (t.x - a * x) * c, t.y = (t.y - a * M) * c, t.z = (t.z - a * d) * c, r.x = u + (p + x) * c, r.y = h + (v + M) * c, r.z = m + (_ + d) * c;
  const w = y - o.x, f = E - o.y, P = R - o.z, I = r.x - y, K = r.y - E, N = r.z - R;
  return w * I + f * K + P * N > 0 && (r.x = y, r.y = E, r.z = R, t.x = (r.x - y) / i, t.y = (r.y - E) / i, t.z = (r.z - R) / i), r;
}
function Ti(o, e) {
  e.set(0, 0), o.forEach((t) => {
    e.x += t.clientX, e.y += t.clientY;
  }), e.x /= o.length, e.y /= o.length;
}
function bi(o, e) {
  return sn(o) ? (console.warn(`${e} is not supported in OrthographicCamera`), !0) : !1;
}
class yf {
  constructor() {
    this._listeners = {};
  }
  /**
   * Adds the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(e, t) {
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  /**
   * Presence of the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  hasEventListener(e, t) {
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  /**
   * Removes the specified event listener
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(e, t) {
    const s = this._listeners[e];
    if (s !== void 0) {
      const i = s.indexOf(t);
      i !== -1 && s.splice(i, 1);
    }
  }
  /**
   * Removes all event listeners
   * @param type event name
   * @category Methods
   */
  removeAllEventListeners(e) {
    if (!e) {
      this._listeners = {};
      return;
    }
    Array.isArray(this._listeners[e]) && (this._listeners[e].length = 0);
  }
  /**
   * Fire an event type.
   * @param event DispatcherEvent
   * @category Methods
   */
  dispatchEvent(e) {
    const n = this._listeners[e.type];
    if (n !== void 0) {
      e.target = this;
      const s = n.slice(0);
      for (let i = 0, r = s.length; i < r; i++)
        s[i].call(this, e);
    }
  }
}
const vf = "2.7.4", Ds = 1 / 8, za = typeof window < "u", _f = za && /Mac/.test(navigator.platform), xf = !(za && "PointerEvent" in window);
let me, oo, Ls, Ei, at, Ee, Le, On, qn, Pt, Rt, yn, ao, lo, yt, Qn, Fn, co, Mi, uo, Si, Ai, Os;
class ls extends yf {
  /**
       * Injects THREE as the dependency. You can then proceed to use CameraControls.
       *
       * e.g
       * ```javascript
       * CameraControls.install( { THREE: THREE } );
       * ```
       *
       * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.
       *
       * ```js
       * import {
       * 	Vector2,
       * 	Vector3,
       * 	Vector4,
       * 	Quaternion,
       * 	Matrix4,
       * 	Spherical,
       * 	Box3,
       * 	Sphere,
       * 	Raycaster,
       * 	MathUtils,
       * } from 'three';
       *
       * const subsetOfTHREE = {
       * 	Vector2   : Vector2,
       * 	Vector3   : Vector3,
       * 	Vector4   : Vector4,
       * 	Quaternion: Quaternion,
       * 	Matrix4   : Matrix4,
       * 	Spherical : Spherical,
       * 	Box3      : Box3,
       * 	Sphere    : Sphere,
       * 	Raycaster : Raycaster,
       * };
  
       * CameraControls.install( { THREE: subsetOfTHREE } );
       * ```
       * @category Statics
       */
  static install(e) {
    me = e.THREE, oo = Object.freeze(new me.Vector3(0, 0, 0)), Ls = Object.freeze(new me.Vector3(0, 1, 0)), Ei = Object.freeze(new me.Vector3(0, 0, 1)), at = new me.Vector2(), Ee = new me.Vector3(), Le = new me.Vector3(), On = new me.Vector3(), qn = new me.Vector3(), Pt = new me.Vector3(), Rt = new me.Vector3(), yn = new me.Vector3(), ao = new me.Vector3(), lo = new me.Vector3(), yt = new me.Spherical(), Qn = new me.Spherical(), Fn = new me.Box3(), co = new me.Box3(), Mi = new me.Sphere(), uo = new me.Quaternion(), Si = new me.Quaternion(), Ai = new me.Matrix4(), Os = new me.Raycaster();
  }
  /**
   * list all ACTIONs
   * @category Statics
   */
  static get ACTION() {
    return Q;
  }
  /**
   * Creates a `CameraControls` instance.
   *
   * Note:
   * You **must install** three.js before using camera-controls. see [#install](#install)
   * Not doing so will lead to runtime errors (`undefined` references to THREE).
   *
   * e.g.
   * ```
   * CameraControls.install( { THREE } );
   * const cameraControls = new CameraControls( camera, domElement );
   * ```
   *
   * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.
   * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
   * @category Constructor
   */
  constructor(e, t) {
    super(), this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.minDistance = Number.EPSILON, this.maxDistance = 1 / 0, this.infinityDolly = !1, this.minZoom = 0.01, this.maxZoom = 1 / 0, this.smoothTime = 0.25, this.draggingSmoothTime = 0.125, this.maxSpeed = 1 / 0, this.azimuthRotateSpeed = 1, this.polarRotateSpeed = 1, this.dollySpeed = 1, this.dollyDragInverted = !1, this.truckSpeed = 2, this.dollyToCursor = !1, this.dragToOffset = !1, this.verticalDragToForward = !1, this.boundaryFriction = 0, this.restThreshold = 0.01, this.colliderMeshes = [], this.cancel = () => {
    }, this._enabled = !0, this._state = Q.NONE, this._viewport = null, this._changedDolly = 0, this._changedZoom = 0, this._hasRested = !0, this._boundaryEnclosesCamera = !1, this._needsUpdate = !0, this._updatedLastTime = !1, this._elementRect = new DOMRect(), this._isDragging = !1, this._dragNeedsUpdate = !0, this._activePointers = [], this._lockedPointer = null, this._interactiveArea = new DOMRect(0, 0, 1, 1), this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._isUserControllingOffset = !1, this._isUserControllingZoom = !1, this._lastDollyDirection = Dn.NONE, this._thetaVelocity = { value: 0 }, this._phiVelocity = { value: 0 }, this._radiusVelocity = { value: 0 }, this._targetVelocity = new me.Vector3(), this._focalOffsetVelocity = new me.Vector3(), this._zoomVelocity = { value: 0 }, this._truckInternal = (g, A, x) => {
      let M, d;
      if (gn(this._camera)) {
        const w = Ee.copy(this._camera.position).sub(this._target), f = this._camera.getEffectiveFOV() * $n, P = w.length() * Math.tan(f * 0.5);
        M = this.truckSpeed * g * P / this._elementRect.height, d = this.truckSpeed * A * P / this._elementRect.height;
      } else if (sn(this._camera)) {
        const w = this._camera;
        M = g * (w.right - w.left) / w.zoom / this._elementRect.width, d = A * (w.top - w.bottom) / w.zoom / this._elementRect.height;
      } else
        return;
      this.verticalDragToForward ? (x ? this.setFocalOffset(this._focalOffsetEnd.x + M, this._focalOffsetEnd.y, this._focalOffsetEnd.z, !0) : this.truck(M, 0, !0), this.forward(-d, !0)) : x ? this.setFocalOffset(this._focalOffsetEnd.x + M, this._focalOffsetEnd.y + d, this._focalOffsetEnd.z, !0) : this.truck(M, d, !0);
    }, this._rotateInternal = (g, A) => {
      const x = Ln * this.azimuthRotateSpeed * g / this._elementRect.height, M = Ln * this.polarRotateSpeed * A / this._elementRect.height;
      this.rotate(x, M, !0);
    }, this._dollyInternal = (g, A, x) => {
      const M = Math.pow(0.95, -g * this.dollySpeed), d = this._sphericalEnd.radius, w = this._sphericalEnd.radius * M, f = Et(w, this.minDistance, this.maxDistance), P = f - w;
      this.infinityDolly && this.dollyToCursor ? this._dollyToNoClamp(w, !0) : this.infinityDolly && !this.dollyToCursor ? (this.dollyInFixed(P, !0), this._dollyToNoClamp(f, !0)) : this._dollyToNoClamp(f, !0), this.dollyToCursor && (this._changedDolly += (this.infinityDolly ? w : f) - d, this._dollyControlCoord.set(A, x)), this._lastDollyDirection = Math.sign(-g);
    }, this._zoomInternal = (g, A, x) => {
      const M = Math.pow(0.95, g * this.dollySpeed), d = this._zoom, w = this._zoom * M;
      this.zoomTo(w, !0), this.dollyToCursor && (this._changedZoom += w - d, this._dollyControlCoord.set(A, x));
    }, typeof me > "u" && console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."), this._camera = e, this._yAxisUpSpace = new me.Quaternion().setFromUnitVectors(this._camera.up, Ls), this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert(), this._state = Q.NONE, this._target = new me.Vector3(), this._targetEnd = this._target.clone(), this._focalOffset = new me.Vector3(), this._focalOffsetEnd = this._focalOffset.clone(), this._spherical = new me.Spherical().setFromVector3(Ee.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)), this._sphericalEnd = this._spherical.clone(), this._lastDistance = this._spherical.radius, this._zoom = this._camera.zoom, this._zoomEnd = this._zoom, this._lastZoom = this._zoom, this._nearPlaneCorners = [
      new me.Vector3(),
      new me.Vector3(),
      new me.Vector3(),
      new me.Vector3()
    ], this._updateNearPlaneCorners(), this._boundary = new me.Box3(new me.Vector3(-1 / 0, -1 / 0, -1 / 0), new me.Vector3(1 / 0, 1 / 0, 1 / 0)), this._cameraUp0 = this._camera.up.clone(), this._target0 = this._target.clone(), this._position0 = this._camera.position.clone(), this._zoom0 = this._zoom, this._focalOffset0 = this._focalOffset.clone(), this._dollyControlCoord = new me.Vector2(), this.mouseButtons = {
      left: Q.ROTATE,
      middle: Q.DOLLY,
      right: Q.TRUCK,
      wheel: gn(this._camera) ? Q.DOLLY : sn(this._camera) ? Q.ZOOM : Q.NONE
    }, this.touches = {
      one: Q.TOUCH_ROTATE,
      two: gn(this._camera) ? Q.TOUCH_DOLLY_TRUCK : sn(this._camera) ? Q.TOUCH_ZOOM_TRUCK : Q.NONE,
      three: Q.TOUCH_TRUCK
    };
    const n = new me.Vector2(), s = new me.Vector2(), i = new me.Vector2(), r = (g) => {
      if (!this._enabled || !this._domElement)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const M = this._domElement.getBoundingClientRect(), d = g.clientX / M.width, w = g.clientY / M.height;
        if (d < this._interactiveArea.left || d > this._interactiveArea.right || w < this._interactiveArea.top || w > this._interactiveArea.bottom)
          return;
      }
      const A = g.pointerType !== "mouse" ? null : (g.buttons & ye.LEFT) === ye.LEFT ? ye.LEFT : (g.buttons & ye.MIDDLE) === ye.MIDDLE ? ye.MIDDLE : (g.buttons & ye.RIGHT) === ye.RIGHT ? ye.RIGHT : null;
      if (A !== null) {
        const M = this._findPointerByMouseButton(A);
        M && this._disposePointer(M);
      }
      if ((g.buttons & ye.LEFT) === ye.LEFT && this._lockedPointer)
        return;
      const x = {
        pointerId: g.pointerId,
        clientX: g.clientX,
        clientY: g.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: A
      };
      this._activePointers.push(x), this._domElement.ownerDocument.removeEventListener("pointermove", l, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", u), this._domElement.ownerDocument.addEventListener("pointermove", l, { passive: !1 }), this._domElement.ownerDocument.addEventListener("pointerup", u), this._isDragging = !0, _(g);
    }, a = (g) => {
      if (!this._enabled || !this._domElement || this._lockedPointer)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const M = this._domElement.getBoundingClientRect(), d = g.clientX / M.width, w = g.clientY / M.height;
        if (d < this._interactiveArea.left || d > this._interactiveArea.right || w < this._interactiveArea.top || w > this._interactiveArea.bottom)
          return;
      }
      const A = (g.buttons & ye.LEFT) === ye.LEFT ? ye.LEFT : (g.buttons & ye.MIDDLE) === ye.MIDDLE ? ye.MIDDLE : (g.buttons & ye.RIGHT) === ye.RIGHT ? ye.RIGHT : null;
      if (A !== null) {
        const M = this._findPointerByMouseButton(A);
        M && this._disposePointer(M);
      }
      const x = {
        pointerId: 1,
        clientX: g.clientX,
        clientY: g.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: (g.buttons & ye.LEFT) === ye.LEFT ? ye.LEFT : (g.buttons & ye.MIDDLE) === ye.LEFT ? ye.MIDDLE : (g.buttons & ye.RIGHT) === ye.LEFT ? ye.RIGHT : null
      };
      this._activePointers.push(x), this._domElement.ownerDocument.removeEventListener("mousemove", c), this._domElement.ownerDocument.removeEventListener("mouseup", h), this._domElement.ownerDocument.addEventListener("mousemove", c), this._domElement.ownerDocument.addEventListener("mouseup", h), this._isDragging = !0, _(g);
    }, l = (g) => {
      g.cancelable && g.preventDefault();
      const A = g.pointerId, x = this._lockedPointer || this._findPointerById(A);
      if (x) {
        if (x.clientX = g.clientX, x.clientY = g.clientY, x.deltaX = g.movementX, x.deltaY = g.movementY, this._state = 0, g.pointerType === "touch")
          switch (this._activePointers.length) {
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          (!this._isDragging && this._lockedPointer || this._isDragging && (g.buttons & ye.LEFT) === ye.LEFT) && (this._state = this._state | this.mouseButtons.left), this._isDragging && (g.buttons & ye.MIDDLE) === ye.MIDDLE && (this._state = this._state | this.mouseButtons.middle), this._isDragging && (g.buttons & ye.RIGHT) === ye.RIGHT && (this._state = this._state | this.mouseButtons.right);
        y();
      }
    }, c = (g) => {
      const A = this._lockedPointer || this._findPointerById(1);
      A && (A.clientX = g.clientX, A.clientY = g.clientY, A.deltaX = g.movementX, A.deltaY = g.movementY, this._state = 0, (this._lockedPointer || (g.buttons & ye.LEFT) === ye.LEFT) && (this._state = this._state | this.mouseButtons.left), (g.buttons & ye.MIDDLE) === ye.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (g.buttons & ye.RIGHT) === ye.RIGHT && (this._state = this._state | this.mouseButtons.right), y());
    }, u = (g) => {
      const A = this._findPointerById(g.pointerId);
      if (!(A && A === this._lockedPointer)) {
        if (A && this._disposePointer(A), g.pointerType === "touch")
          switch (this._activePointers.length) {
            case 0:
              this._state = Q.NONE;
              break;
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          this._state = Q.NONE;
        E();
      }
    }, h = () => {
      const g = this._findPointerById(1);
      g && g === this._lockedPointer || (g && this._disposePointer(g), this._state = Q.NONE, E());
    };
    let m = -1;
    const p = (g) => {
      if (!this._domElement || !this._enabled || this.mouseButtons.wheel === Q.NONE)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const w = this._domElement.getBoundingClientRect(), f = g.clientX / w.width, P = g.clientY / w.height;
        if (f < this._interactiveArea.left || f > this._interactiveArea.right || P < this._interactiveArea.top || P > this._interactiveArea.bottom)
          return;
      }
      if (g.preventDefault(), this.dollyToCursor || this.mouseButtons.wheel === Q.ROTATE || this.mouseButtons.wheel === Q.TRUCK) {
        const w = performance.now();
        m - w < 1e3 && this._getClientRect(this._elementRect), m = w;
      }
      const A = _f ? -1 : -3, x = g.deltaMode === 1 ? g.deltaY / A : g.deltaY / (A * 10), M = this.dollyToCursor ? (g.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, d = this.dollyToCursor ? (g.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
      switch (this.mouseButtons.wheel) {
        case Q.ROTATE: {
          this._rotateInternal(g.deltaX, g.deltaY), this._isUserControllingRotate = !0;
          break;
        }
        case Q.TRUCK: {
          this._truckInternal(g.deltaX, g.deltaY, !1), this._isUserControllingTruck = !0;
          break;
        }
        case Q.OFFSET: {
          this._truckInternal(g.deltaX, g.deltaY, !0), this._isUserControllingOffset = !0;
          break;
        }
        case Q.DOLLY: {
          this._dollyInternal(-x, M, d), this._isUserControllingDolly = !0;
          break;
        }
        case Q.ZOOM: {
          this._zoomInternal(-x, M, d), this._isUserControllingZoom = !0;
          break;
        }
      }
      this.dispatchEvent({ type: "control" });
    }, v = (g) => {
      if (!(!this._domElement || !this._enabled)) {
        if (this.mouseButtons.right === ls.ACTION.NONE) {
          const A = g instanceof PointerEvent ? g.pointerId : (g instanceof MouseEvent, 0), x = this._findPointerById(A);
          x && this._disposePointer(x), this._domElement.ownerDocument.removeEventListener("pointermove", l, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", u), this._domElement.ownerDocument.removeEventListener("mousemove", c), this._domElement.ownerDocument.removeEventListener("mouseup", h);
          return;
        }
        g.preventDefault();
      }
    }, _ = (g) => {
      if (!this._enabled)
        return;
      if (Ti(this._activePointers, at), this._getClientRect(this._elementRect), n.copy(at), s.copy(at), this._activePointers.length >= 2) {
        const x = at.x - this._activePointers[1].clientX, M = at.y - this._activePointers[1].clientY, d = Math.sqrt(x * x + M * M);
        i.set(0, d);
        const w = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5, f = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
        s.set(w, f);
      }
      if (this._state = 0, !g)
        this._lockedPointer && (this._state = this._state | this.mouseButtons.left);
      else if ("pointerType" in g && g.pointerType === "touch")
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      else
        !this._lockedPointer && (g.buttons & ye.LEFT) === ye.LEFT && (this._state = this._state | this.mouseButtons.left), (g.buttons & ye.MIDDLE) === ye.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (g.buttons & ye.RIGHT) === ye.RIGHT && (this._state = this._state | this.mouseButtons.right);
      ((this._state & Q.ROTATE) === Q.ROTATE || (this._state & Q.TOUCH_ROTATE) === Q.TOUCH_ROTATE || (this._state & Q.TOUCH_DOLLY_ROTATE) === Q.TOUCH_DOLLY_ROTATE || (this._state & Q.TOUCH_ZOOM_ROTATE) === Q.TOUCH_ZOOM_ROTATE) && (this._sphericalEnd.theta = this._spherical.theta, this._sphericalEnd.phi = this._spherical.phi, this._thetaVelocity.value = 0, this._phiVelocity.value = 0), ((this._state & Q.TRUCK) === Q.TRUCK || (this._state & Q.TOUCH_TRUCK) === Q.TOUCH_TRUCK || (this._state & Q.TOUCH_DOLLY_TRUCK) === Q.TOUCH_DOLLY_TRUCK || (this._state & Q.TOUCH_ZOOM_TRUCK) === Q.TOUCH_ZOOM_TRUCK) && (this._targetEnd.copy(this._target), this._targetVelocity.set(0, 0, 0)), ((this._state & Q.DOLLY) === Q.DOLLY || (this._state & Q.TOUCH_DOLLY) === Q.TOUCH_DOLLY || (this._state & Q.TOUCH_DOLLY_TRUCK) === Q.TOUCH_DOLLY_TRUCK || (this._state & Q.TOUCH_DOLLY_OFFSET) === Q.TOUCH_DOLLY_OFFSET || (this._state & Q.TOUCH_DOLLY_ROTATE) === Q.TOUCH_DOLLY_ROTATE) && (this._sphericalEnd.radius = this._spherical.radius, this._radiusVelocity.value = 0), ((this._state & Q.ZOOM) === Q.ZOOM || (this._state & Q.TOUCH_ZOOM) === Q.TOUCH_ZOOM || (this._state & Q.TOUCH_ZOOM_TRUCK) === Q.TOUCH_ZOOM_TRUCK || (this._state & Q.TOUCH_ZOOM_OFFSET) === Q.TOUCH_ZOOM_OFFSET || (this._state & Q.TOUCH_ZOOM_ROTATE) === Q.TOUCH_ZOOM_ROTATE) && (this._zoomEnd = this._zoom, this._zoomVelocity.value = 0), ((this._state & Q.OFFSET) === Q.OFFSET || (this._state & Q.TOUCH_OFFSET) === Q.TOUCH_OFFSET || (this._state & Q.TOUCH_DOLLY_OFFSET) === Q.TOUCH_DOLLY_OFFSET || (this._state & Q.TOUCH_ZOOM_OFFSET) === Q.TOUCH_ZOOM_OFFSET) && (this._focalOffsetEnd.copy(this._focalOffset), this._focalOffsetVelocity.set(0, 0, 0)), this.dispatchEvent({ type: "controlstart" });
    }, y = () => {
      if (!this._enabled || !this._dragNeedsUpdate)
        return;
      this._dragNeedsUpdate = !1, Ti(this._activePointers, at);
      const A = this._domElement && document.pointerLockElement === this._domElement ? this._lockedPointer || this._activePointers[0] : null, x = A ? -A.deltaX : s.x - at.x, M = A ? -A.deltaY : s.y - at.y;
      if (s.copy(at), ((this._state & Q.ROTATE) === Q.ROTATE || (this._state & Q.TOUCH_ROTATE) === Q.TOUCH_ROTATE || (this._state & Q.TOUCH_DOLLY_ROTATE) === Q.TOUCH_DOLLY_ROTATE || (this._state & Q.TOUCH_ZOOM_ROTATE) === Q.TOUCH_ZOOM_ROTATE) && (this._rotateInternal(x, M), this._isUserControllingRotate = !0), (this._state & Q.DOLLY) === Q.DOLLY || (this._state & Q.ZOOM) === Q.ZOOM) {
        const d = this.dollyToCursor ? (n.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, w = this.dollyToCursor ? (n.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0, f = this.dollyDragInverted ? -1 : 1;
        (this._state & Q.DOLLY) === Q.DOLLY ? (this._dollyInternal(f * M * Ds, d, w), this._isUserControllingDolly = !0) : (this._zoomInternal(f * M * Ds, d, w), this._isUserControllingZoom = !0);
      }
      if ((this._state & Q.TOUCH_DOLLY) === Q.TOUCH_DOLLY || (this._state & Q.TOUCH_ZOOM) === Q.TOUCH_ZOOM || (this._state & Q.TOUCH_DOLLY_TRUCK) === Q.TOUCH_DOLLY_TRUCK || (this._state & Q.TOUCH_ZOOM_TRUCK) === Q.TOUCH_ZOOM_TRUCK || (this._state & Q.TOUCH_DOLLY_OFFSET) === Q.TOUCH_DOLLY_OFFSET || (this._state & Q.TOUCH_ZOOM_OFFSET) === Q.TOUCH_ZOOM_OFFSET || (this._state & Q.TOUCH_DOLLY_ROTATE) === Q.TOUCH_DOLLY_ROTATE || (this._state & Q.TOUCH_ZOOM_ROTATE) === Q.TOUCH_ZOOM_ROTATE) {
        const d = at.x - this._activePointers[1].clientX, w = at.y - this._activePointers[1].clientY, f = Math.sqrt(d * d + w * w), P = i.y - f;
        i.set(0, f);
        const I = this.dollyToCursor ? (s.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, K = this.dollyToCursor ? (s.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        (this._state & Q.TOUCH_DOLLY) === Q.TOUCH_DOLLY || (this._state & Q.TOUCH_DOLLY_ROTATE) === Q.TOUCH_DOLLY_ROTATE || (this._state & Q.TOUCH_DOLLY_TRUCK) === Q.TOUCH_DOLLY_TRUCK || (this._state & Q.TOUCH_DOLLY_OFFSET) === Q.TOUCH_DOLLY_OFFSET ? (this._dollyInternal(P * Ds, I, K), this._isUserControllingDolly = !0) : (this._zoomInternal(P * Ds, I, K), this._isUserControllingZoom = !0);
      }
      ((this._state & Q.TRUCK) === Q.TRUCK || (this._state & Q.TOUCH_TRUCK) === Q.TOUCH_TRUCK || (this._state & Q.TOUCH_DOLLY_TRUCK) === Q.TOUCH_DOLLY_TRUCK || (this._state & Q.TOUCH_ZOOM_TRUCK) === Q.TOUCH_ZOOM_TRUCK) && (this._truckInternal(x, M, !1), this._isUserControllingTruck = !0), ((this._state & Q.OFFSET) === Q.OFFSET || (this._state & Q.TOUCH_OFFSET) === Q.TOUCH_OFFSET || (this._state & Q.TOUCH_DOLLY_OFFSET) === Q.TOUCH_DOLLY_OFFSET || (this._state & Q.TOUCH_ZOOM_OFFSET) === Q.TOUCH_ZOOM_OFFSET) && (this._truckInternal(x, M, !0), this._isUserControllingOffset = !0), this.dispatchEvent({ type: "control" });
    }, E = () => {
      Ti(this._activePointers, at), s.copy(at), this._dragNeedsUpdate = !1, (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) && (this._isDragging = !1), this._activePointers.length === 0 && this._domElement && (this._domElement.ownerDocument.removeEventListener("pointermove", l, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("mousemove", c), this._domElement.ownerDocument.removeEventListener("pointerup", u), this._domElement.ownerDocument.removeEventListener("mouseup", h), this.dispatchEvent({ type: "controlend" }));
    };
    this.lockPointer = () => {
      !this._enabled || !this._domElement || (this.cancel(), this._lockedPointer = {
        pointerId: -1,
        clientX: 0,
        clientY: 0,
        deltaX: 0,
        deltaY: 0,
        mouseButton: null
      }, this._activePointers.push(this._lockedPointer), this._domElement.ownerDocument.removeEventListener("pointermove", l, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", u), this._domElement.requestPointerLock(), this._domElement.ownerDocument.addEventListener("pointerlockchange", R), this._domElement.ownerDocument.addEventListener("pointerlockerror", T), this._domElement.ownerDocument.addEventListener("pointermove", l, { passive: !1 }), this._domElement.ownerDocument.addEventListener("pointerup", u), _());
    }, this.unlockPointer = () => {
      this._lockedPointer !== null && (this._disposePointer(this._lockedPointer), this._lockedPointer = null), document.exitPointerLock(), this.cancel(), this._domElement && (this._domElement.ownerDocument.removeEventListener("pointerlockchange", R), this._domElement.ownerDocument.removeEventListener("pointerlockerror", T));
    };
    const R = () => {
      this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement || this.unlockPointer();
    }, T = () => {
      this.unlockPointer();
    };
    this._addAllEventListeners = (g) => {
      this._domElement = g, this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none", this._domElement.addEventListener("pointerdown", r), xf && this._domElement.addEventListener("mousedown", a), this._domElement.addEventListener("pointercancel", u), this._domElement.addEventListener("wheel", p, { passive: !1 }), this._domElement.addEventListener("contextmenu", v);
    }, this._removeAllEventListeners = () => {
      this._domElement && (this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = "", this._domElement.removeEventListener("pointerdown", r), this._domElement.removeEventListener("mousedown", a), this._domElement.removeEventListener("pointercancel", u), this._domElement.removeEventListener("wheel", p, { passive: !1 }), this._domElement.removeEventListener("contextmenu", v), this._domElement.ownerDocument.removeEventListener("pointermove", l, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("mousemove", c), this._domElement.ownerDocument.removeEventListener("pointerup", u), this._domElement.ownerDocument.removeEventListener("mouseup", h), this._domElement.ownerDocument.removeEventListener("pointerlockchange", R), this._domElement.ownerDocument.removeEventListener("pointerlockerror", T));
    }, this.cancel = () => {
      this._state !== Q.NONE && (this._state = Q.NONE, this._activePointers.length = 0, E());
    }, t && this.connect(t), this.update(0);
  }
  /**
   * The camera to be controlled
   * @category Properties
   */
  get camera() {
    return this._camera;
  }
  set camera(e) {
    this._camera = e, this.updateCameraUp(), this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0;
  }
  /**
   * Whether or not the controls are enabled.
   * `false` to disable user dragging/touch-move, but all methods works.
   * @category Properties
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._enabled = e, this._domElement && (e ? (this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none") : (this.cancel(), this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = ""));
  }
  /**
   * Returns `true` if the controls are active updating.
   * readonly value.
   * @category Properties
   */
  get active() {
    return !this._hasRested;
  }
  /**
   * Getter for the current `ACTION`.
   * readonly value.
   * @category Properties
   */
  get currentAction() {
    return this._state;
  }
  /**
   * get/set Current distance.
   * @category Properties
   */
  get distance() {
    return this._spherical.radius;
  }
  set distance(e) {
    this._spherical.radius === e && this._sphericalEnd.radius === e || (this._spherical.radius = e, this._sphericalEnd.radius = e, this._needsUpdate = !0);
  }
  // horizontal angle
  /**
   * get/set the azimuth angle (horizontal) in radians.
   * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
   * @category Properties
   */
  get azimuthAngle() {
    return this._spherical.theta;
  }
  set azimuthAngle(e) {
    this._spherical.theta === e && this._sphericalEnd.theta === e || (this._spherical.theta = e, this._sphericalEnd.theta = e, this._needsUpdate = !0);
  }
  // vertical angle
  /**
   * get/set the polar angle (vertical) in radians.
   * @category Properties
   */
  get polarAngle() {
    return this._spherical.phi;
  }
  set polarAngle(e) {
    this._spherical.phi === e && this._sphericalEnd.phi === e || (this._spherical.phi = e, this._sphericalEnd.phi = e, this._needsUpdate = !0);
  }
  /**
   * Whether camera position should be enclosed in the boundary or not.
   * @category Properties
   */
  get boundaryEnclosesCamera() {
    return this._boundaryEnclosesCamera;
  }
  set boundaryEnclosesCamera(e) {
    this._boundaryEnclosesCamera = e, this._needsUpdate = !0;
  }
  /**
   * Set drag-start, touches and wheel enable area in the domElement.
   * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.
   * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.
   * @category Properties
   */
  set interactiveArea(e) {
    this._interactiveArea.width = Et(e.width, 0, 1), this._interactiveArea.height = Et(e.height, 0, 1), this._interactiveArea.x = Et(e.x, 0, 1 - this._interactiveArea.width), this._interactiveArea.y = Et(e.y, 0, 1 - this._interactiveArea.height);
  }
  /**
   * Adds the specified event listener.
   * Applicable event types (which is `K`) are:
   * | Event name          | Timing |
   * | ------------------- | ------ |
   * | `'controlstart'`    | When the user starts to control the camera via mouse / touches. ¹ |
   * | `'control'`         | When the user controls the camera (dragging). |
   * | `'controlend'`      | When the user ends to control the camera. ¹ |
   * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
   * | `'update'`          | When the camera position is updated. |
   * | `'wake'`            | When the camera starts moving. |
   * | `'rest'`            | When the camera movement is below `.restThreshold` ². |
   * | `'sleep'`           | When the camera end moving. |
   *
   * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
   * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
   *
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(e, t) {
    super.addEventListener(e, t);
  }
  /**
   * Removes the specified event listener
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(e, t) {
    super.removeEventListener(e, t);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical).
   * Every value is added to the current value.
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotate(e, t, n = !1) {
    return this.rotateTo(this._sphericalEnd.theta + e, this._sphericalEnd.phi + t, n);
  }
  /**
   * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
   *
   * e.g.
   * ```
   * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotateAzimuthTo(e, t = !1) {
    return this.rotateTo(e, this._sphericalEnd.phi, t);
  }
  /**
   * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
   *
   * e.g.
   * ```
   * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotatePolarTo(e, t = !1) {
    return this.rotateTo(this._sphericalEnd.theta, e, t);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
   * Camera view will rotate over the orbit pivot absolutely:
   *
   * azimuthAngle
   * ```
   *       0º
   *         \
   * 90º -----+----- -90º
   *           \
   *           180º
   * ```
   * | direction | angle                  |
   * | --------- | ---------------------- |
   * | front     | 0º                     |
   * | left      | 90º (`Math.PI / 2`)    |
   * | right     | -90º (`- Math.PI / 2`) |
   * | back      | 180º (`Math.PI`)       |
   *
   * polarAngle
   * ```
   *     180º
   *      |
   *      90º
   *      |
   *      0º
   * ```
   * | direction            | angle                  |
   * | -------------------- | ---------------------- |
   * | top/sky              | 180º (`Math.PI`)       |
   * | horizontal from view | 90º (`Math.PI / 2`)    |
   * | bottom/floor         | 0º                     |
   *
   * @param azimuthAngle Azimuth rotate angle to. In radian.
   * @param polarAngle Polar rotate angle to. In radian.
   * @param enableTransition  Whether to move smoothly or immediately
   * @category Methods
   */
  rotateTo(e, t, n = !1) {
    this._isUserControllingRotate = !1;
    const s = Et(e, this.minAzimuthAngle, this.maxAzimuthAngle), i = Et(t, this.minPolarAngle, this.maxPolarAngle);
    this._sphericalEnd.theta = s, this._sphericalEnd.phi = i, this._sphericalEnd.makeSafe(), this._needsUpdate = !0, n || (this._spherical.theta = this._sphericalEnd.theta, this._spherical.phi = this._sphericalEnd.phi);
    const r = !n || ke(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && ke(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
    return this._createOnRestPromise(r);
  }
  /**
   * Dolly in/out camera position.
   * @param distance Distance of dollyIn. Negative number for dollyOut.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dolly(e, t = !1) {
    return this.dollyTo(this._sphericalEnd.radius - e, t);
  }
  /**
   * Dolly in/out camera position to given distance.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyTo(e, t = !1) {
    return this._isUserControllingDolly = !1, this._lastDollyDirection = Dn.NONE, this._changedDolly = 0, this._dollyToNoClamp(Et(e, this.minDistance, this.maxDistance), t);
  }
  _dollyToNoClamp(e, t = !1) {
    const n = this._sphericalEnd.radius;
    if (this.colliderMeshes.length >= 1) {
      const r = this._collisionTest(), a = ke(r, this._spherical.radius);
      if (!(n > e) && a)
        return Promise.resolve();
      this._sphericalEnd.radius = Math.min(e, r);
    } else
      this._sphericalEnd.radius = e;
    this._needsUpdate = !0, t || (this._spherical.radius = this._sphericalEnd.radius);
    const i = !t || ke(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(i);
  }
  /**
   * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.
   * Specify a negative value for dolly out.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyInFixed(e, t = !1) {
    this._targetEnd.add(this._getCameraDirection(qn).multiplyScalar(e)), t || this._target.copy(this._targetEnd);
    const n = !t || ke(this._target.x, this._targetEnd.x, this.restThreshold) && ke(this._target.y, this._targetEnd.y, this.restThreshold) && ke(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(n);
  }
  /**
   * Zoom in/out camera. The value is added to camera zoom.
   * Limits set with `.minZoom` and `.maxZoom`
   * @param zoomStep zoom scale
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  zoom(e, t = !1) {
    return this.zoomTo(this._zoomEnd + e, t);
  }
  /**
   * Zoom in/out camera to given scale. The value overwrites camera zoom.
   * Limits set with .minZoom and .maxZoom
   * @param zoom
   * @param enableTransition
   * @category Methods
   */
  zoomTo(e, t = !1) {
    this._isUserControllingZoom = !1, this._zoomEnd = Et(e, this.minZoom, this.maxZoom), this._needsUpdate = !0, t || (this._zoom = this._zoomEnd);
    const n = !t || ke(this._zoom, this._zoomEnd, this.restThreshold);
    return this._changedZoom = 0, this._createOnRestPromise(n);
  }
  /**
   * @deprecated `pan()` has been renamed to `truck()`
   * @category Methods
   */
  pan(e, t, n = !1) {
    return console.warn("`pan` has been renamed to `truck`"), this.truck(e, t, n);
  }
  /**
   * Truck and pedestal camera using current azimuthal angle
   * @param x Horizontal translate amount
   * @param y Vertical translate amount
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  truck(e, t, n = !1) {
    this._camera.updateMatrix(), Pt.setFromMatrixColumn(this._camera.matrix, 0), Rt.setFromMatrixColumn(this._camera.matrix, 1), Pt.multiplyScalar(e), Rt.multiplyScalar(-t);
    const s = Ee.copy(Pt).add(Rt), i = Le.copy(this._targetEnd).add(s);
    return this.moveTo(i.x, i.y, i.z, n);
  }
  /**
   * Move forward / backward.
   * @param distance Amount to move forward / backward. Negative value to move backward
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  forward(e, t = !1) {
    Ee.setFromMatrixColumn(this._camera.matrix, 0), Ee.crossVectors(this._camera.up, Ee), Ee.multiplyScalar(e);
    const n = Le.copy(this._targetEnd).add(Ee);
    return this.moveTo(n.x, n.y, n.z, t);
  }
  /**
   * Move up / down.
   * @param height Amount to move up / down. Negative value to move down
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  elevate(e, t = !1) {
    return Ee.copy(this._camera.up).multiplyScalar(e), this.moveTo(this._targetEnd.x + Ee.x, this._targetEnd.y + Ee.y, this._targetEnd.z + Ee.z, t);
  }
  /**
   * Move target position to given point.
   * @param x x coord to move center position
   * @param y y coord to move center position
   * @param z z coord to move center position
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  moveTo(e, t, n, s = !1) {
    this._isUserControllingTruck = !1;
    const i = Ee.set(e, t, n).sub(this._targetEnd);
    this._encloseToBoundary(this._targetEnd, i, this.boundaryFriction), this._needsUpdate = !0, s || this._target.copy(this._targetEnd);
    const r = !s || ke(this._target.x, this._targetEnd.x, this.restThreshold) && ke(this._target.y, this._targetEnd.y, this.restThreshold) && ke(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(r);
  }
  /**
   * Look in the given point direction.
   * @param x point x.
   * @param y point y.
   * @param z point z.
   * @param enableTransition Whether to move smoothly or immediately.
   * @returns Transition end promise
   * @category Methods
   */
  lookInDirectionOf(e, t, n, s = !1) {
    const a = Ee.set(e, t, n).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius).add(this._targetEnd);
    return this.setPosition(a.x, a.y, a.z, s);
  }
  /**
   * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
   * set `cover: true` to fill enter screen.
   * e.g.
   * ```
   * cameraControls.fitToBox( myMesh );
   * ```
   * @param box3OrObject Axis aligned bounding box to fit the view.
   * @param enableTransition Whether to move smoothly or immediately.
   * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
   * @returns Transition end promise
   * @category Methods
   */
  fitToBox(e, t, { cover: n = !1, paddingLeft: s = 0, paddingRight: i = 0, paddingBottom: r = 0, paddingTop: a = 0 } = {}) {
    const l = [], c = e.isBox3 ? Fn.copy(e) : Fn.setFromObject(e);
    c.isEmpty() && (console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"), Promise.resolve());
    const u = io(this._sphericalEnd.theta, so), h = io(this._sphericalEnd.phi, so);
    l.push(this.rotateTo(u, h, t));
    const m = Ee.setFromSpherical(this._sphericalEnd).normalize(), p = uo.setFromUnitVectors(m, Ei), v = ke(Math.abs(m.y), 1);
    v && p.multiply(Si.setFromAxisAngle(Ls, u)), p.multiply(this._yAxisUpSpaceInverse);
    const _ = co.makeEmpty();
    Le.copy(c.min).applyQuaternion(p), _.expandByPoint(Le), Le.copy(c.min).setX(c.max.x).applyQuaternion(p), _.expandByPoint(Le), Le.copy(c.min).setY(c.max.y).applyQuaternion(p), _.expandByPoint(Le), Le.copy(c.max).setZ(c.min.z).applyQuaternion(p), _.expandByPoint(Le), Le.copy(c.min).setZ(c.max.z).applyQuaternion(p), _.expandByPoint(Le), Le.copy(c.max).setY(c.min.y).applyQuaternion(p), _.expandByPoint(Le), Le.copy(c.max).setX(c.min.x).applyQuaternion(p), _.expandByPoint(Le), Le.copy(c.max).applyQuaternion(p), _.expandByPoint(Le), _.min.x -= s, _.min.y -= r, _.max.x += i, _.max.y += a, p.setFromUnitVectors(Ei, m), v && p.premultiply(Si.invert()), p.premultiply(this._yAxisUpSpace);
    const y = _.getSize(Ee), E = _.getCenter(Le).applyQuaternion(p);
    if (gn(this._camera)) {
      const R = this.getDistanceToFitBox(y.x, y.y, y.z, n);
      l.push(this.moveTo(E.x, E.y, E.z, t)), l.push(this.dollyTo(R, t)), l.push(this.setFocalOffset(0, 0, 0, t));
    } else if (sn(this._camera)) {
      const R = this._camera, T = R.right - R.left, g = R.top - R.bottom, A = n ? Math.max(T / y.x, g / y.y) : Math.min(T / y.x, g / y.y);
      l.push(this.moveTo(E.x, E.y, E.z, t)), l.push(this.zoomTo(A, t)), l.push(this.setFocalOffset(0, 0, 0, t));
    }
    return Promise.all(l);
  }
  /**
   * Fit the viewport to the sphere or the bounding sphere of the object.
   * @param sphereOrMesh
   * @param enableTransition
   * @category Methods
   */
  fitToSphere(e, t) {
    const n = [], i = e instanceof me.Sphere ? Mi.copy(e) : ls.createBoundingSphere(e, Mi);
    if (n.push(this.moveTo(i.center.x, i.center.y, i.center.z, t)), gn(this._camera)) {
      const r = this.getDistanceToFitSphere(i.radius);
      n.push(this.dollyTo(r, t));
    } else if (sn(this._camera)) {
      const r = this._camera.right - this._camera.left, a = this._camera.top - this._camera.bottom, l = 2 * i.radius, c = Math.min(r / l, a / l);
      n.push(this.zoomTo(c, t));
    }
    return n.push(this.setFocalOffset(0, 0, 0, t)), Promise.all(n);
  }
  /**
   * Look at the `target` from the `position`.
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setLookAt(e, t, n, s, i, r, a = !1) {
    this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._lastDollyDirection = Dn.NONE, this._changedDolly = 0;
    const l = Le.set(s, i, r), c = Ee.set(e, t, n);
    this._targetEnd.copy(l), this._sphericalEnd.setFromVector3(c.sub(l).applyQuaternion(this._yAxisUpSpace)), this.normalizeRotations(), this._needsUpdate = !0, a || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const u = !a || ke(this._target.x, this._targetEnd.x, this.restThreshold) && ke(this._target.y, this._targetEnd.y, this.restThreshold) && ke(this._target.z, this._targetEnd.z, this.restThreshold) && ke(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && ke(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && ke(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(u);
  }
  /**
   * Similar to setLookAt, but it interpolates between two states.
   * @param positionAX
   * @param positionAY
   * @param positionAZ
   * @param targetAX
   * @param targetAY
   * @param targetAZ
   * @param positionBX
   * @param positionBY
   * @param positionBZ
   * @param targetBX
   * @param targetBY
   * @param targetBZ
   * @param t
   * @param enableTransition
   * @category Methods
   */
  lerpLookAt(e, t, n, s, i, r, a, l, c, u, h, m, p, v = !1) {
    this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._lastDollyDirection = Dn.NONE, this._changedDolly = 0;
    const _ = Ee.set(s, i, r), y = Le.set(e, t, n);
    yt.setFromVector3(y.sub(_).applyQuaternion(this._yAxisUpSpace));
    const E = On.set(u, h, m), R = Le.set(a, l, c);
    Qn.setFromVector3(R.sub(E).applyQuaternion(this._yAxisUpSpace)), this._targetEnd.copy(_.lerp(E, p));
    const T = Qn.theta - yt.theta, g = Qn.phi - yt.phi, A = Qn.radius - yt.radius;
    this._sphericalEnd.set(yt.radius + A * p, yt.phi + g * p, yt.theta + T * p), this.normalizeRotations(), this._needsUpdate = !0, v || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const x = !v || ke(this._target.x, this._targetEnd.x, this.restThreshold) && ke(this._target.y, this._targetEnd.y, this.restThreshold) && ke(this._target.z, this._targetEnd.z, this.restThreshold) && ke(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && ke(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && ke(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(x);
  }
  /**
   * Set angle and distance by given position.
   * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param enableTransition
   * @category Methods
   */
  setPosition(e, t, n, s = !1) {
    return this.setLookAt(e, t, n, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, s);
  }
  /**
   * Set the target position where gaze at.
   * An alias of `setLookAt()`, without position change. Thus keep the same position.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setTarget(e, t, n, s = !1) {
    const i = this.getPosition(Ee), r = this.setLookAt(i.x, i.y, i.z, e, t, n, s);
    return this._sphericalEnd.phi = Et(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle), r;
  }
  /**
   * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
   * @param x
   * @param y
   * @param z
   * @param enableTransition
   * @category Methods
   */
  setFocalOffset(e, t, n, s = !1) {
    this._isUserControllingOffset = !1, this._focalOffsetEnd.set(e, t, n), this._needsUpdate = !0, s || this._focalOffset.copy(this._focalOffsetEnd);
    const i = !s || ke(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && ke(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && ke(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
    return this._createOnRestPromise(i);
  }
  /**
   * Set orbit point without moving the camera.
   * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @category Methods
   */
  setOrbitPoint(e, t, n) {
    this._camera.updateMatrixWorld(), Pt.setFromMatrixColumn(this._camera.matrixWorldInverse, 0), Rt.setFromMatrixColumn(this._camera.matrixWorldInverse, 1), yn.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
    const s = Ee.set(e, t, n), i = s.distanceTo(this._camera.position), r = s.sub(this._camera.position);
    Pt.multiplyScalar(r.x), Rt.multiplyScalar(r.y), yn.multiplyScalar(r.z), Ee.copy(Pt).add(Rt).add(yn), Ee.z = Ee.z + i, this.dollyTo(i, !1), this.setFocalOffset(-Ee.x, Ee.y, -Ee.z, !1), this.moveTo(e, t, n, !1);
  }
  /**
   * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
   * @param box3
   * @category Methods
   */
  setBoundary(e) {
    if (!e) {
      this._boundary.min.set(-1 / 0, -1 / 0, -1 / 0), this._boundary.max.set(1 / 0, 1 / 0, 1 / 0), this._needsUpdate = !0;
      return;
    }
    this._boundary.copy(e), this._boundary.clampPoint(this._targetEnd, this._targetEnd), this._needsUpdate = !0;
  }
  /**
   * Set (or unset) the current viewport.
   * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
   * @param viewportOrX
   * @param y
   * @param width
   * @param height
   * @category Methods
   */
  setViewport(e, t, n, s) {
    if (e === null) {
      this._viewport = null;
      return;
    }
    this._viewport = this._viewport || new me.Vector4(), typeof e == "number" ? this._viewport.set(e, t, n, s) : this._viewport.copy(e);
  }
  /**
   * Calculate the distance to fit the box.
   * @param width box width
   * @param height box height
   * @param depth box depth
   * @returns distance
   * @category Methods
   */
  getDistanceToFitBox(e, t, n, s = !1) {
    if (bi(this._camera, "getDistanceToFitBox"))
      return this._spherical.radius;
    const i = e / t, r = this._camera.getEffectiveFOV() * $n, a = this._camera.aspect;
    return ((s ? i > a : i < a) ? t : e / a) * 0.5 / Math.tan(r * 0.5) + n * 0.5;
  }
  /**
   * Calculate the distance to fit the sphere.
   * @param radius sphere radius
   * @returns distance
   * @category Methods
   */
  getDistanceToFitSphere(e) {
    if (bi(this._camera, "getDistanceToFitSphere"))
      return this._spherical.radius;
    const t = this._camera.getEffectiveFOV() * $n, n = Math.atan(Math.tan(t * 0.5) * this._camera.aspect) * 2, s = 1 < this._camera.aspect ? t : n;
    return e / Math.sin(s * 0.5);
  }
  /**
   * Returns the orbit center position, where the camera looking at.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getTarget(e, t = !0) {
    return (e && e.isVector3 ? e : new me.Vector3()).copy(t ? this._targetEnd : this._target);
  }
  /**
   * Returns the camera position.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getPosition(e, t = !0) {
    return (e && e.isVector3 ? e : new me.Vector3()).setFromSpherical(t ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(t ? this._targetEnd : this._target);
  }
  /**
   * Returns the spherical coordinates of the orbit.
   * @param out The receiving Spherical instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getSpherical(e, t = !0) {
    return (e && e instanceof me.Spherical ? e : new me.Spherical()).copy(t ? this._sphericalEnd : this._spherical);
  }
  /**
   * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getFocalOffset(e, t = !0) {
    return (e && e.isVector3 ? e : new me.Vector3()).copy(t ? this._focalOffsetEnd : this._focalOffset);
  }
  /**
   * Normalize camera azimuth angle rotation between 0 and 360 degrees.
   * @category Methods
   */
  normalizeRotations() {
    this._sphericalEnd.theta = this._sphericalEnd.theta % Ln, this._sphericalEnd.theta < 0 && (this._sphericalEnd.theta += Ln), this._spherical.theta += Ln * Math.round((this._sphericalEnd.theta - this._spherical.theta) / Ln);
  }
  /**
   * Reset all rotation and position to defaults.
   * @param enableTransition
   * @category Methods
   */
  reset(e = !1) {
    if (!ke(this._camera.up.x, this._cameraUp0.x) || !ke(this._camera.up.y, this._cameraUp0.y) || !ke(this._camera.up.z, this._cameraUp0.z)) {
      this._camera.up.copy(this._cameraUp0);
      const n = this.getPosition(Ee);
      this.updateCameraUp(), this.setPosition(n.x, n.y, n.z);
    }
    const t = [
      this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, e),
      this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, e),
      this.zoomTo(this._zoom0, e)
    ];
    return Promise.all(t);
  }
  /**
   * Set current camera position as the default position.
   * @category Methods
   */
  saveState() {
    this._cameraUp0.copy(this._camera.up), this.getTarget(this._target0), this.getPosition(this._position0), this._zoom0 = this._zoom, this._focalOffset0.copy(this._focalOffset);
  }
  /**
   * Sync camera-up direction.
   * When camera-up vector is changed, `.updateCameraUp()` must be called.
   * @category Methods
   */
  updateCameraUp() {
    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, Ls), this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
  }
  /**
   * Apply current camera-up direction to the camera.
   * The orbit system will be re-initialized with the current position.
   * @category Methods
   */
  applyCameraUp() {
    const e = Ee.subVectors(this._target, this._camera.position).normalize(), t = Le.crossVectors(e, this._camera.up);
    this._camera.up.crossVectors(t, e).normalize(), this._camera.updateMatrixWorld();
    const n = this.getPosition(Ee);
    this.updateCameraUp(), this.setPosition(n.x, n.y, n.z);
  }
  /**
   * Update camera position and directions.
   * This should be called in your tick loop every time, and returns true if re-rendering is needed.
   * @param delta
   * @returns updated
   * @category Methods
   */
  update(e) {
    const t = this._sphericalEnd.theta - this._spherical.theta, n = this._sphericalEnd.phi - this._spherical.phi, s = this._sphericalEnd.radius - this._spherical.radius, i = ao.subVectors(this._targetEnd, this._target), r = lo.subVectors(this._focalOffsetEnd, this._focalOffset), a = this._zoomEnd - this._zoom;
    if (ze(t))
      this._thetaVelocity.value = 0, this._spherical.theta = this._sphericalEnd.theta;
    else {
      const h = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.theta = Is(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, h, 1 / 0, e), this._needsUpdate = !0;
    }
    if (ze(n))
      this._phiVelocity.value = 0, this._spherical.phi = this._sphericalEnd.phi;
    else {
      const h = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.phi = Is(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, h, 1 / 0, e), this._needsUpdate = !0;
    }
    if (ze(s))
      this._radiusVelocity.value = 0, this._spherical.radius = this._sphericalEnd.radius;
    else {
      const h = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.radius = Is(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, h, this.maxSpeed, e), this._needsUpdate = !0;
    }
    if (ze(i.x) && ze(i.y) && ze(i.z))
      this._targetVelocity.set(0, 0, 0), this._target.copy(this._targetEnd);
    else {
      const h = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
      ro(this._target, this._targetEnd, this._targetVelocity, h, this.maxSpeed, e, this._target), this._needsUpdate = !0;
    }
    if (ze(r.x) && ze(r.y) && ze(r.z))
      this._focalOffsetVelocity.set(0, 0, 0), this._focalOffset.copy(this._focalOffsetEnd);
    else {
      const h = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
      ro(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, h, this.maxSpeed, e, this._focalOffset), this._needsUpdate = !0;
    }
    if (ze(a))
      this._zoomVelocity.value = 0, this._zoom = this._zoomEnd;
    else {
      const h = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
      this._zoom = Is(this._zoom, this._zoomEnd, this._zoomVelocity, h, 1 / 0, e);
    }
    if (this.dollyToCursor) {
      if (gn(this._camera) && this._changedDolly !== 0) {
        const h = this._spherical.radius - this._lastDistance, m = this._camera, p = this._getCameraDirection(qn), v = Ee.copy(p).cross(m.up).normalize();
        v.lengthSq() === 0 && (v.x = 1);
        const _ = Le.crossVectors(v, p), y = this._sphericalEnd.radius * Math.tan(m.getEffectiveFOV() * $n * 0.5), R = (this._sphericalEnd.radius - h - this._sphericalEnd.radius) / this._sphericalEnd.radius, T = On.copy(this._targetEnd).add(v.multiplyScalar(this._dollyControlCoord.x * y * m.aspect)).add(_.multiplyScalar(this._dollyControlCoord.y * y)), g = Ee.copy(this._targetEnd).lerp(T, R), A = this._lastDollyDirection === Dn.IN && this._spherical.radius <= this.minDistance, x = this._lastDollyDirection === Dn.OUT && this.maxDistance <= this._spherical.radius;
        if (this.infinityDolly && (A || x)) {
          this._sphericalEnd.radius -= h, this._spherical.radius -= h;
          const d = Le.copy(p).multiplyScalar(-h);
          g.add(d);
        }
        this._boundary.clampPoint(g, g);
        const M = Le.subVectors(g, this._targetEnd);
        this._targetEnd.copy(g), this._target.add(M), this._changedDolly -= h, ze(this._changedDolly) && (this._changedDolly = 0);
      } else if (sn(this._camera) && this._changedZoom !== 0) {
        const h = this._zoom - this._lastZoom, m = this._camera, p = Ee.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (m.near + m.far) / (m.near - m.far)).unproject(m), v = Le.set(0, 0, -1).applyQuaternion(m.quaternion), _ = On.copy(p).add(v.multiplyScalar(-p.dot(m.up))), E = -(this._zoom - h - this._zoom) / this._zoom, R = this._getCameraDirection(qn), T = this._targetEnd.dot(R), g = Ee.copy(this._targetEnd).lerp(_, E), A = g.dot(R), x = R.multiplyScalar(A - T);
        g.sub(x), this._boundary.clampPoint(g, g);
        const M = Le.subVectors(g, this._targetEnd);
        this._targetEnd.copy(g), this._target.add(M), this._changedZoom -= h, ze(this._changedZoom) && (this._changedZoom = 0);
      }
    }
    this._camera.zoom !== this._zoom && (this._camera.zoom = this._zoom, this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0), this._dragNeedsUpdate = !0;
    const l = this._collisionTest();
    this._spherical.radius = Math.min(this._spherical.radius, l), this._spherical.makeSafe(), this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target), this._camera.lookAt(this._target), (!ze(this._focalOffset.x) || !ze(this._focalOffset.y) || !ze(this._focalOffset.z)) && (this._camera.updateMatrixWorld(), Pt.setFromMatrixColumn(this._camera.matrix, 0), Rt.setFromMatrixColumn(this._camera.matrix, 1), yn.setFromMatrixColumn(this._camera.matrix, 2), Pt.multiplyScalar(this._focalOffset.x), Rt.multiplyScalar(-this._focalOffset.y), yn.multiplyScalar(this._focalOffset.z), Ee.copy(Pt).add(Rt).add(yn), this._camera.position.add(Ee)), this._boundaryEnclosesCamera && this._encloseToBoundary(this._camera.position.copy(this._target), Ee.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
    const u = this._needsUpdate;
    return u && !this._updatedLastTime ? (this._hasRested = !1, this.dispatchEvent({ type: "wake" }), this.dispatchEvent({ type: "update" })) : u ? (this.dispatchEvent({ type: "update" }), ze(t, this.restThreshold) && ze(n, this.restThreshold) && ze(s, this.restThreshold) && ze(i.x, this.restThreshold) && ze(i.y, this.restThreshold) && ze(i.z, this.restThreshold) && ze(r.x, this.restThreshold) && ze(r.y, this.restThreshold) && ze(r.z, this.restThreshold) && ze(a, this.restThreshold) && !this._hasRested && (this._hasRested = !0, this.dispatchEvent({ type: "rest" }))) : !u && this._updatedLastTime && this.dispatchEvent({ type: "sleep" }), this._lastDistance = this._spherical.radius, this._lastZoom = this._zoom, this._updatedLastTime = u, this._needsUpdate = !1, u;
  }
  /**
   * Get all state in JSON string
   * @category Methods
   */
  toJSON() {
    return JSON.stringify({
      enabled: this._enabled,
      minDistance: this.minDistance,
      maxDistance: Zn(this.maxDistance),
      minZoom: this.minZoom,
      maxZoom: Zn(this.maxZoom),
      minPolarAngle: this.minPolarAngle,
      maxPolarAngle: Zn(this.maxPolarAngle),
      minAzimuthAngle: Zn(this.minAzimuthAngle),
      maxAzimuthAngle: Zn(this.maxAzimuthAngle),
      smoothTime: this.smoothTime,
      draggingSmoothTime: this.draggingSmoothTime,
      dollySpeed: this.dollySpeed,
      truckSpeed: this.truckSpeed,
      dollyToCursor: this.dollyToCursor,
      verticalDragToForward: this.verticalDragToForward,
      target: this._targetEnd.toArray(),
      position: Ee.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
      zoom: this._zoomEnd,
      focalOffset: this._focalOffsetEnd.toArray(),
      target0: this._target0.toArray(),
      position0: this._position0.toArray(),
      zoom0: this._zoom0,
      focalOffset0: this._focalOffset0.toArray()
    });
  }
  /**
   * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
   * @param json
   * @param enableTransition
   * @category Methods
   */
  fromJSON(e, t = !1) {
    const n = JSON.parse(e);
    this.enabled = n.enabled, this.minDistance = n.minDistance, this.maxDistance = Kn(n.maxDistance), this.minZoom = n.minZoom, this.maxZoom = Kn(n.maxZoom), this.minPolarAngle = n.minPolarAngle, this.maxPolarAngle = Kn(n.maxPolarAngle), this.minAzimuthAngle = Kn(n.minAzimuthAngle), this.maxAzimuthAngle = Kn(n.maxAzimuthAngle), this.smoothTime = n.smoothTime, this.draggingSmoothTime = n.draggingSmoothTime, this.dollySpeed = n.dollySpeed, this.truckSpeed = n.truckSpeed, this.dollyToCursor = n.dollyToCursor, this.verticalDragToForward = n.verticalDragToForward, this._target0.fromArray(n.target0), this._position0.fromArray(n.position0), this._zoom0 = n.zoom0, this._focalOffset0.fromArray(n.focalOffset0), this.moveTo(n.target[0], n.target[1], n.target[2], t), yt.setFromVector3(Ee.fromArray(n.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)), this.rotateTo(yt.theta, yt.phi, t), this.dollyTo(yt.radius, t), this.zoomTo(n.zoom, t), this.setFocalOffset(n.focalOffset[0], n.focalOffset[1], n.focalOffset[2], t), this._needsUpdate = !0;
  }
  /**
   * Attach all internal event handlers to enable drag control.
   * @category Methods
   */
  connect(e) {
    if (this._domElement) {
      console.warn("camera-controls is already connected.");
      return;
    }
    e.setAttribute("data-camera-controls-version", vf), this._addAllEventListeners(e), this._getClientRect(this._elementRect);
  }
  /**
   * Detach all internal event handlers to disable drag control.
   */
  disconnect() {
    this.cancel(), this._removeAllEventListeners(), this._domElement && (this._domElement.removeAttribute("data-camera-controls-version"), this._domElement = void 0);
  }
  /**
   * Dispose the cameraControls instance itself, remove all eventListeners.
   * @category Methods
   */
  dispose() {
    this.removeAllEventListeners(), this.disconnect();
  }
  // it's okay to expose public though
  _getTargetDirection(e) {
    return e.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);
  }
  // it's okay to expose public though
  _getCameraDirection(e) {
    return this._getTargetDirection(e).negate();
  }
  _findPointerById(e) {
    return this._activePointers.find((t) => t.pointerId === e);
  }
  _findPointerByMouseButton(e) {
    return this._activePointers.find((t) => t.mouseButton === e);
  }
  _disposePointer(e) {
    this._activePointers.splice(this._activePointers.indexOf(e), 1);
  }
  _encloseToBoundary(e, t, n) {
    const s = t.lengthSq();
    if (s === 0)
      return e;
    const i = Le.copy(t).add(e), a = this._boundary.clampPoint(i, On).sub(i), l = a.lengthSq();
    if (l === 0)
      return e.add(t);
    if (l === s)
      return e;
    if (n === 0)
      return e.add(t).add(a);
    {
      const c = 1 + n * l / t.dot(a);
      return e.add(Le.copy(t).multiplyScalar(c)).add(a.multiplyScalar(1 - n));
    }
  }
  _updateNearPlaneCorners() {
    if (gn(this._camera)) {
      const e = this._camera, t = e.near, n = e.getEffectiveFOV() * $n, s = Math.tan(n * 0.5) * t, i = s * e.aspect;
      this._nearPlaneCorners[0].set(-i, -s, 0), this._nearPlaneCorners[1].set(i, -s, 0), this._nearPlaneCorners[2].set(i, s, 0), this._nearPlaneCorners[3].set(-i, s, 0);
    } else if (sn(this._camera)) {
      const e = this._camera, t = 1 / e.zoom, n = e.left * t, s = e.right * t, i = e.top * t, r = e.bottom * t;
      this._nearPlaneCorners[0].set(n, i, 0), this._nearPlaneCorners[1].set(s, i, 0), this._nearPlaneCorners[2].set(s, r, 0), this._nearPlaneCorners[3].set(n, r, 0);
    }
  }
  // lateUpdate
  _collisionTest() {
    let e = 1 / 0;
    if (!(this.colliderMeshes.length >= 1) || bi(this._camera, "_collisionTest"))
      return e;
    const n = this._getTargetDirection(qn);
    Ai.lookAt(oo, n, this._camera.up);
    for (let s = 0; s < 4; s++) {
      const i = Le.copy(this._nearPlaneCorners[s]);
      i.applyMatrix4(Ai);
      const r = On.addVectors(this._target, i);
      Os.set(r, n), Os.far = this._spherical.radius + 1;
      const a = Os.intersectObjects(this.colliderMeshes);
      a.length !== 0 && a[0].distance < e && (e = a[0].distance);
    }
    return e;
  }
  /**
   * Get its client rect and package into given `DOMRect` .
   */
  _getClientRect(e) {
    if (!this._domElement)
      return;
    const t = this._domElement.getBoundingClientRect();
    return e.x = t.left, e.y = t.top, this._viewport ? (e.x += this._viewport.x, e.y += t.height - this._viewport.w - this._viewport.y, e.width = this._viewport.z, e.height = this._viewport.w) : (e.width = t.width, e.height = t.height), e;
  }
  _createOnRestPromise(e) {
    return e ? Promise.resolve() : (this._hasRested = !1, this.dispatchEvent({ type: "transitionstart" }), new Promise((t) => {
      const n = () => {
        this.removeEventListener("rest", n), t();
      };
      this.addEventListener("rest", n);
    }));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _addAllEventListeners(e) {
  }
  _removeAllEventListeners() {
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  get dampingFactor() {
    return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  set dampingFactor(e) {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  get draggingDampingFactor() {
    return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  set draggingDampingFactor(e) {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
  }
  static createBoundingSphere(e, t = new me.Sphere()) {
    const n = t, s = n.center;
    Fn.makeEmpty(), e.traverseVisible((r) => {
      r.isMesh && Fn.expandByObject(r);
    }), Fn.getCenter(s);
    let i = 0;
    return e.traverseVisible((r) => {
      if (!r.isMesh)
        return;
      const a = r, l = a.geometry.clone();
      l.applyMatrix4(a.matrixWorld);
      const u = l.attributes.position;
      for (let h = 0, m = u.count; h < m; h++)
        Ee.fromBufferAttribute(u, h), i = Math.max(i, s.distanceToSquared(Ee));
    }), n.radius = Math.sqrt(i), n;
  }
}
const wf = ["min-polar-angle", "max-polar-angle", "min-azimuth-angle", "max-azimuth-angle", "distance", "min-distance", "max-distance", "infinity-dolly", "min-zoom", "max-zoom", "smooth-time", "dragging-smooth-time", "max-speed", "azimuth-rotate-speed", "polar-rotate-speed", "dolly-speed", "dolly-drag-inverted", "truck-speed", "dolly-to-cursor", "drag-to-offset", "vertical-drag-to-forward", "boundary-friction", "rest-threshold", "collider-meshes", "args"], Jm = /* @__PURE__ */ pe({
  __name: "CameraControls",
  props: {
    makeDefault: { type: Boolean, default: !1 },
    camera: {},
    domElement: {},
    minPolarAngle: { default: 0 },
    maxPolarAngle: { default: Math.PI },
    minAzimuthAngle: { default: -1 / 0 },
    maxAzimuthAngle: { default: 1 / 0 },
    distance: { default: () => je().camera.value.position.z },
    minDistance: { default: Number.EPSILON },
    maxDistance: { default: 1 / 0 },
    infinityDolly: { type: Boolean, default: !1 },
    minZoom: { default: 0.01 },
    maxZoom: { default: 1 / 0 },
    smoothTime: { default: 0.25 },
    draggingSmoothTime: { default: 0.125 },
    maxSpeed: { default: 1 / 0 },
    azimuthRotateSpeed: { default: 1 },
    polarRotateSpeed: { default: 1 },
    dollySpeed: { default: 1 },
    dollyDragInverted: { type: Boolean, default: !1 },
    truckSpeed: { default: 2 },
    dollyToCursor: { type: Boolean, default: !1 },
    dragToOffset: { type: Boolean, default: !1 },
    verticalDragToForward: { type: Boolean, default: !1 },
    boundaryFriction: { default: 0 },
    restThreshold: { default: 0.01 },
    colliderMeshes: { default: () => [] },
    mouseButtons: {},
    touches: {}
  },
  emits: ["change", "start", "end"],
  setup(o, { expose: e, emit: t }) {
    const n = o, s = t, {
      makeDefault: i,
      minPolarAngle: r,
      maxPolarAngle: a,
      minAzimuthAngle: l,
      maxAzimuthAngle: c,
      distance: u,
      minDistance: h,
      maxDistance: m,
      infinityDolly: p,
      minZoom: v,
      maxZoom: _,
      smoothTime: y,
      draggingSmoothTime: E,
      maxSpeed: R,
      azimuthRotateSpeed: T,
      polarRotateSpeed: g,
      dollySpeed: A,
      dollyDragInverted: x,
      truckSpeed: M,
      dollyToCursor: d,
      dragToOffset: w,
      verticalDragToForward: f,
      boundaryFriction: P,
      restThreshold: I,
      colliderMeshes: K
    } = Fe(n), N = {
      Box3: hs,
      MathUtils: {
        clamp: We.clamp
      },
      Matrix4: De,
      Quaternion: He,
      Raycaster: Vo,
      Sphere: Qs,
      Spherical: Ws,
      Vector2: le,
      Vector3: ee,
      Vector4: ht
    };
    ls.install({ THREE: N });
    const { camera: Z, renderer: W, extend: X, controls: V } = je(), ne = ue(null);
    X({ CameraControls: ls }), ft(() => {
      se(), ne.value && i.value ? V.value = ne.value : V.value = null;
    });
    function se() {
      Ve(ne.value, "update", () => s("change", ne.value)), Ve(ne.value, "controlend", () => s("end", ne.value)), Ve(ne.value, "controlstart", () => s("start", ne.value));
    }
    const { onLoop: he } = Ke();
    return he(({ delta: H }) => {
      var k, b;
      (k = ne.value) != null && k.enabled && ((b = ne.value) == null || b.update(H));
    }), ot(() => {
      ne.value && ne.value.disconnect();
    }), e({
      value: ne
    }), (H, k) => (H.camera || z(Z)) && (H.domElement || z(W)) ? (fe(), de("TresCameraControls", {
      key: 0,
      ref_key: "controlsRef",
      ref: ne,
      "min-polar-angle": z(r),
      "max-polar-angle": z(a),
      "min-azimuth-angle": z(l),
      "max-azimuth-angle": z(c),
      distance: z(u),
      "min-distance": z(h),
      "max-distance": z(m),
      "infinity-dolly": z(p),
      "min-zoom": z(v),
      "max-zoom": z(_),
      "smooth-time": z(y),
      "dragging-smooth-time": z(E),
      "max-speed": z(R),
      "azimuth-rotate-speed": z(T),
      "polar-rotate-speed": z(g),
      "dolly-speed": z(A),
      "dolly-drag-inverted": z(x),
      "truck-speed": z(M),
      "dolly-to-cursor": z(d),
      "drag-to-offset": z(w),
      "vertical-drag-to-forward": z(f),
      "boundary-friction": z(P),
      "rest-threshold": z(I),
      "collider-meshes": z(K),
      args: [H.camera || z(Z), H.domElement || z(W).domElement]
    }, null, 8, wf)) : Wt("", !0);
  }
});
class Tf extends us {
  constructor(t = {}) {
    super(t);
    oe(this, "_time");
    oe(this, "_factor");
    this.setValues(t), this._time = { value: 0 }, this._factor = { value: 1 };
  }
  onBeforeCompile(t) {
    t.uniforms || (t.uniforms = {}), t.uniforms.time = this._time, t.uniforms.factor = this._factor, t.vertexShader = `
        uniform float time;
        uniform float factor;
        ${t.vertexShader}
      `, t.vertexShader = t.vertexShader.replace(
      "#include <begin_vertex>",
      `float theta = sin( time + position.y ) / 2.0 * factor;
          float c = cos( theta );
          float s = sin( theta );
          mat3 m = mat3( c, 0, s, 0, 1, 0, -s, 0, c );
          vec3 transformed = vec3( position ) * m;
          vNormal = vNormal * m;`
    );
  }
  get time() {
    return this._time.value;
  }
  set time(t) {
    this._time.value = t;
  }
  get factor() {
    return this._factor.value;
  }
  set factor(t) {
    this._factor.value = t;
  }
}
const bf = ["factor"], eg = /* @__PURE__ */ pe({
  __name: "index",
  props: {
    speed: { default: 1 },
    factor: { default: 1 }
  },
  setup(o) {
    const e = o, t = xe(), { extend: n } = je();
    n({ MeshWobbleMaterial: Tf });
    const { onLoop: s } = Ke();
    return s(({ elapsed: i }) => {
      t.value && (t.value.time = i * (e == null ? void 0 : e.speed));
    }), (i, r) => (fe(), de("TresMeshWobbleMaterial", Ye({
      ref_key: "materialRef",
      ref: t,
      factor: i.factor
    }, i.$attrs), null, 16, bf));
  }
});
function cn(o, e, t) {
  return Math.max(e, Math.min(t, o));
}
function Ef(o, e) {
  return (o % e + e) % e;
}
function Mf(o, e, t, n, s) {
  return n + (o - e) * (s - n) / (t - e);
}
function Pi(o, e, t) {
  return (1 - t) * o + t * e;
}
class yr {
  constructor(e = 0, t = 0) {
    yr.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, n = this.y, s = e.elements;
    return this.x = s[0] * t + s[3] * n + s[6], this.y = s[1] * t + s[4] * n + s[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0)
      return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(cn(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y;
    return t * t + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const n = Math.cos(t), s = Math.sin(t), i = this.x - e.x, r = this.y - e.y;
    return this.x = i * n - r * s + e.x, this.y = i * s + r * n + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
const Sf = "", rn = "srgb", vr = "srgb-linear", Af = "display-p3", Ha = "display-p3-linear", tr = "linear", ho = "srgb", fo = "rec709", po = "p3";
class gs {
  constructor(e, t, n, s, i, r, a, l, c) {
    gs.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, n, s, i, r, a, l, c);
  }
  set(e, t, n, s, i, r, a, l, c) {
    const u = this.elements;
    return u[0] = e, u[1] = s, u[2] = a, u[3] = t, u[4] = i, u[5] = l, u[6] = n, u[7] = r, u[8] = c, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this;
  }
  extractBasis(e, t, n) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements, s = t.elements, i = this.elements, r = n[0], a = n[3], l = n[6], c = n[1], u = n[4], h = n[7], m = n[2], p = n[5], v = n[8], _ = s[0], y = s[3], E = s[6], R = s[1], T = s[4], g = s[7], A = s[2], x = s[5], M = s[8];
    return i[0] = r * _ + a * R + l * A, i[3] = r * y + a * T + l * x, i[6] = r * E + a * g + l * M, i[1] = c * _ + u * R + h * A, i[4] = c * y + u * T + h * x, i[7] = c * E + u * g + h * M, i[2] = m * _ + p * R + v * A, i[5] = m * y + p * T + v * x, i[8] = m * E + p * g + v * M, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], n = e[1], s = e[2], i = e[3], r = e[4], a = e[5], l = e[6], c = e[7], u = e[8];
    return t * r * u - t * a * c - n * i * u + n * a * l + s * i * c - s * r * l;
  }
  invert() {
    const e = this.elements, t = e[0], n = e[1], s = e[2], i = e[3], r = e[4], a = e[5], l = e[6], c = e[7], u = e[8], h = u * r - a * c, m = a * l - u * i, p = c * i - r * l, v = t * h + n * m + s * p;
    if (v === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const _ = 1 / v;
    return e[0] = h * _, e[1] = (s * c - u * n) * _, e[2] = (a * n - s * r) * _, e[3] = m * _, e[4] = (u * t - s * l) * _, e[5] = (s * i - a * t) * _, e[6] = p * _, e[7] = (n * l - c * t) * _, e[8] = (r * t - n * i) * _, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, n, s, i, r, a) {
    const l = Math.cos(i), c = Math.sin(i);
    return this.set(
      n * l,
      n * c,
      -n * (l * r + c * a) + r + e,
      -s * c,
      s * l,
      -s * (-c * r + l * a) + a + t,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, t) {
    return this.premultiply(Ri.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(Ri.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(Ri.makeTranslation(e, t)), this;
  }
  // for 2D Transforms
  makeTranslation(e, t) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      t,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      -n,
      0,
      n,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t) {
    return this.set(
      e,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let s = 0; s < 9; s++)
      if (t[s] !== n[s])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 9; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const Ri = /* @__PURE__ */ new gs(), mo = /* @__PURE__ */ new gs().set(
  0.8224621,
  0.177538,
  0,
  0.0331941,
  0.9668058,
  0,
  0.0170827,
  0.0723974,
  0.9105199
), go = /* @__PURE__ */ new gs().set(
  1.2249401,
  -0.2249404,
  0,
  -0.0420569,
  1.0420571,
  0,
  -0.0196376,
  -0.0786361,
  1.0982735
), Fs = {
  [vr]: {
    transfer: tr,
    primaries: fo,
    toReference: (o) => o,
    fromReference: (o) => o
  },
  [rn]: {
    transfer: ho,
    primaries: fo,
    toReference: (o) => o.convertSRGBToLinear(),
    fromReference: (o) => o.convertLinearToSRGB()
  },
  [Ha]: {
    transfer: tr,
    primaries: po,
    toReference: (o) => o.applyMatrix3(go),
    fromReference: (o) => o.applyMatrix3(mo)
  },
  [Af]: {
    transfer: ho,
    primaries: po,
    toReference: (o) => o.convertSRGBToLinear().applyMatrix3(go),
    fromReference: (o) => o.applyMatrix3(mo).convertLinearToSRGB()
  }
}, Pf = /* @__PURE__ */ new Set([vr, Ha]), Tt = {
  enabled: !0,
  _workingColorSpace: vr,
  get workingColorSpace() {
    return this._workingColorSpace;
  },
  set workingColorSpace(o) {
    if (!Pf.has(o))
      throw new Error(`Unsupported working color space, "${o}".`);
    this._workingColorSpace = o;
  },
  convert: function(o, e, t) {
    if (this.enabled === !1 || e === t || !e || !t)
      return o;
    const n = Fs[e].toReference, s = Fs[t].fromReference;
    return s(n(o));
  },
  fromWorkingColorSpace: function(o, e) {
    return this.convert(o, this._workingColorSpace, e);
  },
  toWorkingColorSpace: function(o, e) {
    return this.convert(o, e, this._workingColorSpace);
  },
  getPrimaries: function(o) {
    return Fs[o].primaries;
  },
  getTransfer: function(o) {
    return o === Sf ? tr : Fs[o].transfer;
  }
};
function Ci(o) {
  return o < 0.04045 ? o * 0.0773993808 : Math.pow(o * 0.9478672986 + 0.0521327014, 2.4);
}
function Ii(o) {
  return o < 31308e-7 ? o * 12.92 : 1.055 * Math.pow(o, 0.41666) - 0.055;
}
const Ga = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, Jt = { h: 0, s: 0, l: 0 }, ks = { h: 0, s: 0, l: 0 };
function Di(o, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? o + (e - o) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? o + (e - o) * 6 * (2 / 3 - t) : o;
}
class Zs {
  constructor(e, t, n) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n);
  }
  set(e, t, n) {
    if (t === void 0 && n === void 0) {
      const s = e;
      s && s.isColor ? this.copy(s) : typeof s == "number" ? this.setHex(s) : typeof s == "string" && this.setStyle(s);
    } else
      this.setRGB(e, t, n);
    return this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, t = rn) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Tt.toWorkingColorSpace(this, t), this;
  }
  setRGB(e, t, n, s = Tt.workingColorSpace) {
    return this.r = e, this.g = t, this.b = n, Tt.toWorkingColorSpace(this, s), this;
  }
  setHSL(e, t, n, s = Tt.workingColorSpace) {
    if (e = Ef(e, 1), t = cn(t, 0, 1), n = cn(n, 0, 1), t === 0)
      this.r = this.g = this.b = n;
    else {
      const i = n <= 0.5 ? n * (1 + t) : n + t - n * t, r = 2 * n - i;
      this.r = Di(r, i, e + 1 / 3), this.g = Di(r, i, e), this.b = Di(r, i, e - 1 / 3);
    }
    return Tt.toWorkingColorSpace(this, s), this;
  }
  setStyle(e, t = rn) {
    function n(i) {
      i !== void 0 && parseFloat(i) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let s;
    if (s = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let i;
      const r = s[1], a = s[2];
      switch (r) {
        case "rgb":
        case "rgba":
          if (i = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return n(i[4]), this.setRGB(
              Math.min(255, parseInt(i[1], 10)) / 255,
              Math.min(255, parseInt(i[2], 10)) / 255,
              Math.min(255, parseInt(i[3], 10)) / 255,
              t
            );
          if (i = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return n(i[4]), this.setRGB(
              Math.min(100, parseInt(i[1], 10)) / 100,
              Math.min(100, parseInt(i[2], 10)) / 100,
              Math.min(100, parseInt(i[3], 10)) / 100,
              t
            );
          break;
        case "hsl":
        case "hsla":
          if (i = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return n(i[4]), this.setHSL(
              parseFloat(i[1]) / 360,
              parseFloat(i[2]) / 100,
              parseFloat(i[3]) / 100,
              t
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (s = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const i = s[1], r = i.length;
      if (r === 3)
        return this.setRGB(
          parseInt(i.charAt(0), 16) / 15,
          parseInt(i.charAt(1), 16) / 15,
          parseInt(i.charAt(2), 16) / 15,
          t
        );
      if (r === 6)
        return this.setHex(parseInt(i, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = rn) {
    const n = Ga[e.toLowerCase()];
    return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = Ci(e.r), this.g = Ci(e.g), this.b = Ci(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = Ii(e.r), this.g = Ii(e.g), this.b = Ii(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = rn) {
    return Tt.fromWorkingColorSpace(st.copy(this), e), Math.round(cn(st.r * 255, 0, 255)) * 65536 + Math.round(cn(st.g * 255, 0, 255)) * 256 + Math.round(cn(st.b * 255, 0, 255));
  }
  getHexString(e = rn) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = Tt.workingColorSpace) {
    Tt.fromWorkingColorSpace(st.copy(this), t);
    const n = st.r, s = st.g, i = st.b, r = Math.max(n, s, i), a = Math.min(n, s, i);
    let l, c;
    const u = (a + r) / 2;
    if (a === r)
      l = 0, c = 0;
    else {
      const h = r - a;
      switch (c = u <= 0.5 ? h / (r + a) : h / (2 - r - a), r) {
        case n:
          l = (s - i) / h + (s < i ? 6 : 0);
          break;
        case s:
          l = (i - n) / h + 2;
          break;
        case i:
          l = (n - s) / h + 4;
          break;
      }
      l /= 6;
    }
    return e.h = l, e.s = c, e.l = u, e;
  }
  getRGB(e, t = Tt.workingColorSpace) {
    return Tt.fromWorkingColorSpace(st.copy(this), t), e.r = st.r, e.g = st.g, e.b = st.b, e;
  }
  getStyle(e = rn) {
    Tt.fromWorkingColorSpace(st.copy(this), e);
    const t = st.r, n = st.g, s = st.b;
    return e !== rn ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${s.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(s * 255)})`;
  }
  offsetHSL(e, t, n) {
    return this.getHSL(Jt), this.setHSL(Jt.h + e, Jt.s + t, Jt.l + n);
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  lerpColors(e, t, n) {
    return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this;
  }
  lerpHSL(e, t) {
    this.getHSL(Jt), e.getHSL(ks);
    const n = Pi(Jt.h, ks.h, t), s = Pi(Jt.s, ks.s, t), i = Pi(Jt.l, ks.l, t);
    return this.setHSL(n, s, i), this;
  }
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  applyMatrix3(e) {
    const t = this.r, n = this.g, s = this.b, i = e.elements;
    return this.r = i[0] * t + i[3] * n + i[6] * s, this.g = i[1] * t + i[4] * n + i[7] * s, this.b = i[2] * t + i[5] * n + i[8] * s, this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const st = /* @__PURE__ */ new Zs();
Zs.NAMES = Ga;
class Rf extends us {
  constructor(t = {}) {
    super();
    oe(this, "isMeshPhysicalMaterial");
    oe(this, "clearcoatMap");
    oe(this, "clearcoatRoughness");
    oe(this, "clearcoatRoughnessMap");
    oe(this, "clearcoatNormalScale");
    oe(this, "clearcoatNormalMap");
    oe(this, "ior");
    oe(this, "transmissionMap");
    oe(this, "thickness");
    oe(this, "thicknessMap");
    oe(this, "attenuationDistance");
    oe(this, "attenuationColor");
    oe(this, "specularIntensity");
    oe(this, "specularIntensityMap");
    oe(this, "specularColor");
    oe(this, "specularColorMap");
    oe(this, "_clearcoat");
    oe(this, "_transmission");
    this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new yr(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get() {
        return cn(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set(n) {
        this.ior = (1 + 0.4 * n) / (1 - 0.4 * n);
      }
    }), this.roughness = 0, this.transmissionMap = null, this.thickness = 0.5, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Zs(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Zs(1, 1, 1), this.specularColorMap = null, this._clearcoat = 0.5, this._transmission = 1, this.setValues(t);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(t) {
    this._clearcoat > 0 != t > 0 && this.version++, this._clearcoat = t;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(t) {
    this._transmission > 0 != t > 0 && this.version++, this._transmission = t;
  }
  copy(t) {
    return super.copy(t), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.ior = t.ior, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this;
  }
}
const Cf = Rf, tg = /* @__PURE__ */ pe({
  __name: "index",
  setup(o, { expose: e }) {
    const t = xe(), { extend: n } = je();
    return n({ MeshGlassMaterial: Cf }), e({ MeshGlassMaterialClass: t }), (s, i) => (fe(), de("TresMeshGlassMaterial", {
      ref_key: "MeshGlassMaterialClass",
      ref: t
    }, null, 512));
  }
});
var If = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ys(o) {
  return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") ? o.default : o;
}
function Us(o) {
  throw new Error('Could not dynamically require "' + o + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var ja = { exports: {} };
(function(o, e) {
  (function(t) {
    o.exports = t();
  })(function() {
    return function t(n, s, i) {
      function r(c, u) {
        if (!s[c]) {
          if (!n[c]) {
            var h = typeof Us == "function" && Us;
            if (!u && h)
              return h(c, !0);
            if (a)
              return a(c, !0);
            throw new Error("Cannot find module '" + c + "'");
          }
          u = s[c] = { exports: {} }, n[c][0].call(u.exports, function(m) {
            var p = n[c][1][m];
            return r(p || m);
          }, u, u.exports, t, n, s, i);
        }
        return s[c].exports;
      }
      for (var a = typeof Us == "function" && Us, l = 0; l < i.length; l++)
        r(i[l]);
      return r;
    }({ 1: [function(t, n, s) {
      (function(i, r, a, l, c, u, h, m, p) {
        var v = t("crypto");
        function _(x, M) {
          M = R(x, M);
          var d;
          return (d = M.algorithm !== "passthrough" ? v.createHash(M.algorithm) : new A()).write === void 0 && (d.write = d.update, d.end = d.update), g(M, d).dispatch(x), d.update || d.end(""), d.digest ? d.digest(M.encoding === "buffer" ? void 0 : M.encoding) : (x = d.read(), M.encoding !== "buffer" ? x.toString(M.encoding) : x);
        }
        (s = n.exports = _).sha1 = function(x) {
          return _(x);
        }, s.keys = function(x) {
          return _(x, { excludeValues: !0, algorithm: "sha1", encoding: "hex" });
        }, s.MD5 = function(x) {
          return _(x, { algorithm: "md5", encoding: "hex" });
        }, s.keysMD5 = function(x) {
          return _(x, { algorithm: "md5", encoding: "hex", excludeValues: !0 });
        };
        var y = v.getHashes ? v.getHashes().slice() : ["sha1", "md5"], E = (y.push("passthrough"), ["buffer", "hex", "binary", "base64"]);
        function R(x, M) {
          var d = {};
          if (d.algorithm = (M = M || {}).algorithm || "sha1", d.encoding = M.encoding || "hex", d.excludeValues = !!M.excludeValues, d.algorithm = d.algorithm.toLowerCase(), d.encoding = d.encoding.toLowerCase(), d.ignoreUnknown = M.ignoreUnknown === !0, d.respectType = M.respectType !== !1, d.respectFunctionNames = M.respectFunctionNames !== !1, d.respectFunctionProperties = M.respectFunctionProperties !== !1, d.unorderedArrays = M.unorderedArrays === !0, d.unorderedSets = M.unorderedSets !== !1, d.unorderedObjects = M.unorderedObjects !== !1, d.replacer = M.replacer || void 0, d.excludeKeys = M.excludeKeys || void 0, x === void 0)
            throw new Error("Object argument required.");
          for (var w = 0; w < y.length; ++w)
            y[w].toLowerCase() === d.algorithm.toLowerCase() && (d.algorithm = y[w]);
          if (y.indexOf(d.algorithm) === -1)
            throw new Error('Algorithm "' + d.algorithm + '"  not supported. supported values: ' + y.join(", "));
          if (E.indexOf(d.encoding) === -1 && d.algorithm !== "passthrough")
            throw new Error('Encoding "' + d.encoding + '"  not supported. supported values: ' + E.join(", "));
          return d;
        }
        function T(x) {
          if (typeof x == "function")
            return /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(x)) != null;
        }
        function g(x, M, d) {
          d = d || [];
          function w(f) {
            return M.update ? M.update(f, "utf8") : M.write(f, "utf8");
          }
          return { dispatch: function(f) {
            return this["_" + ((f = x.replacer ? x.replacer(f) : f) === null ? "null" : typeof f)](f);
          }, _object: function(f) {
            var P, I = Object.prototype.toString.call(f), K = /\[object (.*)\]/i.exec(I);
            if (K = (K = K ? K[1] : "unknown:[" + I + "]").toLowerCase(), 0 <= (I = d.indexOf(f)))
              return this.dispatch("[CIRCULAR:" + I + "]");
            if (d.push(f), a !== void 0 && a.isBuffer && a.isBuffer(f))
              return w("buffer:"), w(f);
            if (K === "object" || K === "function" || K === "asyncfunction")
              return I = Object.keys(f), x.unorderedObjects && (I = I.sort()), x.respectType === !1 || T(f) || I.splice(0, 0, "prototype", "__proto__", "constructor"), x.excludeKeys && (I = I.filter(function(N) {
                return !x.excludeKeys(N);
              })), w("object:" + I.length + ":"), P = this, I.forEach(function(N) {
                P.dispatch(N), w(":"), x.excludeValues || P.dispatch(f[N]), w(",");
              });
            if (!this["_" + K]) {
              if (x.ignoreUnknown)
                return w("[" + K + "]");
              throw new Error('Unknown object type "' + K + '"');
            }
            this["_" + K](f);
          }, _array: function(f, N) {
            N = N !== void 0 ? N : x.unorderedArrays !== !1;
            var I = this;
            if (w("array:" + f.length + ":"), !N || f.length <= 1)
              return f.forEach(function(Z) {
                return I.dispatch(Z);
              });
            var K = [], N = f.map(function(Z) {
              var W = new A(), X = d.slice();
              return g(x, W, X).dispatch(Z), K = K.concat(X.slice(d.length)), W.read().toString();
            });
            return d = d.concat(K), N.sort(), this._array(N, !1);
          }, _date: function(f) {
            return w("date:" + f.toJSON());
          }, _symbol: function(f) {
            return w("symbol:" + f.toString());
          }, _error: function(f) {
            return w("error:" + f.toString());
          }, _boolean: function(f) {
            return w("bool:" + f.toString());
          }, _string: function(f) {
            w("string:" + f.length + ":"), w(f.toString());
          }, _function: function(f) {
            w("fn:"), T(f) ? this.dispatch("[native]") : this.dispatch(f.toString()), x.respectFunctionNames !== !1 && this.dispatch("function-name:" + String(f.name)), x.respectFunctionProperties && this._object(f);
          }, _number: function(f) {
            return w("number:" + f.toString());
          }, _xml: function(f) {
            return w("xml:" + f.toString());
          }, _null: function() {
            return w("Null");
          }, _undefined: function() {
            return w("Undefined");
          }, _regexp: function(f) {
            return w("regex:" + f.toString());
          }, _uint8array: function(f) {
            return w("uint8array:"), this.dispatch(Array.prototype.slice.call(f));
          }, _uint8clampedarray: function(f) {
            return w("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(f));
          }, _int8array: function(f) {
            return w("int8array:"), this.dispatch(Array.prototype.slice.call(f));
          }, _uint16array: function(f) {
            return w("uint16array:"), this.dispatch(Array.prototype.slice.call(f));
          }, _int16array: function(f) {
            return w("int16array:"), this.dispatch(Array.prototype.slice.call(f));
          }, _uint32array: function(f) {
            return w("uint32array:"), this.dispatch(Array.prototype.slice.call(f));
          }, _int32array: function(f) {
            return w("int32array:"), this.dispatch(Array.prototype.slice.call(f));
          }, _float32array: function(f) {
            return w("float32array:"), this.dispatch(Array.prototype.slice.call(f));
          }, _float64array: function(f) {
            return w("float64array:"), this.dispatch(Array.prototype.slice.call(f));
          }, _arraybuffer: function(f) {
            return w("arraybuffer:"), this.dispatch(new Uint8Array(f));
          }, _url: function(f) {
            return w("url:" + f.toString());
          }, _map: function(f) {
            return w("map:"), f = Array.from(f), this._array(f, x.unorderedSets !== !1);
          }, _set: function(f) {
            return w("set:"), f = Array.from(f), this._array(f, x.unorderedSets !== !1);
          }, _file: function(f) {
            return w("file:"), this.dispatch([f.name, f.size, f.type, f.lastModfied]);
          }, _blob: function() {
            if (x.ignoreUnknown)
              return w("[blob]");
            throw Error(`Hashing Blob objects is currently not supported
(see https://github.com/puleos/object-hash/issues/26)
Use "options.replacer" or "options.ignoreUnknown"
`);
          }, _domwindow: function() {
            return w("domwindow");
          }, _bigint: function(f) {
            return w("bigint:" + f.toString());
          }, _process: function() {
            return w("process");
          }, _timer: function() {
            return w("timer");
          }, _pipe: function() {
            return w("pipe");
          }, _tcp: function() {
            return w("tcp");
          }, _udp: function() {
            return w("udp");
          }, _tty: function() {
            return w("tty");
          }, _statwatcher: function() {
            return w("statwatcher");
          }, _securecontext: function() {
            return w("securecontext");
          }, _connection: function() {
            return w("connection");
          }, _zlib: function() {
            return w("zlib");
          }, _context: function() {
            return w("context");
          }, _nodescript: function() {
            return w("nodescript");
          }, _httpparser: function() {
            return w("httpparser");
          }, _dataview: function() {
            return w("dataview");
          }, _signal: function() {
            return w("signal");
          }, _fsevent: function() {
            return w("fsevent");
          }, _tlswrap: function() {
            return w("tlswrap");
          } };
        }
        function A() {
          return { buf: "", write: function(x) {
            this.buf += x;
          }, end: function(x) {
            this.buf += x;
          }, read: function() {
            return this.buf;
          } };
        }
        s.writeToStream = function(x, M, d) {
          return d === void 0 && (d = M, M = {}), g(M = R(x, M), d).dispatch(x);
        };
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_9a5aa49d.js", "/");
    }, { buffer: 3, crypto: 5, lYpoI2: 11 }], 2: [function(t, n, s) {
      (function(i, r, a, l, c, u, h, m, p) {
        (function(v) {
          var _ = typeof Uint8Array < "u" ? Uint8Array : Array, y = 43, E = 47, R = 48, T = 97, g = 65, A = 45, x = 95;
          function M(d) {
            return d = d.charCodeAt(0), d === y || d === A ? 62 : d === E || d === x ? 63 : d < R ? -1 : d < R + 10 ? d - R + 26 + 26 : d < g + 26 ? d - g : d < T + 26 ? d - T + 26 : void 0;
          }
          v.toByteArray = function(d) {
            var w, f;
            if (0 < d.length % 4)
              throw new Error("Invalid string. Length must be a multiple of 4");
            var P = d.length, P = d.charAt(P - 2) === "=" ? 2 : d.charAt(P - 1) === "=" ? 1 : 0, I = new _(3 * d.length / 4 - P), K = 0 < P ? d.length - 4 : d.length, N = 0;
            function Z(W) {
              I[N++] = W;
            }
            for (w = 0; w < K; w += 4, 0)
              Z((16711680 & (f = M(d.charAt(w)) << 18 | M(d.charAt(w + 1)) << 12 | M(d.charAt(w + 2)) << 6 | M(d.charAt(w + 3)))) >> 16), Z((65280 & f) >> 8), Z(255 & f);
            return P == 2 ? Z(255 & (f = M(d.charAt(w)) << 2 | M(d.charAt(w + 1)) >> 4)) : P == 1 && (Z((f = M(d.charAt(w)) << 10 | M(d.charAt(w + 1)) << 4 | M(d.charAt(w + 2)) >> 2) >> 8 & 255), Z(255 & f)), I;
          }, v.fromByteArray = function(d) {
            var w, f, P, I, K = d.length % 3, N = "";
            function Z(W) {
              return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(W);
            }
            for (w = 0, P = d.length - K; w < P; w += 3)
              f = (d[w] << 16) + (d[w + 1] << 8) + d[w + 2], N += Z((I = f) >> 18 & 63) + Z(I >> 12 & 63) + Z(I >> 6 & 63) + Z(63 & I);
            switch (K) {
              case 1:
                N = (N += Z((f = d[d.length - 1]) >> 2)) + Z(f << 4 & 63) + "==";
                break;
              case 2:
                N = (N = (N += Z((f = (d[d.length - 2] << 8) + d[d.length - 1]) >> 10)) + Z(f >> 4 & 63)) + Z(f << 2 & 63) + "=";
            }
            return N;
          };
        })(s === void 0 ? this.base64js = {} : s);
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib");
    }, { buffer: 3, lYpoI2: 11 }], 3: [function(t, n, s) {
      (function(i, r, y, l, c, u, h, m, p) {
        var v = t("base64-js"), _ = t("ieee754");
        function y(S, C, D) {
          if (!(this instanceof y))
            return new y(S, C, D);
          var G, $, Y, te, O = typeof S;
          if (C === "base64" && O == "string")
            for (S = (te = S).trim ? te.trim() : te.replace(/^\s+|\s+$/g, ""); S.length % 4 != 0; )
              S += "=";
          if (O == "number")
            G = V(S);
          else if (O == "string")
            G = y.byteLength(S, C);
          else {
            if (O != "object")
              throw new Error("First argument needs to be a number, array or string.");
            G = V(S.length);
          }
          if (y._useTypedArrays ? $ = y._augment(new Uint8Array(G)) : (($ = this).length = G, $._isBuffer = !0), y._useTypedArrays && typeof S.byteLength == "number")
            $._set(S);
          else if (ne(te = S) || y.isBuffer(te) || te && typeof te == "object" && typeof te.length == "number")
            for (Y = 0; Y < G; Y++)
              y.isBuffer(S) ? $[Y] = S.readUInt8(Y) : $[Y] = S[Y];
          else if (O == "string")
            $.write(S, 0, C);
          else if (O == "number" && !y._useTypedArrays && !D)
            for (Y = 0; Y < G; Y++)
              $[Y] = 0;
          return $;
        }
        function E(S, C, D, G) {
          return y._charsWritten = k(function($) {
            for (var Y = [], te = 0; te < $.length; te++)
              Y.push(255 & $.charCodeAt(te));
            return Y;
          }(C), S, D, G);
        }
        function R(S, C, D, G) {
          return y._charsWritten = k(function($) {
            for (var Y, te, O = [], L = 0; L < $.length; L++)
              te = $.charCodeAt(L), Y = te >> 8, te = te % 256, O.push(te), O.push(Y);
            return O;
          }(C), S, D, G);
        }
        function T(S, C, D) {
          var G = "";
          D = Math.min(S.length, D);
          for (var $ = C; $ < D; $++)
            G += String.fromCharCode(S[$]);
          return G;
        }
        function g(S, C, D, Y) {
          Y || (B(typeof D == "boolean", "missing or invalid endian"), B(C != null, "missing offset"), B(C + 1 < S.length, "Trying to read beyond buffer length"));
          var $, Y = S.length;
          if (!(Y <= C))
            return D ? ($ = S[C], C + 1 < Y && ($ |= S[C + 1] << 8)) : ($ = S[C] << 8, C + 1 < Y && ($ |= S[C + 1])), $;
        }
        function A(S, C, D, Y) {
          Y || (B(typeof D == "boolean", "missing or invalid endian"), B(C != null, "missing offset"), B(C + 3 < S.length, "Trying to read beyond buffer length"));
          var $, Y = S.length;
          if (!(Y <= C))
            return D ? (C + 2 < Y && ($ = S[C + 2] << 16), C + 1 < Y && ($ |= S[C + 1] << 8), $ |= S[C], C + 3 < Y && ($ += S[C + 3] << 24 >>> 0)) : (C + 1 < Y && ($ = S[C + 1] << 16), C + 2 < Y && ($ |= S[C + 2] << 8), C + 3 < Y && ($ |= S[C + 3]), $ += S[C] << 24 >>> 0), $;
        }
        function x(S, C, D, G) {
          if (G || (B(typeof D == "boolean", "missing or invalid endian"), B(C != null, "missing offset"), B(C + 1 < S.length, "Trying to read beyond buffer length")), !(S.length <= C))
            return G = g(S, C, D, !0), 32768 & G ? -1 * (65535 - G + 1) : G;
        }
        function M(S, C, D, G) {
          if (G || (B(typeof D == "boolean", "missing or invalid endian"), B(C != null, "missing offset"), B(C + 3 < S.length, "Trying to read beyond buffer length")), !(S.length <= C))
            return G = A(S, C, D, !0), 2147483648 & G ? -1 * (4294967295 - G + 1) : G;
        }
        function d(S, C, D, G) {
          return G || (B(typeof D == "boolean", "missing or invalid endian"), B(C + 3 < S.length, "Trying to read beyond buffer length")), _.read(S, C, D, 23, 4);
        }
        function w(S, C, D, G) {
          return G || (B(typeof D == "boolean", "missing or invalid endian"), B(C + 7 < S.length, "Trying to read beyond buffer length")), _.read(S, C, D, 52, 8);
        }
        function f(S, C, D, G, $) {
          if ($ || (B(C != null, "missing value"), B(typeof G == "boolean", "missing or invalid endian"), B(D != null, "missing offset"), B(D + 1 < S.length, "trying to write beyond buffer length"), U(C, 65535)), $ = S.length, !($ <= D))
            for (var Y = 0, te = Math.min($ - D, 2); Y < te; Y++)
              S[D + Y] = (C & 255 << 8 * (G ? Y : 1 - Y)) >>> 8 * (G ? Y : 1 - Y);
        }
        function P(S, C, D, G, $) {
          if ($ || (B(C != null, "missing value"), B(typeof G == "boolean", "missing or invalid endian"), B(D != null, "missing offset"), B(D + 3 < S.length, "trying to write beyond buffer length"), U(C, 4294967295)), $ = S.length, !($ <= D))
            for (var Y = 0, te = Math.min($ - D, 4); Y < te; Y++)
              S[D + Y] = C >>> 8 * (G ? Y : 3 - Y) & 255;
        }
        function I(S, C, D, G, $) {
          $ || (B(C != null, "missing value"), B(typeof G == "boolean", "missing or invalid endian"), B(D != null, "missing offset"), B(D + 1 < S.length, "Trying to write beyond buffer length"), J(C, 32767, -32768)), S.length <= D || f(S, 0 <= C ? C : 65535 + C + 1, D, G, $);
        }
        function K(S, C, D, G, $) {
          $ || (B(C != null, "missing value"), B(typeof G == "boolean", "missing or invalid endian"), B(D != null, "missing offset"), B(D + 3 < S.length, "Trying to write beyond buffer length"), J(C, 2147483647, -2147483648)), S.length <= D || P(S, 0 <= C ? C : 4294967295 + C + 1, D, G, $);
        }
        function N(S, C, D, G, $) {
          $ || (B(C != null, "missing value"), B(typeof G == "boolean", "missing or invalid endian"), B(D != null, "missing offset"), B(D + 3 < S.length, "Trying to write beyond buffer length"), F(C, 34028234663852886e22, -34028234663852886e22)), S.length <= D || _.write(S, C, D, G, 23, 4);
        }
        function Z(S, C, D, G, $) {
          $ || (B(C != null, "missing value"), B(typeof G == "boolean", "missing or invalid endian"), B(D != null, "missing offset"), B(D + 7 < S.length, "Trying to write beyond buffer length"), F(C, 17976931348623157e292, -17976931348623157e292)), S.length <= D || _.write(S, C, D, G, 52, 8);
        }
        s.Buffer = y, s.SlowBuffer = y, s.INSPECT_MAX_BYTES = 50, y.poolSize = 8192, y._useTypedArrays = function() {
          try {
            var S = new ArrayBuffer(0), C = new Uint8Array(S);
            return C.foo = function() {
              return 42;
            }, C.foo() === 42 && typeof C.subarray == "function";
          } catch {
            return !1;
          }
        }(), y.isEncoding = function(S) {
          switch (String(S).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "raw":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return !0;
            default:
              return !1;
          }
        }, y.isBuffer = function(S) {
          return !(S == null || !S._isBuffer);
        }, y.byteLength = function(S, C) {
          var D;
          switch (S += "", C || "utf8") {
            case "hex":
              D = S.length / 2;
              break;
            case "utf8":
            case "utf-8":
              D = he(S).length;
              break;
            case "ascii":
            case "binary":
            case "raw":
              D = S.length;
              break;
            case "base64":
              D = H(S).length;
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              D = 2 * S.length;
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return D;
        }, y.concat = function(S, C) {
          if (B(ne(S), `Usage: Buffer.concat(list, [totalLength])
list should be an Array.`), S.length === 0)
            return new y(0);
          if (S.length === 1)
            return S[0];
          if (typeof C != "number")
            for ($ = C = 0; $ < S.length; $++)
              C += S[$].length;
          for (var D = new y(C), G = 0, $ = 0; $ < S.length; $++) {
            var Y = S[$];
            Y.copy(D, G), G += Y.length;
          }
          return D;
        }, y.prototype.write = function(S, C, D, G) {
          isFinite(C) ? isFinite(D) || (G = D, D = void 0) : (L = G, G = C, C = D, D = L), C = Number(C) || 0;
          var $, Y, te, O, L = this.length - C;
          switch ((!D || L < (D = Number(D))) && (D = L), G = String(G || "utf8").toLowerCase()) {
            case "hex":
              $ = function(re, ce, be, Me) {
                be = Number(be) || 0;
                var Se = re.length - be;
                (!Me || Se < (Me = Number(Me))) && (Me = Se), B((Se = ce.length) % 2 == 0, "Invalid hex string"), Se / 2 < Me && (Me = Se / 2);
                for (var qe = 0; qe < Me; qe++) {
                  var kt = parseInt(ce.substr(2 * qe, 2), 16);
                  B(!isNaN(kt), "Invalid hex string"), re[be + qe] = kt;
                }
                return y._charsWritten = 2 * qe, qe;
              }(this, S, C, D);
              break;
            case "utf8":
            case "utf-8":
              Y = this, te = C, O = D, $ = y._charsWritten = k(he(S), Y, te, O);
              break;
            case "ascii":
            case "binary":
              $ = E(this, S, C, D);
              break;
            case "base64":
              Y = this, te = C, O = D, $ = y._charsWritten = k(H(S), Y, te, O);
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              $ = R(this, S, C, D);
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return $;
        }, y.prototype.toString = function(S, C, D) {
          var G, $, Y, te, O = this;
          if (S = String(S || "utf8").toLowerCase(), C = Number(C) || 0, (D = D !== void 0 ? Number(D) : O.length) === C)
            return "";
          switch (S) {
            case "hex":
              G = function(L, re, ce) {
                var be = L.length;
                (!re || re < 0) && (re = 0), (!ce || ce < 0 || be < ce) && (ce = be);
                for (var Me = "", Se = re; Se < ce; Se++)
                  Me += se(L[Se]);
                return Me;
              }(O, C, D);
              break;
            case "utf8":
            case "utf-8":
              G = function(L, re, ce) {
                var be = "", Me = "";
                ce = Math.min(L.length, ce);
                for (var Se = re; Se < ce; Se++)
                  L[Se] <= 127 ? (be += b(Me) + String.fromCharCode(L[Se]), Me = "") : Me += "%" + L[Se].toString(16);
                return be + b(Me);
              }(O, C, D);
              break;
            case "ascii":
            case "binary":
              G = T(O, C, D);
              break;
            case "base64":
              $ = O, te = D, G = (Y = C) === 0 && te === $.length ? v.fromByteArray($) : v.fromByteArray($.slice(Y, te));
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              G = function(L, re, ce) {
                for (var be = L.slice(re, ce), Me = "", Se = 0; Se < be.length; Se += 2)
                  Me += String.fromCharCode(be[Se] + 256 * be[Se + 1]);
                return Me;
              }(O, C, D);
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return G;
        }, y.prototype.toJSON = function() {
          return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
        }, y.prototype.copy = function(S, C, D, G) {
          if (C = C || 0, (G = G || G === 0 ? G : this.length) !== (D = D || 0) && S.length !== 0 && this.length !== 0) {
            B(D <= G, "sourceEnd < sourceStart"), B(0 <= C && C < S.length, "targetStart out of bounds"), B(0 <= D && D < this.length, "sourceStart out of bounds"), B(0 <= G && G <= this.length, "sourceEnd out of bounds"), G > this.length && (G = this.length);
            var $ = (G = S.length - C < G - D ? S.length - C + D : G) - D;
            if ($ < 100 || !y._useTypedArrays)
              for (var Y = 0; Y < $; Y++)
                S[Y + C] = this[Y + D];
            else
              S._set(this.subarray(D, D + $), C);
          }
        }, y.prototype.slice = function(S, C) {
          var D = this.length;
          if (S = X(S, D, 0), C = X(C, D, D), y._useTypedArrays)
            return y._augment(this.subarray(S, C));
          for (var G = C - S, $ = new y(G, void 0, !0), Y = 0; Y < G; Y++)
            $[Y] = this[Y + S];
          return $;
        }, y.prototype.get = function(S) {
          return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(S);
        }, y.prototype.set = function(S, C) {
          return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(S, C);
        }, y.prototype.readUInt8 = function(S, C) {
          if (C || (B(S != null, "missing offset"), B(S < this.length, "Trying to read beyond buffer length")), !(S >= this.length))
            return this[S];
        }, y.prototype.readUInt16LE = function(S, C) {
          return g(this, S, !0, C);
        }, y.prototype.readUInt16BE = function(S, C) {
          return g(this, S, !1, C);
        }, y.prototype.readUInt32LE = function(S, C) {
          return A(this, S, !0, C);
        }, y.prototype.readUInt32BE = function(S, C) {
          return A(this, S, !1, C);
        }, y.prototype.readInt8 = function(S, C) {
          if (C || (B(S != null, "missing offset"), B(S < this.length, "Trying to read beyond buffer length")), !(S >= this.length))
            return 128 & this[S] ? -1 * (255 - this[S] + 1) : this[S];
        }, y.prototype.readInt16LE = function(S, C) {
          return x(this, S, !0, C);
        }, y.prototype.readInt16BE = function(S, C) {
          return x(this, S, !1, C);
        }, y.prototype.readInt32LE = function(S, C) {
          return M(this, S, !0, C);
        }, y.prototype.readInt32BE = function(S, C) {
          return M(this, S, !1, C);
        }, y.prototype.readFloatLE = function(S, C) {
          return d(this, S, !0, C);
        }, y.prototype.readFloatBE = function(S, C) {
          return d(this, S, !1, C);
        }, y.prototype.readDoubleLE = function(S, C) {
          return w(this, S, !0, C);
        }, y.prototype.readDoubleBE = function(S, C) {
          return w(this, S, !1, C);
        }, y.prototype.writeUInt8 = function(S, C, D) {
          D || (B(S != null, "missing value"), B(C != null, "missing offset"), B(C < this.length, "trying to write beyond buffer length"), U(S, 255)), C >= this.length || (this[C] = S);
        }, y.prototype.writeUInt16LE = function(S, C, D) {
          f(this, S, C, !0, D);
        }, y.prototype.writeUInt16BE = function(S, C, D) {
          f(this, S, C, !1, D);
        }, y.prototype.writeUInt32LE = function(S, C, D) {
          P(this, S, C, !0, D);
        }, y.prototype.writeUInt32BE = function(S, C, D) {
          P(this, S, C, !1, D);
        }, y.prototype.writeInt8 = function(S, C, D) {
          D || (B(S != null, "missing value"), B(C != null, "missing offset"), B(C < this.length, "Trying to write beyond buffer length"), J(S, 127, -128)), C >= this.length || (0 <= S ? this.writeUInt8(S, C, D) : this.writeUInt8(255 + S + 1, C, D));
        }, y.prototype.writeInt16LE = function(S, C, D) {
          I(this, S, C, !0, D);
        }, y.prototype.writeInt16BE = function(S, C, D) {
          I(this, S, C, !1, D);
        }, y.prototype.writeInt32LE = function(S, C, D) {
          K(this, S, C, !0, D);
        }, y.prototype.writeInt32BE = function(S, C, D) {
          K(this, S, C, !1, D);
        }, y.prototype.writeFloatLE = function(S, C, D) {
          N(this, S, C, !0, D);
        }, y.prototype.writeFloatBE = function(S, C, D) {
          N(this, S, C, !1, D);
        }, y.prototype.writeDoubleLE = function(S, C, D) {
          Z(this, S, C, !0, D);
        }, y.prototype.writeDoubleBE = function(S, C, D) {
          Z(this, S, C, !1, D);
        }, y.prototype.fill = function(S, C, D) {
          if (C = C || 0, D = D || this.length, B(typeof (S = typeof (S = S || 0) == "string" ? S.charCodeAt(0) : S) == "number" && !isNaN(S), "value is not a number"), B(C <= D, "end < start"), D !== C && this.length !== 0) {
            B(0 <= C && C < this.length, "start out of bounds"), B(0 <= D && D <= this.length, "end out of bounds");
            for (var G = C; G < D; G++)
              this[G] = S;
          }
        }, y.prototype.inspect = function() {
          for (var S = [], C = this.length, D = 0; D < C; D++)
            if (S[D] = se(this[D]), D === s.INSPECT_MAX_BYTES) {
              S[D + 1] = "...";
              break;
            }
          return "<Buffer " + S.join(" ") + ">";
        }, y.prototype.toArrayBuffer = function() {
          if (typeof Uint8Array > "u")
            throw new Error("Buffer.toArrayBuffer not supported in this browser");
          if (y._useTypedArrays)
            return new y(this).buffer;
          for (var S = new Uint8Array(this.length), C = 0, D = S.length; C < D; C += 1)
            S[C] = this[C];
          return S.buffer;
        };
        var W = y.prototype;
        function X(S, C, D) {
          return typeof S != "number" ? D : C <= (S = ~~S) ? C : 0 <= S || 0 <= (S += C) ? S : 0;
        }
        function V(S) {
          return (S = ~~Math.ceil(+S)) < 0 ? 0 : S;
        }
        function ne(S) {
          return (Array.isArray || function(C) {
            return Object.prototype.toString.call(C) === "[object Array]";
          })(S);
        }
        function se(S) {
          return S < 16 ? "0" + S.toString(16) : S.toString(16);
        }
        function he(S) {
          for (var C = [], D = 0; D < S.length; D++) {
            var G = S.charCodeAt(D);
            if (G <= 127)
              C.push(S.charCodeAt(D));
            else
              for (var $ = D, Y = (55296 <= G && G <= 57343 && D++, encodeURIComponent(S.slice($, D + 1)).substr(1).split("%")), te = 0; te < Y.length; te++)
                C.push(parseInt(Y[te], 16));
          }
          return C;
        }
        function H(S) {
          return v.toByteArray(S);
        }
        function k(S, C, D, G) {
          for (var $ = 0; $ < G && !($ + D >= C.length || $ >= S.length); $++)
            C[$ + D] = S[$];
          return $;
        }
        function b(S) {
          try {
            return decodeURIComponent(S);
          } catch {
            return "�";
          }
        }
        function U(S, C) {
          B(typeof S == "number", "cannot write a non-number as a number"), B(0 <= S, "specified a negative value for writing an unsigned value"), B(S <= C, "value is larger than maximum value for type"), B(Math.floor(S) === S, "value has a fractional component");
        }
        function J(S, C, D) {
          B(typeof S == "number", "cannot write a non-number as a number"), B(S <= C, "value larger than maximum allowed value"), B(D <= S, "value smaller than minimum allowed value"), B(Math.floor(S) === S, "value has a fractional component");
        }
        function F(S, C, D) {
          B(typeof S == "number", "cannot write a non-number as a number"), B(S <= C, "value larger than maximum allowed value"), B(D <= S, "value smaller than minimum allowed value");
        }
        function B(S, C) {
          if (!S)
            throw new Error(C || "Failed assertion");
        }
        y._augment = function(S) {
          return S._isBuffer = !0, S._get = S.get, S._set = S.set, S.get = W.get, S.set = W.set, S.write = W.write, S.toString = W.toString, S.toLocaleString = W.toString, S.toJSON = W.toJSON, S.copy = W.copy, S.slice = W.slice, S.readUInt8 = W.readUInt8, S.readUInt16LE = W.readUInt16LE, S.readUInt16BE = W.readUInt16BE, S.readUInt32LE = W.readUInt32LE, S.readUInt32BE = W.readUInt32BE, S.readInt8 = W.readInt8, S.readInt16LE = W.readInt16LE, S.readInt16BE = W.readInt16BE, S.readInt32LE = W.readInt32LE, S.readInt32BE = W.readInt32BE, S.readFloatLE = W.readFloatLE, S.readFloatBE = W.readFloatBE, S.readDoubleLE = W.readDoubleLE, S.readDoubleBE = W.readDoubleBE, S.writeUInt8 = W.writeUInt8, S.writeUInt16LE = W.writeUInt16LE, S.writeUInt16BE = W.writeUInt16BE, S.writeUInt32LE = W.writeUInt32LE, S.writeUInt32BE = W.writeUInt32BE, S.writeInt8 = W.writeInt8, S.writeInt16LE = W.writeInt16LE, S.writeInt16BE = W.writeInt16BE, S.writeInt32LE = W.writeInt32LE, S.writeInt32BE = W.writeInt32BE, S.writeFloatLE = W.writeFloatLE, S.writeFloatBE = W.writeFloatBE, S.writeDoubleLE = W.writeDoubleLE, S.writeDoubleBE = W.writeDoubleBE, S.fill = W.fill, S.inspect = W.inspect, S.toArrayBuffer = W.toArrayBuffer, S;
        };
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer");
    }, { "base64-js": 2, buffer: 3, ieee754: 10, lYpoI2: 11 }], 4: [function(t, n, s) {
      (function(i, r, v, l, c, u, h, m, p) {
        var v = t("buffer").Buffer, _ = 4, y = new v(_);
        y.fill(0), n.exports = { hash: function(E, R, T, g) {
          for (var A = R(function(f, P) {
            f.length % _ != 0 && (I = f.length + (_ - f.length % _), f = v.concat([f, y], I));
            for (var I, K = [], N = P ? f.readInt32BE : f.readInt32LE, Z = 0; Z < f.length; Z += _)
              K.push(N.call(f, Z));
            return K;
          }(E = v.isBuffer(E) ? E : new v(E), g), 8 * E.length), R = g, x = new v(T), M = R ? x.writeInt32BE : x.writeInt32LE, d = 0; d < A.length; d++)
            M.call(x, A[d], 4 * d, !0);
          return x;
        } };
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { buffer: 3, lYpoI2: 11 }], 5: [function(t, n, s) {
      (function(i, r, v, l, c, u, h, m, p) {
        var v = t("buffer").Buffer, _ = t("./sha"), y = t("./sha256"), E = t("./rng"), R = { sha1: _, sha256: y, md5: t("./md5") }, T = 64, g = new v(T);
        function A(f, P) {
          var I = R[f = f || "sha1"], K = [];
          return I || x("algorithm:", f, "is not yet supported"), { update: function(N) {
            return v.isBuffer(N) || (N = new v(N)), K.push(N), N.length, this;
          }, digest: function(N) {
            var Z = v.concat(K), Z = P ? function(W, X, V) {
              v.isBuffer(X) || (X = new v(X)), v.isBuffer(V) || (V = new v(V)), X.length > T ? X = W(X) : X.length < T && (X = v.concat([X, g], T));
              for (var ne = new v(T), se = new v(T), he = 0; he < T; he++)
                ne[he] = 54 ^ X[he], se[he] = 92 ^ X[he];
              return V = W(v.concat([ne, V])), W(v.concat([se, V]));
            }(I, P, Z) : I(Z);
            return K = null, N ? Z.toString(N) : Z;
          } };
        }
        function x() {
          var f = [].slice.call(arguments).join(" ");
          throw new Error([f, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join(`
`));
        }
        g.fill(0), s.createHash = function(f) {
          return A(f);
        }, s.createHmac = A, s.randomBytes = function(f, P) {
          if (!P || !P.call)
            return new v(E(f));
          try {
            P.call(this, void 0, new v(E(f)));
          } catch (I) {
            P(I);
          }
        };
        var M, d = ["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], w = function(f) {
          s[f] = function() {
            x("sorry,", f, "is not implemented yet");
          };
        };
        for (M in d)
          w(d[M]);
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./md5": 6, "./rng": 7, "./sha": 8, "./sha256": 9, buffer: 3, lYpoI2: 11 }], 6: [function(t, n, s) {
      (function(i, r, a, l, c, u, h, m, p) {
        var v = t("./helpers");
        function _(x, M) {
          x[M >> 5] |= 128 << M % 32, x[14 + (M + 64 >>> 9 << 4)] = M;
          for (var d = 1732584193, w = -271733879, f = -1732584194, P = 271733878, I = 0; I < x.length; I += 16) {
            var K = d, N = w, Z = f, W = P, d = E(d, w, f, P, x[I + 0], 7, -680876936), P = E(P, d, w, f, x[I + 1], 12, -389564586), f = E(f, P, d, w, x[I + 2], 17, 606105819), w = E(w, f, P, d, x[I + 3], 22, -1044525330);
            d = E(d, w, f, P, x[I + 4], 7, -176418897), P = E(P, d, w, f, x[I + 5], 12, 1200080426), f = E(f, P, d, w, x[I + 6], 17, -1473231341), w = E(w, f, P, d, x[I + 7], 22, -45705983), d = E(d, w, f, P, x[I + 8], 7, 1770035416), P = E(P, d, w, f, x[I + 9], 12, -1958414417), f = E(f, P, d, w, x[I + 10], 17, -42063), w = E(w, f, P, d, x[I + 11], 22, -1990404162), d = E(d, w, f, P, x[I + 12], 7, 1804603682), P = E(P, d, w, f, x[I + 13], 12, -40341101), f = E(f, P, d, w, x[I + 14], 17, -1502002290), d = R(d, w = E(w, f, P, d, x[I + 15], 22, 1236535329), f, P, x[I + 1], 5, -165796510), P = R(P, d, w, f, x[I + 6], 9, -1069501632), f = R(f, P, d, w, x[I + 11], 14, 643717713), w = R(w, f, P, d, x[I + 0], 20, -373897302), d = R(d, w, f, P, x[I + 5], 5, -701558691), P = R(P, d, w, f, x[I + 10], 9, 38016083), f = R(f, P, d, w, x[I + 15], 14, -660478335), w = R(w, f, P, d, x[I + 4], 20, -405537848), d = R(d, w, f, P, x[I + 9], 5, 568446438), P = R(P, d, w, f, x[I + 14], 9, -1019803690), f = R(f, P, d, w, x[I + 3], 14, -187363961), w = R(w, f, P, d, x[I + 8], 20, 1163531501), d = R(d, w, f, P, x[I + 13], 5, -1444681467), P = R(P, d, w, f, x[I + 2], 9, -51403784), f = R(f, P, d, w, x[I + 7], 14, 1735328473), d = T(d, w = R(w, f, P, d, x[I + 12], 20, -1926607734), f, P, x[I + 5], 4, -378558), P = T(P, d, w, f, x[I + 8], 11, -2022574463), f = T(f, P, d, w, x[I + 11], 16, 1839030562), w = T(w, f, P, d, x[I + 14], 23, -35309556), d = T(d, w, f, P, x[I + 1], 4, -1530992060), P = T(P, d, w, f, x[I + 4], 11, 1272893353), f = T(f, P, d, w, x[I + 7], 16, -155497632), w = T(w, f, P, d, x[I + 10], 23, -1094730640), d = T(d, w, f, P, x[I + 13], 4, 681279174), P = T(P, d, w, f, x[I + 0], 11, -358537222), f = T(f, P, d, w, x[I + 3], 16, -722521979), w = T(w, f, P, d, x[I + 6], 23, 76029189), d = T(d, w, f, P, x[I + 9], 4, -640364487), P = T(P, d, w, f, x[I + 12], 11, -421815835), f = T(f, P, d, w, x[I + 15], 16, 530742520), d = g(d, w = T(w, f, P, d, x[I + 2], 23, -995338651), f, P, x[I + 0], 6, -198630844), P = g(P, d, w, f, x[I + 7], 10, 1126891415), f = g(f, P, d, w, x[I + 14], 15, -1416354905), w = g(w, f, P, d, x[I + 5], 21, -57434055), d = g(d, w, f, P, x[I + 12], 6, 1700485571), P = g(P, d, w, f, x[I + 3], 10, -1894986606), f = g(f, P, d, w, x[I + 10], 15, -1051523), w = g(w, f, P, d, x[I + 1], 21, -2054922799), d = g(d, w, f, P, x[I + 8], 6, 1873313359), P = g(P, d, w, f, x[I + 15], 10, -30611744), f = g(f, P, d, w, x[I + 6], 15, -1560198380), w = g(w, f, P, d, x[I + 13], 21, 1309151649), d = g(d, w, f, P, x[I + 4], 6, -145523070), P = g(P, d, w, f, x[I + 11], 10, -1120210379), f = g(f, P, d, w, x[I + 2], 15, 718787259), w = g(w, f, P, d, x[I + 9], 21, -343485551), d = A(d, K), w = A(w, N), f = A(f, Z), P = A(P, W);
          }
          return Array(d, w, f, P);
        }
        function y(x, M, d, w, f, P) {
          return A((M = A(A(M, x), A(w, P))) << f | M >>> 32 - f, d);
        }
        function E(x, M, d, w, f, P, I) {
          return y(M & d | ~M & w, x, M, f, P, I);
        }
        function R(x, M, d, w, f, P, I) {
          return y(M & w | d & ~w, x, M, f, P, I);
        }
        function T(x, M, d, w, f, P, I) {
          return y(M ^ d ^ w, x, M, f, P, I);
        }
        function g(x, M, d, w, f, P, I) {
          return y(d ^ (M | ~w), x, M, f, P, I);
        }
        function A(x, M) {
          var d = (65535 & x) + (65535 & M);
          return (x >> 16) + (M >> 16) + (d >> 16) << 16 | 65535 & d;
        }
        n.exports = function(x) {
          return v.hash(x, _, 16);
        };
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 7: [function(t, n, s) {
      (function(i, r, a, l, c, u, h, m, p) {
        n.exports = function(v) {
          for (var _, y = new Array(v), E = 0; E < v; E++)
            !(3 & E) && (_ = 4294967296 * Math.random()), y[E] = _ >>> ((3 & E) << 3) & 255;
          return y;
        };
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { buffer: 3, lYpoI2: 11 }], 8: [function(t, n, s) {
      (function(i, r, a, l, c, u, h, m, p) {
        var v = t("./helpers");
        function _(R, T) {
          R[T >> 5] |= 128 << 24 - T % 32, R[15 + (T + 64 >> 9 << 4)] = T;
          for (var g, A, x, M = Array(80), d = 1732584193, w = -271733879, f = -1732584194, P = 271733878, I = -1009589776, K = 0; K < R.length; K += 16) {
            for (var N = d, Z = w, W = f, X = P, V = I, ne = 0; ne < 80; ne++) {
              M[ne] = ne < 16 ? R[K + ne] : E(M[ne - 3] ^ M[ne - 8] ^ M[ne - 14] ^ M[ne - 16], 1);
              var se = y(y(E(d, 5), (se = w, A = f, x = P, (g = ne) < 20 ? se & A | ~se & x : !(g < 40) && g < 60 ? se & A | se & x | A & x : se ^ A ^ x)), y(y(I, M[ne]), (g = ne) < 20 ? 1518500249 : g < 40 ? 1859775393 : g < 60 ? -1894007588 : -899497514)), I = P, P = f, f = E(w, 30), w = d, d = se;
            }
            d = y(d, N), w = y(w, Z), f = y(f, W), P = y(P, X), I = y(I, V);
          }
          return Array(d, w, f, P, I);
        }
        function y(R, T) {
          var g = (65535 & R) + (65535 & T);
          return (R >> 16) + (T >> 16) + (g >> 16) << 16 | 65535 & g;
        }
        function E(R, T) {
          return R << T | R >>> 32 - T;
        }
        n.exports = function(R) {
          return v.hash(R, _, 20, !0);
        };
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 9: [function(t, n, s) {
      (function(i, r, a, l, c, u, h, m, p) {
        function v(T, g) {
          var A = (65535 & T) + (65535 & g);
          return (T >> 16) + (g >> 16) + (A >> 16) << 16 | 65535 & A;
        }
        function _(T, g) {
          var A, x = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298), M = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225), d = new Array(64);
          T[g >> 5] |= 128 << 24 - g % 32, T[15 + (g + 64 >> 9 << 4)] = g;
          for (var w, f, P = 0; P < T.length; P += 16) {
            for (var I = M[0], K = M[1], N = M[2], Z = M[3], W = M[4], X = M[5], V = M[6], ne = M[7], se = 0; se < 64; se++)
              d[se] = se < 16 ? T[se + P] : v(v(v((f = d[se - 2], E(f, 17) ^ E(f, 19) ^ R(f, 10)), d[se - 7]), (f = d[se - 15], E(f, 7) ^ E(f, 18) ^ R(f, 3))), d[se - 16]), A = v(v(v(v(ne, E(f = W, 6) ^ E(f, 11) ^ E(f, 25)), W & X ^ ~W & V), x[se]), d[se]), w = v(E(w = I, 2) ^ E(w, 13) ^ E(w, 22), I & K ^ I & N ^ K & N), ne = V, V = X, X = W, W = v(Z, A), Z = N, N = K, K = I, I = v(A, w);
            M[0] = v(I, M[0]), M[1] = v(K, M[1]), M[2] = v(N, M[2]), M[3] = v(Z, M[3]), M[4] = v(W, M[4]), M[5] = v(X, M[5]), M[6] = v(V, M[6]), M[7] = v(ne, M[7]);
          }
          return M;
        }
        var y = t("./helpers"), E = function(T, g) {
          return T >>> g | T << 32 - g;
        }, R = function(T, g) {
          return T >>> g;
        };
        n.exports = function(T) {
          return y.hash(T, _, 32, !0);
        };
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 10: [function(t, n, s) {
      (function(i, r, a, l, c, u, h, m, p) {
        s.read = function(v, _, y, E, P) {
          var T, g, A = 8 * P - E - 1, x = (1 << A) - 1, M = x >> 1, d = -7, w = y ? P - 1 : 0, f = y ? -1 : 1, P = v[_ + w];
          for (w += f, T = P & (1 << -d) - 1, P >>= -d, d += A; 0 < d; T = 256 * T + v[_ + w], w += f, d -= 8)
            ;
          for (g = T & (1 << -d) - 1, T >>= -d, d += E; 0 < d; g = 256 * g + v[_ + w], w += f, d -= 8)
            ;
          if (T === 0)
            T = 1 - M;
          else {
            if (T === x)
              return g ? NaN : 1 / 0 * (P ? -1 : 1);
            g += Math.pow(2, E), T -= M;
          }
          return (P ? -1 : 1) * g * Math.pow(2, T - E);
        }, s.write = function(v, _, y, E, R, I) {
          var g, A, x = 8 * I - R - 1, M = (1 << x) - 1, d = M >> 1, w = R === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = E ? 0 : I - 1, P = E ? 1 : -1, I = _ < 0 || _ === 0 && 1 / _ < 0 ? 1 : 0;
          for (_ = Math.abs(_), isNaN(_) || _ === 1 / 0 ? (A = isNaN(_) ? 1 : 0, g = M) : (g = Math.floor(Math.log(_) / Math.LN2), _ * (E = Math.pow(2, -g)) < 1 && (g--, E *= 2), 2 <= (_ += 1 <= g + d ? w / E : w * Math.pow(2, 1 - d)) * E && (g++, E /= 2), M <= g + d ? (A = 0, g = M) : 1 <= g + d ? (A = (_ * E - 1) * Math.pow(2, R), g += d) : (A = _ * Math.pow(2, d - 1) * Math.pow(2, R), g = 0)); 8 <= R; v[y + f] = 255 & A, f += P, A /= 256, R -= 8)
            ;
          for (g = g << R | A, x += R; 0 < x; v[y + f] = 255 & g, f += P, g /= 256, x -= 8)
            ;
          v[y + f - P] |= 128 * I;
        };
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/ieee754/index.js", "/node_modules/gulp-browserify/node_modules/ieee754");
    }, { buffer: 3, lYpoI2: 11 }], 11: [function(t, n, s) {
      (function(i, r, a, l, c, u, h, m, p) {
        var v, _, y;
        function E() {
        }
        (i = n.exports = {}).nextTick = (_ = typeof window < "u" && window.setImmediate, y = typeof window < "u" && window.postMessage && window.addEventListener, _ ? function(R) {
          return window.setImmediate(R);
        } : y ? (v = [], window.addEventListener("message", function(R) {
          var T = R.source;
          T !== window && T !== null || R.data !== "process-tick" || (R.stopPropagation(), 0 < v.length && v.shift()());
        }, !0), function(R) {
          v.push(R), window.postMessage("process-tick", "*");
        }) : function(R) {
          setTimeout(R, 0);
        }), i.title = "browser", i.browser = !0, i.env = {}, i.argv = [], i.on = E, i.addListener = E, i.once = E, i.off = E, i.removeListener = E, i.removeAllListeners = E, i.emit = E, i.binding = function(R) {
          throw new Error("process.binding is not supported");
        }, i.cwd = function() {
          return "/";
        }, i.chdir = function(R) {
          throw new Error("process.chdir is not supported");
        };
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process");
    }, { buffer: 3, lYpoI2: 11 }] }, {}, [1])(1);
  });
})(ja);
var Df = ja.exports;
const Lf = /* @__PURE__ */ ys(Df);
var Va = [
  // current
  "precision",
  "highp",
  "mediump",
  "lowp",
  "attribute",
  "const",
  "uniform",
  "varying",
  "break",
  "continue",
  "do",
  "for",
  "while",
  "if",
  "else",
  "in",
  "out",
  "inout",
  "float",
  "int",
  "uint",
  "void",
  "bool",
  "true",
  "false",
  "discard",
  "return",
  "mat2",
  "mat3",
  "mat4",
  "vec2",
  "vec3",
  "vec4",
  "ivec2",
  "ivec3",
  "ivec4",
  "bvec2",
  "bvec3",
  "bvec4",
  "sampler1D",
  "sampler2D",
  "sampler3D",
  "samplerCube",
  "sampler1DShadow",
  "sampler2DShadow",
  "struct",
  "asm",
  "class",
  "union",
  "enum",
  "typedef",
  "template",
  "this",
  "packed",
  "goto",
  "switch",
  "default",
  "inline",
  "noinline",
  "volatile",
  "public",
  "static",
  "extern",
  "external",
  "interface",
  "long",
  "short",
  "double",
  "half",
  "fixed",
  "unsigned",
  "input",
  "output",
  "hvec2",
  "hvec3",
  "hvec4",
  "dvec2",
  "dvec3",
  "dvec4",
  "fvec2",
  "fvec3",
  "fvec4",
  "sampler2DRect",
  "sampler3DRect",
  "sampler2DRectShadow",
  "sizeof",
  "cast",
  "namespace",
  "using"
], Of = [
  "<<=",
  ">>=",
  "++",
  "--",
  "<<",
  ">>",
  "<=",
  ">=",
  "==",
  "!=",
  "&&",
  "||",
  "+=",
  "-=",
  "*=",
  "/=",
  "%=",
  "&=",
  "^^",
  "^=",
  "|=",
  "(",
  ")",
  "[",
  "]",
  ".",
  "!",
  "~",
  "*",
  "/",
  "%",
  "+",
  "-",
  "<",
  ">",
  "&",
  "^",
  "|",
  "?",
  ":",
  "=",
  ",",
  ";",
  "{",
  "}"
], Ya = [
  // Keep this list sorted
  "abs",
  "acos",
  "all",
  "any",
  "asin",
  "atan",
  "ceil",
  "clamp",
  "cos",
  "cross",
  "dFdx",
  "dFdy",
  "degrees",
  "distance",
  "dot",
  "equal",
  "exp",
  "exp2",
  "faceforward",
  "floor",
  "fract",
  "gl_BackColor",
  "gl_BackLightModelProduct",
  "gl_BackLightProduct",
  "gl_BackMaterial",
  "gl_BackSecondaryColor",
  "gl_ClipPlane",
  "gl_ClipVertex",
  "gl_Color",
  "gl_DepthRange",
  "gl_DepthRangeParameters",
  "gl_EyePlaneQ",
  "gl_EyePlaneR",
  "gl_EyePlaneS",
  "gl_EyePlaneT",
  "gl_Fog",
  "gl_FogCoord",
  "gl_FogFragCoord",
  "gl_FogParameters",
  "gl_FragColor",
  "gl_FragCoord",
  "gl_FragData",
  "gl_FragDepth",
  "gl_FragDepthEXT",
  "gl_FrontColor",
  "gl_FrontFacing",
  "gl_FrontLightModelProduct",
  "gl_FrontLightProduct",
  "gl_FrontMaterial",
  "gl_FrontSecondaryColor",
  "gl_LightModel",
  "gl_LightModelParameters",
  "gl_LightModelProducts",
  "gl_LightProducts",
  "gl_LightSource",
  "gl_LightSourceParameters",
  "gl_MaterialParameters",
  "gl_MaxClipPlanes",
  "gl_MaxCombinedTextureImageUnits",
  "gl_MaxDrawBuffers",
  "gl_MaxFragmentUniformComponents",
  "gl_MaxLights",
  "gl_MaxTextureCoords",
  "gl_MaxTextureImageUnits",
  "gl_MaxTextureUnits",
  "gl_MaxVaryingFloats",
  "gl_MaxVertexAttribs",
  "gl_MaxVertexTextureImageUnits",
  "gl_MaxVertexUniformComponents",
  "gl_ModelViewMatrix",
  "gl_ModelViewMatrixInverse",
  "gl_ModelViewMatrixInverseTranspose",
  "gl_ModelViewMatrixTranspose",
  "gl_ModelViewProjectionMatrix",
  "gl_ModelViewProjectionMatrixInverse",
  "gl_ModelViewProjectionMatrixInverseTranspose",
  "gl_ModelViewProjectionMatrixTranspose",
  "gl_MultiTexCoord0",
  "gl_MultiTexCoord1",
  "gl_MultiTexCoord2",
  "gl_MultiTexCoord3",
  "gl_MultiTexCoord4",
  "gl_MultiTexCoord5",
  "gl_MultiTexCoord6",
  "gl_MultiTexCoord7",
  "gl_Normal",
  "gl_NormalMatrix",
  "gl_NormalScale",
  "gl_ObjectPlaneQ",
  "gl_ObjectPlaneR",
  "gl_ObjectPlaneS",
  "gl_ObjectPlaneT",
  "gl_Point",
  "gl_PointCoord",
  "gl_PointParameters",
  "gl_PointSize",
  "gl_Position",
  "gl_ProjectionMatrix",
  "gl_ProjectionMatrixInverse",
  "gl_ProjectionMatrixInverseTranspose",
  "gl_ProjectionMatrixTranspose",
  "gl_SecondaryColor",
  "gl_TexCoord",
  "gl_TextureEnvColor",
  "gl_TextureMatrix",
  "gl_TextureMatrixInverse",
  "gl_TextureMatrixInverseTranspose",
  "gl_TextureMatrixTranspose",
  "gl_Vertex",
  "greaterThan",
  "greaterThanEqual",
  "inversesqrt",
  "length",
  "lessThan",
  "lessThanEqual",
  "log",
  "log2",
  "matrixCompMult",
  "max",
  "min",
  "mix",
  "mod",
  "normalize",
  "not",
  "notEqual",
  "pow",
  "radians",
  "reflect",
  "refract",
  "sign",
  "sin",
  "smoothstep",
  "sqrt",
  "step",
  "tan",
  "texture2D",
  "texture2DLod",
  "texture2DProj",
  "texture2DProjLod",
  "textureCube",
  "textureCubeLod",
  "texture2DLodEXT",
  "texture2DProjLodEXT",
  "textureCubeLodEXT",
  "texture2DGradEXT",
  "texture2DProjGradEXT",
  "textureCubeGradEXT"
], Ff = Va, kf = Ff.slice().concat([
  "layout",
  "centroid",
  "smooth",
  "case",
  "mat2x2",
  "mat2x3",
  "mat2x4",
  "mat3x2",
  "mat3x3",
  "mat3x4",
  "mat4x2",
  "mat4x3",
  "mat4x4",
  "uvec2",
  "uvec3",
  "uvec4",
  "samplerCubeShadow",
  "sampler2DArray",
  "sampler2DArrayShadow",
  "isampler2D",
  "isampler3D",
  "isamplerCube",
  "isampler2DArray",
  "usampler2D",
  "usampler3D",
  "usamplerCube",
  "usampler2DArray",
  "coherent",
  "restrict",
  "readonly",
  "writeonly",
  "resource",
  "atomic_uint",
  "noperspective",
  "patch",
  "sample",
  "subroutine",
  "common",
  "partition",
  "active",
  "filter",
  "image1D",
  "image2D",
  "image3D",
  "imageCube",
  "iimage1D",
  "iimage2D",
  "iimage3D",
  "iimageCube",
  "uimage1D",
  "uimage2D",
  "uimage3D",
  "uimageCube",
  "image1DArray",
  "image2DArray",
  "iimage1DArray",
  "iimage2DArray",
  "uimage1DArray",
  "uimage2DArray",
  "image1DShadow",
  "image2DShadow",
  "image1DArrayShadow",
  "image2DArrayShadow",
  "imageBuffer",
  "iimageBuffer",
  "uimageBuffer",
  "sampler1DArray",
  "sampler1DArrayShadow",
  "isampler1D",
  "isampler1DArray",
  "usampler1D",
  "usampler1DArray",
  "isampler2DRect",
  "usampler2DRect",
  "samplerBuffer",
  "isamplerBuffer",
  "usamplerBuffer",
  "sampler2DMS",
  "isampler2DMS",
  "usampler2DMS",
  "sampler2DMSArray",
  "isampler2DMSArray",
  "usampler2DMSArray"
]), nr = Ya;
nr = nr.slice().filter(function(o) {
  return !/^(gl\_|texture)/.test(o);
});
var Uf = nr.concat([
  // the updated gl_ constants
  "gl_VertexID",
  "gl_InstanceID",
  "gl_Position",
  "gl_PointSize",
  "gl_FragCoord",
  "gl_FrontFacing",
  "gl_FragDepth",
  "gl_PointCoord",
  "gl_MaxVertexAttribs",
  "gl_MaxVertexUniformVectors",
  "gl_MaxVertexOutputVectors",
  "gl_MaxFragmentInputVectors",
  "gl_MaxVertexTextureImageUnits",
  "gl_MaxCombinedTextureImageUnits",
  "gl_MaxTextureImageUnits",
  "gl_MaxFragmentUniformVectors",
  "gl_MaxDrawBuffers",
  "gl_MinProgramTexelOffset",
  "gl_MaxProgramTexelOffset",
  "gl_DepthRangeParameters",
  "gl_DepthRange",
  "trunc",
  "round",
  "roundEven",
  "isnan",
  "isinf",
  "floatBitsToInt",
  "floatBitsToUint",
  "intBitsToFloat",
  "uintBitsToFloat",
  "packSnorm2x16",
  "unpackSnorm2x16",
  "packUnorm2x16",
  "unpackUnorm2x16",
  "packHalf2x16",
  "unpackHalf2x16",
  "outerProduct",
  "transpose",
  "determinant",
  "inverse",
  "texture",
  "textureSize",
  "textureProj",
  "textureLod",
  "textureOffset",
  "texelFetch",
  "texelFetchOffset",
  "textureProjOffset",
  "textureLodOffset",
  "textureProjLod",
  "textureProjLodOffset",
  "textureGrad",
  "textureGradOffset",
  "textureProjGrad",
  "textureProjGradOffset"
]), Bf = $f, Nf = Va, yo = Of, zf = Ya, Hf = kf, Gf = Uf, bt = 999, vo = 9999, Li = 0, Oi = 1, _o = 2, xo = 3, wo = 4, Jn = 5, jf = 6, Vf = 7, Yf = 8, To = 9, Xf = 10, bo = 11, Wf = [
  "block-comment",
  "line-comment",
  "preprocessor",
  "operator",
  "integer",
  "float",
  "ident",
  "builtin",
  "keyword",
  "whitespace",
  "eof",
  "integer"
];
function $f(o) {
  var e = 0, t = 0, n = bt, s, i, r = [], a = [], l = 1, c = 0, u = 0, h = !1, m = !1, p = "", v;
  o = o || {};
  var _ = zf, y = Nf;
  o.version === "300 es" && (_ = Gf, y = Hf);
  for (var E = {}, R = {}, e = 0; e < _.length; e++)
    E[_[e]] = !0;
  for (var e = 0; e < y.length; e++)
    R[y[e]] = !0;
  return function(X) {
    return a = [], X !== null ? g(X) : A();
  };
  function T(X) {
    X.length && a.push({
      type: Wf[n],
      data: X,
      position: u,
      line: l,
      column: c
    });
  }
  function g(X) {
    e = 0, X.toString && (X = X.toString()), p += X.replace(/\r\n/g, `
`), v = p.length;
    for (var V; s = p[e], e < v; ) {
      switch (V = e, n) {
        case Li:
          e = f();
          break;
        case Oi:
          e = w();
          break;
        case _o:
          e = d();
          break;
        case xo:
          e = P();
          break;
        case wo:
          e = N();
          break;
        case bo:
          e = K();
          break;
        case Jn:
          e = Z();
          break;
        case vo:
          e = W();
          break;
        case To:
          e = M();
          break;
        case bt:
          e = x();
          break;
      }
      if (V !== e)
        switch (p[V]) {
          case `
`:
            c = 0, ++l;
            break;
          default:
            ++c;
            break;
        }
    }
    return t += e, p = p.slice(e), a;
  }
  function A(X) {
    return r.length && T(r.join("")), n = Xf, T("(eof)"), a;
  }
  function x() {
    return r = r.length ? [] : r, i === "/" && s === "*" ? (u = t + e - 1, n = Li, i = s, e + 1) : i === "/" && s === "/" ? (u = t + e - 1, n = Oi, i = s, e + 1) : s === "#" ? (n = _o, u = t + e, e) : /\s/.test(s) ? (n = To, u = t + e, e) : (h = /\d/.test(s), m = /[^\w_]/.test(s), u = t + e, n = h ? wo : m ? xo : vo, e);
  }
  function M() {
    return /[^\s]/g.test(s) ? (T(r.join("")), n = bt, e) : (r.push(s), i = s, e + 1);
  }
  function d() {
    return (s === "\r" || s === `
`) && i !== "\\" ? (T(r.join("")), n = bt, e) : (r.push(s), i = s, e + 1);
  }
  function w() {
    return d();
  }
  function f() {
    return s === "/" && i === "*" ? (r.push(s), T(r.join("")), n = bt, e + 1) : (r.push(s), i = s, e + 1);
  }
  function P() {
    if (i === "." && /\d/.test(s))
      return n = Jn, e;
    if (i === "/" && s === "*")
      return n = Li, e;
    if (i === "/" && s === "/")
      return n = Oi, e;
    if (s === "." && r.length) {
      for (; I(r); )
        ;
      return n = Jn, e;
    }
    if (s === ";" || s === ")" || s === "(") {
      if (r.length)
        for (; I(r); )
          ;
      return T(s), n = bt, e + 1;
    }
    var X = r.length === 2 && s !== "=";
    if (/[\w_\d\s]/.test(s) || X) {
      for (; I(r); )
        ;
      return n = bt, e;
    }
    return r.push(s), i = s, e + 1;
  }
  function I(X) {
    var V = 0, ne, se;
    do {
      if (ne = yo.indexOf(X.slice(0, X.length + V).join("")), se = yo[ne], ne === -1) {
        if (V-- + X.length > 0)
          continue;
        se = X.slice(0, 1).join("");
      }
      return T(se), u += se.length, r = r.slice(se.length), r.length;
    } while (!0);
  }
  function K() {
    return /[^a-fA-F0-9]/.test(s) ? (T(r.join("")), n = bt, e) : (r.push(s), i = s, e + 1);
  }
  function N() {
    return s === "." || /[eE]/.test(s) ? (r.push(s), n = Jn, i = s, e + 1) : s === "x" && r.length === 1 && r[0] === "0" ? (n = bo, r.push(s), i = s, e + 1) : /[^\d]/.test(s) ? (T(r.join("")), n = bt, e) : (r.push(s), i = s, e + 1);
  }
  function Z() {
    return s === "f" && (r.push(s), i = s, e += 1), /[eE]/.test(s) || (s === "-" || s === "+") && /[eE]/.test(i) ? (r.push(s), i = s, e + 1) : /[^\d]/.test(s) ? (T(r.join("")), n = bt, e) : (r.push(s), i = s, e + 1);
  }
  function W() {
    if (/[^\d\w_]/.test(s)) {
      var X = r.join("");
      return R[X] ? n = Yf : E[X] ? n = Vf : n = jf, T(r.join("")), n = bt, e;
    }
    return r.push(s), i = s, e + 1;
  }
}
var Zf = Bf, Kf = qf;
function qf(o, e) {
  var t = Zf(e), n = [];
  return n = n.concat(t(o)), n = n.concat(t(null)), n;
}
const Qf = /* @__PURE__ */ ys(Kf);
var Jf = ed;
function ed(o) {
  for (var e = [], t = 0; t < o.length; t++)
    o[t].type !== "eof" && e.push(o[t].data);
  return e.join("");
}
const Eo = /* @__PURE__ */ ys(Jf);
var td = nd;
function nd(o) {
  var e = null, t = null, n = 0, s = 0, i = 0, r = 0, a = 0, l = [], c, u, h;
  for (c = 0, u; c < o.length; c++)
    if (h = o[c], h.data === "{") {
      if (n && n++ || (u = p(c, en(")"), en()), u < 0) || (r = u, u = p(u, en("("), en(")")), u < 0) || (a = u, u = p(u, es), u < 0) || o[u].type !== "ident" || (t = o[u].data, u = p(u, es), u < 0))
        continue;
      n = 1, s = c, e = o[u].data, i = u;
      var m = p(u, es);
      switch (o[m] && o[m].data) {
        case "lowp":
        case "highp":
        case "mediump":
          i = m;
      }
    } else if (n && h.data === "}") {
      if (--n)
        continue;
      l.push({
        name: t,
        type: e,
        body: [s + 1, c],
        args: [a, r + 1],
        outer: [i, c + 1]
      });
    }
  for (c = 0; c < o.length; c++)
    if (h = o[c], h.data === ";") {
      if (u = p(c, en(")"), en()), u < 0 || (r = u, u = p(u, en("("), en(")")), u < 0) || (a = u, u = p(u, es), u < 0) || o[u].type !== "ident" || (t = o[u].data, u = p(u, es), u < 0) || o[u].type === "operator" || o[u].data === "return")
        continue;
      e = o[u].data, l.push({
        name: t,
        type: e,
        body: !1,
        args: [a, r + 1],
        outer: [u, c + 1]
      });
    }
  return l.sort(function(v, _) {
    return v.outer[0] - _.outer[0];
  });
  function p(v, _, y) {
    for (var E = v - 1; E >= 0; E--) {
      if (_(o[E]))
        return E;
      if (y && y(o[E]))
        return -1;
    }
    return -1;
  }
}
function en(o) {
  return function(e) {
    return e.type === "operator" && (!o || e.data === o);
  };
}
function es(o) {
  return o.type !== "whitespace";
}
const sd = /* @__PURE__ */ ys(td);
function id(o, e) {
  if (typeof o != "object" || o === null)
    return o;
  var t = o[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(o, e || "default");
    if (typeof n != "object")
      return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(o);
}
function Xa(o) {
  var e = id(o, "string");
  return typeof e == "symbol" ? e : String(e);
}
function Ue(o, e, t) {
  return e = Xa(e), e in o ? Object.defineProperty(o, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : o[e] = t, o;
}
function Mo(o, e) {
  var t = Object.keys(o);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(o);
    e && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(o, s).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function kn(o) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Mo(Object(t), !0).forEach(function(n) {
      Ue(o, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(t)) : Mo(Object(t)).forEach(function(n) {
      Object.defineProperty(o, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return o;
}
function rd(o, e) {
  if (o == null)
    return {};
  var t = {}, n = Object.keys(o), s, i;
  for (i = 0; i < n.length; i++)
    s = n[i], !(e.indexOf(s) >= 0) && (t[s] = o[s]);
  return t;
}
function od(o, e) {
  if (o == null)
    return {};
  var t = rd(o, e), n, s;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(o);
    for (s = 0; s < i.length; s++)
      n = i[s], !(e.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(o, n) && (t[n] = o[n]);
  }
  return t;
}
function ad(o, e) {
  if (!(o instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function So(o, e) {
  for (var t = 0; t < e.length; t++) {
    var n = e[t];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(o, Xa(n.key), n);
  }
}
function ld(o, e, t) {
  return e && So(o.prototype, e), t && So(o, t), Object.defineProperty(o, "prototype", {
    writable: !1
  }), o;
}
function Wa(o) {
  if (o === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return o;
}
function sr(o, e) {
  return sr = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, s) {
    return n.__proto__ = s, n;
  }, sr(o, e);
}
function cd(o, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  o.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: o,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(o, "prototype", {
    writable: !1
  }), e && sr(o, e);
}
function Ks(o) {
  return Ks = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, Ks(o);
}
function ud() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function hd(o, e) {
  if (e && (typeof e == "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Wa(o);
}
function fd(o) {
  var e = ud();
  return function() {
    var n = Ks(o), s;
    if (e) {
      var i = Ks(this).constructor;
      s = Reflect.construct(n, arguments, i);
    } else
      s = n.apply(this, arguments);
    return hd(this, s);
  };
}
var _e = {
  position: "csm_Position",
  positionRaw: "csm_PositionRaw",
  pointSize: "csm_PointSize",
  fragColor: "csm_FragColor",
  // PBR
  diffuseColor: "csm_DiffuseColor",
  // Color + alpha
  normal: "csm_Normal",
  // Normal
  roughness: "csm_Roughness",
  // Roughness
  metalness: "csm_Metalness",
  // Metalness
  emissive: "csm_Emissive",
  // Emissive
  ao: "csm_AO",
  // AO
  bump: "csm_Bump",
  // Bump
  depthAlpha: "csm_DepthAlpha"
  // Depth
}, lt, Un, dd = (lt = {}, Ue(lt, "".concat(_e.normal), {
  "#include <beginnormal_vertex>": `
    vec3 objectNormal = `.concat(_e.normal, `;
    #ifdef USE_TANGENT
	    vec3 objectTangent = vec3( tangent.xyz );
    #endif
    `)
}), Ue(lt, "".concat(_e.position), {
  "#include <begin_vertex>": `
    vec3 transformed = `.concat(_e.position, `;
  `)
}), Ue(lt, "".concat(_e.positionRaw), {
  "#include <begin_vertex>": `
    vec4 csm_internal_positionUnprojected = `.concat(_e.positionRaw, `;
    mat4x4 csm_internal_unprojectMatrix = projectionMatrix * modelViewMatrix;
    #ifdef USE_INSTANCING
      csm_internal_unprojectMatrix = csm_internal_unprojectMatrix * instanceMatrix;
    #endif
    csm_internal_positionUnprojected = inverse(csm_internal_unprojectMatrix) * csm_internal_positionUnprojected;
    vec3 transformed = csm_internal_positionUnprojected.xyz;
  `)
}), Ue(lt, "".concat(_e.pointSize), {
  "gl_PointSize = size;": `
    gl_PointSize = `.concat(_e.pointSize, `;
    `)
}), Ue(lt, "".concat(_e.diffuseColor), {
  "#include <color_fragment>": `
    #include <color_fragment>
    diffuseColor = `.concat(_e.diffuseColor, `;
  `)
}), Ue(lt, "".concat(_e.fragColor), {
  "#include <dithering_fragment>": `
    #include <dithering_fragment>
    gl_FragColor  = `.concat(_e.fragColor, `;
  `)
}), Ue(lt, "".concat(_e.emissive), {
  "vec3 totalEmissiveRadiance = emissive;": `
    vec3 totalEmissiveRadiance = `.concat(_e.emissive, `;
    `)
}), Ue(lt, "".concat(_e.roughness), {
  "#include <roughnessmap_fragment>": `
    #include <roughnessmap_fragment>
    roughnessFactor = `.concat(_e.roughness, `;
    `)
}), Ue(lt, "".concat(_e.metalness), {
  "#include <metalnessmap_fragment>": `
    #include <metalnessmap_fragment>
    metalnessFactor = `.concat(_e.metalness, `;
    `)
}), Ue(lt, "".concat(_e.ao), {
  "#include <aomap_fragment>": `
    #include <aomap_fragment>
    reflectedLight.indirectDiffuse *= 1. - `.concat(_e.ao, `;
    `)
}), Ue(lt, "".concat(_e.bump), {
  "#include <normal_fragment_maps>": `
    #include <normal_fragment_maps>

    vec3 csm_internal_orthogonal = `.concat(_e.bump, " - (dot(").concat(_e.bump, `, normal) * normal);
    vec3 csm_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_internal_orthogonal;
    normal = normalize(normal - csm_internal_projectedbump);
    `)
}), Ue(lt, "".concat(_e.depthAlpha), {
  "gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );": `
      gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity * `.concat(_e.depthAlpha, ` );
    `),
  "gl_FragColor = packDepthToRGBA( fragCoordZ );": `
      gl_FragColor = packDepthToRGBA( fragCoordZ );
      gl_FragColor.a *= `.concat(_e.depthAlpha, `;
    `)
}), lt), pd = (Un = {}, Ue(Un, "".concat(_e.position), {
  "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );": `
    gl_Position = projectionMatrix * modelViewMatrix * vec4( `.concat(_e.position, `, 1.0 );
  `)
}), Ue(Un, "".concat(_e.positionRaw), {
  "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );": `
    gl_Position = `.concat(_e.position, `;
  `)
}), Ue(Un, "".concat(_e.diffuseColor), {
  "gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );": `
    gl_FragColor = `.concat(_e.diffuseColor, `;
  `)
}), Ue(Un, "".concat(_e.fragColor), {
  "gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );": `
    gl_FragColor = `.concat(_e.fragColor, `;
  `)
}), Un), md = (
  /* glsl */
  `

#ifdef IS_VERTEX
    // csm_Position & csm_PositionRaw
    #ifdef IS_UNKNOWN
        vec3 csm_Position = vec3(0.0);
        vec4 csm_PositionRaw = vec4(0.0);
        vec3 csm_Normal = vec3(0.0);
    #else
        vec3 csm_Position = position;
        vec4 csm_PositionRaw = projectionMatrix * modelViewMatrix * vec4(position, 1.);
        vec3 csm_Normal = normal;
    #endif

    // csm_PointSize
    #ifdef IS_POINTSMATERIAL
        float csm_PointSize = size;
    #endif
#else
    // csm_DiffuseColor & csm_FragColor
    #if defined IS_UNKNOWN || defined IS_SHADERMATERIAL || defined IS_MESHDEPTHMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_SHADOWMATERIAL
        vec4 csm_DiffuseColor = vec4(1.0, 0.0, 1.0, 1.0);
        vec4 csm_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #else
        #ifdef USE_MAP
            vec4 _csm_sampledDiffuseColor = texture2D(map, vMapUv);

            #ifdef DECODE_VIDEO_TEXTURE
            // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)
            _csm_sampledDiffuseColor = vec4(mix(pow(_csm_sampledDiffuseColor.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), _csm_sampledDiffuseColor.rgb * 0.0773993808, vec3(lessThanEqual(_csm_sampledDiffuseColor.rgb, vec3(0.04045)))), _csm_sampledDiffuseColor.w);
            #endif

            vec4 csm_DiffuseColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;
            vec4 csm_FragColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;
        #else
            vec4 csm_DiffuseColor = vec4(diffuse, opacity);
            vec4 csm_FragColor = vec4(diffuse, opacity);
        #endif
    #endif

    // csm_Emissive, csm_Roughness, csm_Metalness
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL
        vec3 csm_Emissive = emissive;
        float csm_Roughness = roughness;
        float csm_Metalness = metalness;
    #endif

    // csm_AO
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL
        float csm_AO = 0.0;
    #endif

    // csm_Bump
    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL 
        vec3 csm_Bump = vec3(0.0);
    #endif

    float csm_DepthAlpha = 1.0;
#endif
`
), gd = (
  /* glsl */
  `
    varying mat4 csm_internal_vModelViewMatrix;
`
), yd = (
  /* glsl */
  `
    csm_internal_vModelViewMatrix = modelViewMatrix;
`
), vd = (
  /* glsl */
  `
    varying mat4 csm_internal_vModelViewMatrix;
`
), _d = (
  /* glsl */
  `
    
`
), ct, xd = (ct = {}, Ue(ct, "".concat(_e.position), "*"), Ue(ct, "".concat(_e.positionRaw), "*"), Ue(ct, "".concat(_e.normal), "*"), Ue(ct, "".concat(_e.pointSize), ["PointsMaterial"]), Ue(ct, "".concat(_e.diffuseColor), "*"), Ue(ct, "".concat(_e.fragColor), "*"), Ue(ct, "".concat(_e.emissive), ["MeshStandardMaterial", "MeshPhysicalMaterial"]), Ue(ct, "".concat(_e.roughness), ["MeshStandardMaterial", "MeshPhysicalMaterial"]), Ue(ct, "".concat(_e.metalness), ["MeshStandardMaterial", "MeshPhysicalMaterial"]), Ue(ct, "".concat(_e.ao), ["MeshStandardMaterial", "MeshPhysicalMaterial", "MeshBasicMaterial", "MeshLambertMaterial", "MeshPhongMaterial", "MeshToonMaterial"]), Ue(ct, "".concat(_e.bump), ["MeshLambertMaterial", "MeshMatcapMaterial", "MeshNormalMaterial", "MeshPhongMaterial", "MeshPhysicalMaterial", "MeshStandardMaterial", "MeshToonMaterial", "ShadowMaterial"]), Ue(ct, "".concat(_e.depthAlpha), "*"), ct), wd = ["baseMaterial", "fragmentShader", "vertexShader", "uniforms", "patchMap", "cacheKey", "silent"], Td = function(e, t, n) {
  return e.split(t).join(n);
}, bd = function(e) {
  return e.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}, Ed = function(e, t) {
  return new RegExp("\\b".concat(bd(t), "\\b")).test(e);
};
function Md(o) {
  try {
    new o();
  } catch (e) {
    if (e.message.indexOf("is not a constructor") >= 0)
      return !1;
  }
  return !0;
}
function Sd(o, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  Object.assign(o, e);
  var n = Object.getPrototypeOf(e);
  Object.entries(Object.getOwnPropertyDescriptors(n)).filter(function(s) {
    var i = typeof s[1].get == "function", r = typeof s[1].set == "function", a = typeof s[1].value == "function", l = s[0] === "constructor";
    return (i || r || a) && !l;
  }).forEach(function(s) {
    if (typeof o[s[0]] == "function") {
      t || console.warn("Function ".concat(s[0], " already exists on CSM, renaming to base_").concat(s[0]));
      var i = "base_".concat(s[0]);
      o[i] = s[1].value.bind(o);
      return;
    }
    Object.defineProperty(o, s[0], s[1]);
  });
}
function Ad(o) {
  var e = o.toString().trim(), t = e.substring(e.indexOf("{") + 1, e.lastIndexOf("}"));
  return t.trim().length === 0;
}
function Ao(o) {
  return o.replace(/\s/g, "");
}
function Pd(o, e, t) {
  var n = o.lastIndexOf(e);
  return n === -1 ? o : o.substring(0, n) + t + o.substring(n + e.length);
}
var Rd = /* @__PURE__ */ function(o) {
  cd(t, o);
  var e = fd(t);
  function t(n) {
    var s, i = n.baseMaterial, r = n.fragmentShader, a = n.vertexShader, l = n.uniforms, c = n.patchMap, u = n.cacheKey, h = n.silent, m = od(n, wd);
    ad(this, t);
    var p;
    if (Md(i) ? p = new i(m) : (p = i, Object.assign(p, m)), p.type === "RawShaderMaterial")
      throw new Error("CustomShaderMaterial does not support RawShaderMaterial");
    s = e.call(this), Sd(Wa(s), p, h), s.__csm = {
      patchMap: c || {},
      fragmentShader: r || "",
      vertexShader: a || "",
      cacheKey: u,
      baseMaterial: i,
      instanceID: Ar.MathUtils.generateUUID(),
      type: p.type,
      isAlreadyExtended: !Ad(p.onBeforeCompile),
      cacheHash: "",
      silent: h
    }, s.uniforms = kn(kn({}, s.uniforms || {}), l || {});
    {
      var v = s.__csm, _ = v.fragmentShader, y = v.vertexShader, E = s.uniforms;
      s.__csm.cacheHash = s.getCacheHash(), s.generateMaterial(_, y, E);
    }
    return s;
  }
  return ld(t, [{
    key: "update",
    value: function() {
      var s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.uniforms = s.uniforms || this.uniforms, Object.assign(this.__csm, s);
      var i = this.__csm, r = i.fragmentShader, a = i.vertexShader, l = this.uniforms, c = this.getCacheHash();
      this.__csm.cacheHash = c, this.generateMaterial(r, a, l);
    }
    /**
     * Returns a new instance of this material with the same options.
     *
     * @returns A clone of this material.
     */
  }, {
    key: "clone",
    value: function() {
      var s = {
        baseMaterial: this.__csm.baseMaterial,
        fragmentShader: this.__csm.fragmentShader,
        vertexShader: this.__csm.vertexShader,
        uniforms: this.uniforms,
        silent: this.__csm.silent,
        patchMap: this.__csm.patchMap,
        cacheKey: this.__csm.cacheKey
      }, i = new this.constructor(s);
      return Object.assign(this, i), i;
    }
    /**
     * Internally calculates the cache key for this instance of CSM.
     * If no specific CSM inputs are provided, the cache key is the same as the default
     * cache key, i.e. `baseMaterial.onBeforeCompile.toString()`. Not meant to be called directly.
     *
     * This method is quite expensive owing to the hashing function and string manip.
     *
     * TODO:
     * - Optimize string manip.
     * - Find faster hash function
     *
     * @returns {string} A cache key for this instance of CSM.
     */
  }, {
    key: "getCacheHash",
    value: function() {
      var s = this.__csm, i = s.fragmentShader, r = s.vertexShader, a = this.uniforms, l = Object.values(a).reduce(function(u, h) {
        var m = h.value;
        return u + JSON.stringify(m);
      }, ""), c = Ao(i) + Ao(r) + l;
      return c.trim().length > 0 ? Lf(c) : this.customProgramCacheKey();
    }
    /**
     * Does the internal shader generation. Not meant to be called directly.
     *
     * @param fragmentShader
     * @param vertexShader
     * @param uniforms
     */
  }, {
    key: "generateMaterial",
    value: function(s, i, r) {
      var a = this, l = this.parseShader(s), c = this.parseShader(i);
      this.uniforms = r || {}, this.customProgramCacheKey = function() {
        return a.__csm.cacheHash;
      };
      var u = function(p) {
        try {
          if (l) {
            var v = a.patchShader(l, p.fragmentShader, !0);
            p.fragmentShader = a.getMaterialDefine() + v;
          }
          if (c) {
            var _ = a.patchShader(c, p.vertexShader);
            p.vertexShader = `#define IS_VERTEX;
` + _, p.vertexShader = a.getMaterialDefine() + p.vertexShader;
          }
          p.uniforms = kn(kn({}, p.uniforms), a.uniforms), a.uniforms = p.uniforms;
        } catch (y) {
          console.error(y);
        }
      };
      if (this.__csm.isAlreadyExtended) {
        var h = this.onBeforeCompile;
        this.onBeforeCompile = function(m, p) {
          h(m, p), u(m);
        };
      } else
        this.onBeforeCompile = u;
      this.needsUpdate = !0;
    }
    /**
     * Patches input shader with custom shader. Not meant to be called directly.
     * @param customShader
     * @param shader
     * @param isFrag
     * @returns
     */
  }, {
    key: "patchShader",
    value: function(s, i, r) {
      var a = this, l = i, c = kn(kn({}, this.getPatchMapForMaterial()), this.__csm.patchMap);
      Object.keys(c).forEach(function(m) {
        Object.keys(c[m]).forEach(function(p) {
          var v = xd[m], _ = a.__csm.type;
          if (m === "*" || Ed(s.main, m))
            if (!v || Array.isArray(v) && v.includes(_) || v === "*")
              l = Td(l, p, c[m][p]);
            else
              throw new Error("CSM: ".concat(m, " is not available in ").concat(_, ". Shader cannot compile."));
        });
      }), l = l.replace("void main() {", `
        #ifndef CSM_IS_HEAD_DEFAULTS_DEFINED
          `.concat(r ? vd : gd, `
          #define CSM_IS_HEAD_DEFAULTS_DEFINED 1
        #endif

        `).concat(s.header, `
        
        void main() {
          #ifndef CSM_IS_DEFAULTS_DEFINED
            `).concat(md, `
            #define CSM_IS_DEFAULTS_DEFINED 1
          #endif
          
          #ifndef CSM_IS_MAIN_DEFAULTS_DEFINED
            `).concat(r ? _d : yd, `
            #define CSM_IS_MAIN_DEFAULTS_DEFINED 1
          #endif

          // CSM_START
      `));
      var u = this.__csm.isAlreadyExtended, h = l.includes("// CSM_END");
      return u && h ? l = Pd(l, "// CSM_END", `
          // CSM_END
          `.concat(s.main, `
          // CSM_END
        `)) : l = l.replace("// CSM_START", `
        // CSM_START
        `.concat(s.main, `
        // CSM_END
          `)), l = s.defines + l, l;
    }
    /**
     * This method is expensive owing to the tokenization and parsing of the shader.
     *
     * TODO:
     * - Replace tokenization with regex
     *
     * @param shader
     * @returns
     */
  }, {
    key: "parseShader",
    value: function(s) {
      if (s) {
        var i = s.replace(/\/\*\*(.*?)\*\/|\/\/(.*?)\n/gm, ""), r = Qf(i), a = sd(r), l = a.map(function(h) {
          return h.name;
        }).indexOf("main"), c = Eo(r.slice(0, l >= 0 ? a[l].outer[0] : void 0)), u = l >= 0 ? this.getShaderFromIndex(r, a[l].body) : "";
        return {
          defines: "",
          header: c,
          main: u
        };
      }
    }
    /**
     * Gets the material type as a string. Not meant to be called directly.
     * @returns
     */
  }, {
    key: "getMaterialDefine",
    value: function() {
      var s = this.__csm.type;
      return s ? "#define IS_".concat(s.toUpperCase(), `;
`) : `#define IS_UNKNOWN;
`;
    }
    /**
     * Gets the right patch map for the material. Not meant to be called directly.
     * @returns
     */
  }, {
    key: "getPatchMapForMaterial",
    value: function() {
      switch (this.__csm.type) {
        case "ShaderMaterial":
          return pd;
        default:
          return dd;
      }
    }
    /**
     * Gets the shader from the tokens. Not meant to be called directly.
     * @param tokens
     * @param index
     * @returns
     */
  }, {
    key: "getShaderFromIndex",
    value: function(s, i) {
      return Eo(s.slice(i[0], i[1]));
    }
  }]), t;
}(Ar.Material);
const Cd = ["args"], ng = /* @__PURE__ */ pe({
  __name: "index",
  props: {
    baseMaterial: { type: Function },
    vertexShader: {},
    fragmentShader: {},
    silent: { type: Boolean },
    uniforms: {}
  },
  setup(o, { expose: e }) {
    const t = o, n = xe(null), { extend: s } = je();
    return s({ CustomShaderMaterial: Rd }), e({ value: n }), (i, r) => (fe(), de("TresCustomShaderMaterial", {
      ref_key: "customShaderMaterialClass",
      ref: n,
      args: [t]
    }, null, 8, Cd));
  }
}), Id = () => parseInt(rr.replace(/\D+/g, "")), Dd = /* @__PURE__ */ Id();
class Ld extends Xt {
  constructor(t = new le()) {
    super({
      uniforms: {
        inputBuffer: new Re(null),
        depthBuffer: new Re(null),
        resolution: new Re(new le()),
        texelSize: new Re(new le()),
        halfTexelSize: new Re(new le()),
        kernel: new Re(0),
        scale: new Re(1),
        cameraNear: new Re(0),
        cameraFar: new Re(1),
        minDepthThreshold: new Re(0),
        maxDepthThreshold: new Re(1),
        depthScale: new Re(0),
        depthToBlurRatioBias: new Re(0.25)
      },
      fragmentShader: `#include <common>
        #include <dithering_pars_fragment>      
        uniform sampler2D inputBuffer;
        uniform sampler2D depthBuffer;
        uniform float cameraNear;
        uniform float cameraFar;
        uniform float minDepthThreshold;
        uniform float maxDepthThreshold;
        uniform float depthScale;
        uniform float depthToBlurRatioBias;
        varying vec2 vUv;
        varying vec2 vUv0;
        varying vec2 vUv1;
        varying vec2 vUv2;
        varying vec2 vUv3;

        void main() {
          float depthFactor = 0.0;
          
          #ifdef USE_DEPTH
            vec4 depth = texture2D(depthBuffer, vUv);
            depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));
            depthFactor *= depthScale;
            depthFactor = max(0.0, min(1.0, depthFactor + 0.25));
          #endif
          
          vec4 sum = texture2D(inputBuffer, mix(vUv0, vUv, depthFactor));
          sum += texture2D(inputBuffer, mix(vUv1, vUv, depthFactor));
          sum += texture2D(inputBuffer, mix(vUv2, vUv, depthFactor));
          sum += texture2D(inputBuffer, mix(vUv3, vUv, depthFactor));
          gl_FragColor = sum * 0.25 ;

          #include <dithering_fragment>
          #include <tonemapping_fragment>
          #include <${Dd >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
        }`,
      vertexShader: `uniform vec2 texelSize;
        uniform vec2 halfTexelSize;
        uniform float kernel;
        uniform float scale;
        varying vec2 vUv;
        varying vec2 vUv0;
        varying vec2 vUv1;
        varying vec2 vUv2;
        varying vec2 vUv3;

        void main() {
          vec2 uv = position.xy * 0.5 + 0.5;
          vUv = uv;

          vec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;
          vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);
          vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);
          vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);
          vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);

          gl_Position = vec4(position.xy, 1.0, 1.0);
        }`,
      blending: Fl,
      depthWrite: !1,
      depthTest: !1
    });
    oe(this, "kernel");
    this.toneMapped = !1, this.setTexelSize(t.x, t.y), this.kernel = new Float32Array([0, 1, 2, 2, 3]);
  }
  setTexelSize(t, n) {
    this.uniforms.texelSize.value.set(t, n), this.uniforms.halfTexelSize.value.set(t, n).multiplyScalar(0.5);
  }
  setResolution(t) {
    this.uniforms.resolution.value.copy(t);
  }
}
class Od {
  constructor({
    resolution: e,
    width: t = 500,
    height: n = 500,
    minDepthThreshold: s = 0,
    maxDepthThreshold: i = 1,
    depthScale: r = 0,
    depthToBlurRatioBias: a = 0.25
  }) {
    oe(this, "renderTargetA");
    oe(this, "renderTargetB");
    oe(this, "convolutionMaterial");
    oe(this, "scene");
    oe(this, "camera");
    oe(this, "screen");
    oe(this, "renderToScreen", !1);
    this.renderTargetA = new bn(e, e, {
      minFilter: At,
      magFilter: At,
      stencilBuffer: !1,
      depthBuffer: !1,
      type: un
    }), this.renderTargetB = this.renderTargetA.clone(), this.convolutionMaterial = new Ld(), this.convolutionMaterial.setTexelSize(1 / t, 1 / n), this.convolutionMaterial.setResolution(new le(t, n)), this.scene = new Xs(), this.camera = new kl(), this.convolutionMaterial.uniforms.minDepthThreshold.value = s, this.convolutionMaterial.uniforms.maxDepthThreshold.value = i, this.convolutionMaterial.uniforms.depthScale.value = r, this.convolutionMaterial.uniforms.depthToBlurRatioBias.value = a, this.convolutionMaterial.defines.USE_DEPTH = r > 0;
    const l = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]), c = new Float32Array([0, 0, 2, 0, 0, 2]), u = new rt();
    u.setAttribute("position", new pt(l, 3)), u.setAttribute("uv", new pt(c, 2)), this.screen = new ae(u, this.convolutionMaterial), this.screen.frustumCulled = !1, this.scene.add(this.screen);
  }
  render(e, t, n) {
    const s = this.scene, i = this.camera, r = this.renderTargetA, a = this.renderTargetB, l = this.convolutionMaterial, c = l.uniforms;
    c.depthBuffer.value = t.depthTexture;
    const u = l.kernel;
    let h = t, m, p, v;
    for (p = 0, v = u.length - 1; p < v; ++p)
      m = p & 1 ? a : r, c.kernel.value = u[p], c.inputBuffer.value = h.texture, e.setRenderTarget(m), e.render(s, i), h = m;
    c.kernel.value = u[p], c.inputBuffer.value = h.texture, e.setRenderTarget(this.renderToScreen ? null : n), e.render(s, i);
  }
}
class Fd extends us {
  constructor(t = {}) {
    super(t);
    oe(this, "_tDepth", { value: null });
    oe(this, "_distortionMap", { value: null });
    oe(this, "_tDiffuse", { value: null });
    oe(this, "_tDiffuseBlur", { value: null });
    oe(this, "_textureMatrix", { value: null });
    oe(this, "_hasBlur", { value: !1 });
    oe(this, "_mirror", { value: 0 });
    oe(this, "_mixBlur", { value: 0 });
    oe(this, "_blurStrength", { value: 0.5 });
    oe(this, "_minDepthThreshold", { value: 0.9 });
    oe(this, "_maxDepthThreshold", { value: 1 });
    oe(this, "_depthScale", { value: 0 });
    oe(this, "_depthToBlurRatioBias", { value: 0.25 });
    oe(this, "_distortion", { value: 1 });
    oe(this, "_mixContrast", { value: 1 });
    this.setValues(t);
  }
  onBeforeCompile(t) {
    var n;
    (n = t.defines) != null && n.USE_UV || (t.defines.USE_UV = ""), t.uniforms.hasBlur = this._hasBlur, t.uniforms.tDiffuse = this._tDiffuse, t.uniforms.tDepth = this._tDepth, t.uniforms.distortionMap = this._distortionMap, t.uniforms.tDiffuseBlur = this._tDiffuseBlur, t.uniforms.textureMatrix = this._textureMatrix, t.uniforms.mirror = this._mirror, t.uniforms.mixBlur = this._mixBlur, t.uniforms.mixStrength = this._blurStrength, t.uniforms.minDepthThreshold = this._minDepthThreshold, t.uniforms.maxDepthThreshold = this._maxDepthThreshold, t.uniforms.depthScale = this._depthScale, t.uniforms.depthToBlurRatioBias = this._depthToBlurRatioBias, t.uniforms.distortion = this._distortion, t.uniforms.mixContrast = this._mixContrast, t.vertexShader = `
        uniform mat4 textureMatrix;
        varying vec4 my_vUv;
      ${t.vertexShader}`, t.vertexShader = t.vertexShader.replace(
      "#include <project_vertex>",
      `#include <project_vertex>
        my_vUv = textureMatrix * vec4( position, 1.0 );
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );`
    ), t.fragmentShader = `
        uniform sampler2D tDiffuse;
        uniform sampler2D tDiffuseBlur;
        uniform sampler2D tDepth;
        uniform sampler2D distortionMap;
        uniform float distortion;
        uniform float cameraNear;
			  uniform float cameraFar;
        uniform bool hasBlur;
        uniform float mixBlur;
        uniform float mirror;
        uniform float mixStrength;
        uniform float minDepthThreshold;
        uniform float maxDepthThreshold;
        uniform float mixContrast;
        uniform float depthScale;
        uniform float depthToBlurRatioBias;
        varying vec4 my_vUv;
        ${t.fragmentShader}`, t.fragmentShader = t.fragmentShader.replace(
      "#include <emissivemap_fragment>",
      `#include <emissivemap_fragment>

      float distortionFactor = 0.0;
      #ifdef USE_DISTORTION
        distortionFactor = texture2D(distortionMap, vUv).r * distortion;
      #endif

      vec4 new_vUv = my_vUv;
      new_vUv.x += distortionFactor;
      new_vUv.y += distortionFactor;

      vec4 base = texture2DProj(tDiffuse, new_vUv);
      vec4 blur = texture2DProj(tDiffuseBlur, new_vUv);

      vec4 merge = base;

      #ifdef USE_NORMALMAP
        vec2 normal_uv = vec2(0.0);
        vec4 normalColor = texture2D(normalMap, vUv * normalScale);
        vec3 my_normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );
        vec3 coord = new_vUv.xyz / new_vUv.w;
        normal_uv = coord.xy + coord.z * my_normal.xz * 0.05;
        vec4 base_normal = texture2D(tDiffuse, normal_uv);
        vec4 blur_normal = texture2D(tDiffuseBlur, normal_uv);
        merge = base_normal;
        blur = blur_normal;
      #endif

      float depthFactor = 0.0001;
      float blurFactor = 0.0;

      #ifdef USE_DEPTH
        vec4 depth = texture2DProj(tDepth, new_vUv);
        depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));
        depthFactor *= depthScale;
        depthFactor = max(0.0001, min(1.0, depthFactor));

        #ifdef USE_BLUR
          blur = blur * min(1.0, depthFactor + depthToBlurRatioBias);
          merge = merge * min(1.0, depthFactor + 0.5);
        #else
          merge = merge * depthFactor;
        #endif

      #endif

      float reflectorRoughnessFactor = roughness;
      #ifdef USE_ROUGHNESSMAP
        vec4 reflectorTexelRoughness = texture2D( roughnessMap, vUv );
        reflectorRoughnessFactor *= reflectorTexelRoughness.g;
      #endif

      #ifdef USE_BLUR
        blurFactor = min(1.0, mixBlur * reflectorRoughnessFactor);
        merge = mix(merge, blur, blurFactor);
      #endif

      vec4 newMerge = vec4(0.0, 0.0, 0.0, 1.0);
      newMerge.r = (merge.r - 0.5) * mixContrast + 0.5;
      newMerge.g = (merge.g - 0.5) * mixContrast + 0.5;
      newMerge.b = (merge.b - 0.5) * mixContrast + 0.5;

      diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + newMerge.rgb * mixStrength);
      `
    );
  }
  get tDiffuse() {
    return this._tDiffuse.value;
  }
  set tDiffuse(t) {
    this._tDiffuse.value = t;
  }
  get tDepth() {
    return this._tDepth.value;
  }
  set tDepth(t) {
    this._tDepth.value = t;
  }
  get distortionMap() {
    return this._distortionMap.value;
  }
  set distortionMap(t) {
    this._distortionMap.value = t;
  }
  get tDiffuseBlur() {
    return this._tDiffuseBlur.value;
  }
  set tDiffuseBlur(t) {
    this._tDiffuseBlur.value = t;
  }
  get textureMatrix() {
    return this._textureMatrix.value;
  }
  set textureMatrix(t) {
    this._textureMatrix.value = t;
  }
  get hasBlur() {
    return this._hasBlur.value;
  }
  set hasBlur(t) {
    this._hasBlur.value = t;
  }
  get mirror() {
    return this._mirror.value;
  }
  set mirror(t) {
    this._mirror.value = t;
  }
  get mixBlur() {
    return this._mixBlur.value;
  }
  set mixBlur(t) {
    this._mixBlur.value = t;
  }
  get mixStrength() {
    return this._blurStrength.value;
  }
  set mixStrength(t) {
    this._blurStrength.value = t;
  }
  get minDepthThreshold() {
    return this._minDepthThreshold.value;
  }
  set minDepthThreshold(t) {
    this._minDepthThreshold.value = t;
  }
  get maxDepthThreshold() {
    return this._maxDepthThreshold.value;
  }
  set maxDepthThreshold(t) {
    this._maxDepthThreshold.value = t;
  }
  get depthScale() {
    return this._depthScale.value;
  }
  set depthScale(t) {
    this._depthScale.value = t;
  }
  get depthToBlurRatioBias() {
    return this._depthToBlurRatioBias.value;
  }
  set depthToBlurRatioBias(t) {
    this._depthToBlurRatioBias.value = t;
  }
  get distortion() {
    return this._distortion.value;
  }
  set distortion(t) {
    this._distortion.value = t;
  }
  get mixContrast() {
    return this._mixContrast.value;
  }
  set mixContrast(t) {
    this._mixContrast.value = t;
  }
}
const kd = ["texture-matrix", "mirror", "t-diffuse", "t-depth", "t-diffuse-blur", "has-blur", "mix-strength", "min-depth-threshold", "max-depth-threshold", "depth-scale", "depth-to-blur-ratio-bias", "distortion", "distortionMap", "mix-contrast", "defines-USE_BLUR", "defines-USE_DEPTH", "defines-USE_DISTORTION"], sg = /* @__PURE__ */ pe({
  __name: "index",
  props: {
    resolution: { default: 256 },
    mixBlur: { default: 0 },
    mixStrength: { default: 1 },
    blur: { default: () => [0, 0] },
    mirror: { default: 0 },
    minDepthThreshold: { default: 0.9 },
    maxDepthThreshold: { default: 1 },
    depthScale: { default: 0 },
    depthToBlurRatioBias: { default: 0.25 },
    distortionMap: {},
    distortion: { default: 1 },
    mixContrast: { default: 1 },
    reflectorOffset: { default: 0 }
  },
  setup(o) {
    const e = o;
    function t(Z, W) {
      let X;
      return Z.traverse((V) => {
        V.isMesh && V.material && V.material.uuid === W && (X = V);
      }), X;
    }
    function n(Z) {
      var X, V;
      if (f.reflectorWorldPosition.setFromMatrixPosition(Z.matrixWorld), f.cameraWorldPosition.setFromMatrixPosition((X = y.value) == null ? void 0 : X.matrixWorld), f.rotationMatrix.extractRotation(Z.matrixWorld), f.normal.set(0, 0, 1), f.normal.applyMatrix4(f.rotationMatrix), f.reflectorWorldPosition.addScaledVector(f.normal, e.reflectorOffset), f.view.subVectors(f.reflectorWorldPosition, f.cameraWorldPosition), f.view.dot(f.normal) > 0)
        return;
      f.view.reflect(f.normal).negate(), f.view.add(f.reflectorWorldPosition), f.rotationMatrix.extractRotation((V = y.value) == null ? void 0 : V.matrixWorld), f.lookAtPosition.set(0, 0, -1), f.lookAtPosition.applyMatrix4(f.rotationMatrix), f.lookAtPosition.add(f.cameraWorldPosition), f.target.subVectors(f.reflectorWorldPosition, f.lookAtPosition), f.target.reflect(f.normal).negate(), f.target.add(f.reflectorWorldPosition), f.virtualCamera.position.copy(f.view), f.virtualCamera.up.set(0, 1, 0), f.virtualCamera.up.applyMatrix4(f.rotationMatrix), f.virtualCamera.up.reflect(f.normal), f.virtualCamera.lookAt(f.target), f.virtualCamera.far = (y == null ? void 0 : y.value).far, f.virtualCamera.updateMatrixWorld(), f.virtualCamera.projectionMatrix.copy((y == null ? void 0 : y.value).projectionMatrix), f.textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), f.textureMatrix.multiply(f.virtualCamera.projectionMatrix), f.textureMatrix.multiply(f.virtualCamera.matrixWorldInverse), f.textureMatrix.multiply(Z.matrixWorld), f.reflectorPlane.setFromNormalAndCoplanarPoint(f.normal, f.reflectorWorldPosition), f.reflectorPlane.applyMatrix4(f.virtualCamera.matrixWorldInverse), f.clipPlane.set(
        f.reflectorPlane.normal.x,
        f.reflectorPlane.normal.y,
        f.reflectorPlane.normal.z,
        f.reflectorPlane.constant
      );
      const W = f.virtualCamera.projectionMatrix;
      f.q.x = (Math.sign(f.clipPlane.x) + W.elements[8]) / W.elements[0], f.q.y = (Math.sign(f.clipPlane.y) + W.elements[9]) / W.elements[5], f.q.z = -1, f.q.w = (1 + W.elements[10]) / W.elements[14], f.clipPlane.multiplyScalar(2 / f.clipPlane.dot(f.q)), W.elements[2] = f.clipPlane.x, W.elements[6] = f.clipPlane.y, W.elements[10] = f.clipPlane.z + 1, W.elements[14] = f.clipPlane.w;
    }
    const {
      resolution: s,
      minDepthThreshold: i,
      maxDepthThreshold: r,
      depthScale: a,
      depthToBlurRatioBias: l,
      blur: c,
      mirror: u,
      mixBlur: h,
      mixStrength: m,
      distortion: p,
      distortionMap: v,
      mixContrast: _
    } = Fe(e), { camera: y, scene: E, renderer: R, extend: T } = je();
    T({ MeshReflectorMaterial: Fd });
    const g = xe(), A = xe(), x = xe(), M = xe(), d = Ne(() => typeof c.value == "number" ? [c.value, c.value] : c.value), w = Ne(() => d.value[0] > 0 || d.value[1] > 0), f = {
      reflectorPlane: new lr(),
      normal: new ee(),
      reflectorWorldPosition: new ee(),
      cameraWorldPosition: new ee(),
      rotationMatrix: new De(),
      lookAtPosition: new ee(0, 0, -1),
      clipPlane: new ht(),
      view: new ee(),
      target: new ee(),
      q: new ht(),
      virtualCamera: new Mt(),
      textureMatrix: new De()
    };
    ft(() => {
      var W;
      (W = g.value) == null || W.texture.dispose();
      const Z = {
        minFilter: At,
        magFilter: At,
        type: un
      };
      g.value = new bn(
        s.value,
        s.value,
        {
          ...Z,
          depthBuffer: !0,
          depthTexture: new sa(
            s.value,
            s.value,
            Ul,
            Bl
          )
        }
      ), A.value = new bn(
        s.value,
        s.value,
        Z
      ), x.value = new Od({
        resolution: s.value,
        width: d.value[0],
        height: d.value[1],
        minDepthThreshold: i.value,
        maxDepthThreshold: r.value,
        depthScale: a.value,
        depthToBlurRatioBias: l.value
      }), M.value = {
        mirror: u,
        textureMatrix: f.textureMatrix,
        mixBlur: h,
        tDiffuse: g.value.texture,
        tDepth: g.value.depthTexture,
        tDiffuseBlur: g.value.texture,
        hasBlur: w,
        mixStrength: m,
        minDepthThreshold: i,
        maxDepthThreshold: r,
        depthScale: a,
        depthToBlurRatioBias: l,
        distortion: p,
        distortionMap: v.value,
        mixContrast: _,
        "defines-USE_BLUR": w.value ? "" : void 0,
        "defines-USE_DEPTH": a.value > 0 ? "" : void 0,
        "defines-USE_DISTORTION": v.value ? "" : void 0
      };
    });
    const P = xe(), { onLoop: I } = Ke();
    I(() => {
      var V;
      if (!P.value || !R.value || !g.value || !y.value)
        return;
      const Z = t(E.value, P.value.uuid);
      if (!Z)
        return;
      Z.visible = !1;
      const W = R.value.xr.enabled, X = R.value.shadowMap.autoUpdate;
      n(Z), R.value.shadowMap.autoUpdate = !1, R.value.setRenderTarget(g.value), R.value.autoClear || R.value.clear(), R.value.render(E.value, f.virtualCamera), (V = x == null ? void 0 : x.value) == null || V.render(R.value, g.value, A.value), R.value.xr.enabled = W, R.value.shadowMap.autoUpdate = X, Z.visible = !0, R.value.setRenderTarget(null);
    });
    const K = fa(), N = Ne(() => {
      const Z = {};
      return Object.assign(Z, e), Object.assign(Z, K.value), Z;
    });
    return aa(() => {
      var Z, W;
      (Z = g == null ? void 0 : g.value) == null || Z.dispose(), (W = A == null ? void 0 : A.value) == null || W.dispose();
    }), (Z, W) => {
      var X, V, ne;
      return fe(), de("TresMeshReflectorMaterial", Ye({
        key: `key${M.value["defines-USE_BLUR"]}${M.value["defines-USE_DEPTH"]}${M.value["defines-USE_DISTORTION"]}`,
        ref_key: "materialRef",
        ref: P
      }, N.value, {
        "texture-matrix": f.textureMatrix,
        mirror: z(u),
        "t-diffuse": (X = g.value) == null ? void 0 : X.texture,
        "t-depth": (V = g.value) == null ? void 0 : V.depthTexture,
        "t-diffuse-blur": (ne = A.value) == null ? void 0 : ne.texture,
        "has-blur": w.value,
        "mix-strength": z(m),
        "min-depth-threshold": z(i),
        "max-depth-threshold": z(r),
        "depth-scale": z(a),
        "depth-to-blur-ratio-bias": z(l),
        distortion: z(p),
        distortionMap: z(v),
        "mix-contrast": z(_),
        "defines-USE_BLUR": w.value ? "" : void 0,
        "defines-USE_DEPTH": z(a) > 0 ? "" : void 0,
        "defines-USE_DISTORTION": z(v) ? "" : void 0
      }), null, 16, kd);
    };
  }
}), Ud = ["args"], Bd = ["color"], ig = /* @__PURE__ */ pe({
  __name: "Box",
  props: {
    args: { default: () => [1, 1, 1] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = Fe(t), i = xe();
    return e({
      value: i
    }), (r, a) => (fe(), de("TresMesh", Ye({
      ref_key: "boxRef",
      ref: i
    }, r.$attrs), [
      Te("TresBoxGeometry", { args: z(n) }, null, 8, Ud),
      $e(r.$slots, "default", {}, () => [
        Te("TresMeshBasicMaterial", { color: z(s) }, null, 8, Bd)
      ])
    ], 16));
  }
}), Po = new hs(), Bs = new ee();
class $a extends Nl {
  constructor() {
    super(), this.isLineSegmentsGeometry = !0, this.type = "LineSegmentsGeometry";
    const e = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], t = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], n = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(n), this.setAttribute("position", new it(e, 3)), this.setAttribute("uv", new it(t, 2));
  }
  applyMatrix4(e) {
    const t = this.attributes.instanceStart, n = this.attributes.instanceEnd;
    return t !== void 0 && (t.applyMatrix4(e), n.applyMatrix4(e), t.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  setPositions(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const n = new Yi(t, 6, 1);
    return this.setAttribute("instanceStart", new Vt(n, 3, 0)), this.setAttribute("instanceEnd", new Vt(n, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;
  }
  setColors(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const n = new Yi(t, 6, 1);
    return this.setAttribute("instanceColorStart", new Vt(n, 3, 0)), this.setAttribute("instanceColorEnd", new Vt(n, 3, 3)), this;
  }
  fromWireframeGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromEdgesGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromMesh(e) {
    return this.fromWireframeGeometry(new zl(e.geometry)), this;
  }
  fromLineSegments(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new hs());
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    e !== void 0 && t !== void 0 && (this.boundingBox.setFromBufferAttribute(e), Po.setFromBufferAttribute(t), this.boundingBox.union(Po));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Qs()), this.boundingBox === null && this.computeBoundingBox();
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    if (e !== void 0 && t !== void 0) {
      const n = this.boundingSphere.center;
      this.boundingBox.getCenter(n);
      let s = 0;
      for (let i = 0, r = e.count; i < r; i++)
        Bs.fromBufferAttribute(e, i), s = Math.max(s, n.distanceToSquared(Bs)), Bs.fromBufferAttribute(t, i), s = Math.max(s, n.distanceToSquared(Bs));
      this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
    }
  }
  toJSON() {
  }
  applyMatrix(e) {
    return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e);
  }
}
js.line = {
  worldUnits: { value: 1 },
  linewidth: { value: 1 },
  resolution: { value: new le(1, 1) },
  dashOffset: { value: 0 },
  dashScale: { value: 1 },
  dashSize: { value: 1 },
  gapSize: { value: 1 }
  // todo FIX - maybe change to totalSize
};
Vs.line = {
  uniforms: Js.merge([
    js.common,
    js.fog,
    js.line
  ]),
  vertexShader: (
    /* glsl */
    `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );
				vec3 worldUp = normalize( cross( worldDir, tmpFwd ) );
				vec3 worldFwd = cross( worldDir, worldUp );
				worldPos = position.y < 0.5 ? start: end;

				// height offset
				float hw = linewidth * 0.5;
				worldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// cap extension
					worldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;

					// add width to the box
					worldPos.xyz += worldFwd * hw;

					// endcaps
					if ( position.y > 1.0 || position.y < 0.0 ) {

						worldPos.xyz -= worldFwd * 2.0 * hw;

					}

				#endif

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
  )
};
class _r extends Xt {
  constructor(e) {
    super({
      type: "LineMaterial",
      uniforms: Js.clone(Vs.line.uniforms),
      vertexShader: Vs.line.vertexShader,
      fragmentShader: Vs.line.fragmentShader,
      clipping: !0
      // required for clipping support
    }), this.isLineMaterial = !0, this.setValues(e);
  }
  get color() {
    return this.uniforms.diffuse.value;
  }
  set color(e) {
    this.uniforms.diffuse.value = e;
  }
  get worldUnits() {
    return "WORLD_UNITS" in this.defines;
  }
  set worldUnits(e) {
    e === !0 ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
  }
  get linewidth() {
    return this.uniforms.linewidth.value;
  }
  set linewidth(e) {
    this.uniforms.linewidth && (this.uniforms.linewidth.value = e);
  }
  get dashed() {
    return "USE_DASH" in this.defines;
  }
  set dashed(e) {
    e === !0 !== this.dashed && (this.needsUpdate = !0), e === !0 ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
  }
  get dashScale() {
    return this.uniforms.dashScale.value;
  }
  set dashScale(e) {
    this.uniforms.dashScale.value = e;
  }
  get dashSize() {
    return this.uniforms.dashSize.value;
  }
  set dashSize(e) {
    this.uniforms.dashSize.value = e;
  }
  get dashOffset() {
    return this.uniforms.dashOffset.value;
  }
  set dashOffset(e) {
    this.uniforms.dashOffset.value = e;
  }
  get gapSize() {
    return this.uniforms.gapSize.value;
  }
  set gapSize(e) {
    this.uniforms.gapSize.value = e;
  }
  get opacity() {
    return this.uniforms.opacity.value;
  }
  set opacity(e) {
    this.uniforms && (this.uniforms.opacity.value = e);
  }
  get resolution() {
    return this.uniforms.resolution.value;
  }
  set resolution(e) {
    this.uniforms.resolution.value.copy(e);
  }
  get alphaToCoverage() {
    return "USE_ALPHA_TO_COVERAGE" in this.defines;
  }
  set alphaToCoverage(e) {
    this.defines && (e === !0 !== this.alphaToCoverage && (this.needsUpdate = !0), e === !0 ? (this.defines.USE_ALPHA_TO_COVERAGE = "", this.extensions.derivatives = !0) : (delete this.defines.USE_ALPHA_TO_COVERAGE, this.extensions.derivatives = !1));
  }
}
const Ro = new ee(), Co = new ee(), et = new ht(), tt = new ht(), Ct = new ht(), Fi = new ee(), ki = new De(), nt = new Hl(), Io = new ee(), Ns = new hs(), zs = new Qs(), It = new ht();
let Ot, xn;
function Do(o, e, t) {
  return It.set(0, 0, -e, 1).applyMatrix4(o.projectionMatrix), It.multiplyScalar(1 / It.w), It.x = xn / t.width, It.y = xn / t.height, It.applyMatrix4(o.projectionMatrixInverse), It.multiplyScalar(1 / It.w), Math.abs(Math.max(It.x, It.y));
}
function Nd(o, e) {
  const t = o.matrixWorld, n = o.geometry, s = n.attributes.instanceStart, i = n.attributes.instanceEnd, r = Math.min(n.instanceCount, s.count);
  for (let a = 0, l = r; a < l; a++) {
    nt.start.fromBufferAttribute(s, a), nt.end.fromBufferAttribute(i, a), nt.applyMatrix4(t);
    const c = new ee(), u = new ee();
    Ot.distanceSqToSegment(nt.start, nt.end, u, c), u.distanceTo(c) < xn * 0.5 && e.push({
      point: u,
      pointOnLine: c,
      distance: Ot.origin.distanceTo(u),
      object: o,
      face: null,
      faceIndex: a,
      uv: null,
      uv1: null
    });
  }
}
function zd(o, e, t) {
  const n = e.projectionMatrix, i = o.material.resolution, r = o.matrixWorld, a = o.geometry, l = a.attributes.instanceStart, c = a.attributes.instanceEnd, u = Math.min(a.instanceCount, l.count), h = -e.near;
  Ot.at(1, Ct), Ct.w = 1, Ct.applyMatrix4(e.matrixWorldInverse), Ct.applyMatrix4(n), Ct.multiplyScalar(1 / Ct.w), Ct.x *= i.x / 2, Ct.y *= i.y / 2, Ct.z = 0, Fi.copy(Ct), ki.multiplyMatrices(e.matrixWorldInverse, r);
  for (let m = 0, p = u; m < p; m++) {
    if (et.fromBufferAttribute(l, m), tt.fromBufferAttribute(c, m), et.w = 1, tt.w = 1, et.applyMatrix4(ki), tt.applyMatrix4(ki), et.z > h && tt.z > h)
      continue;
    if (et.z > h) {
      const T = et.z - tt.z, g = (et.z - h) / T;
      et.lerp(tt, g);
    } else if (tt.z > h) {
      const T = tt.z - et.z, g = (tt.z - h) / T;
      tt.lerp(et, g);
    }
    et.applyMatrix4(n), tt.applyMatrix4(n), et.multiplyScalar(1 / et.w), tt.multiplyScalar(1 / tt.w), et.x *= i.x / 2, et.y *= i.y / 2, tt.x *= i.x / 2, tt.y *= i.y / 2, nt.start.copy(et), nt.start.z = 0, nt.end.copy(tt), nt.end.z = 0;
    const _ = nt.closestPointToPointParameter(Fi, !0);
    nt.at(_, Io);
    const y = We.lerp(et.z, tt.z, _), E = y >= -1 && y <= 1, R = Fi.distanceTo(Io) < xn * 0.5;
    if (E && R) {
      nt.start.fromBufferAttribute(l, m), nt.end.fromBufferAttribute(c, m), nt.start.applyMatrix4(r), nt.end.applyMatrix4(r);
      const T = new ee(), g = new ee();
      Ot.distanceSqToSegment(nt.start, nt.end, g, T), t.push({
        point: g,
        pointOnLine: T,
        distance: Ot.origin.distanceTo(g),
        object: o,
        face: null,
        faceIndex: m,
        uv: null,
        uv1: null
      });
    }
  }
}
class Hd extends ae {
  constructor(e = new $a(), t = new _r({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLineSegments2 = !0, this.type = "LineSegments2";
  }
  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...
  computeLineDistances() {
    const e = this.geometry, t = e.attributes.instanceStart, n = e.attributes.instanceEnd, s = new Float32Array(2 * t.count);
    for (let r = 0, a = 0, l = t.count; r < l; r++, a += 2)
      Ro.fromBufferAttribute(t, r), Co.fromBufferAttribute(n, r), s[a] = a === 0 ? 0 : s[a - 1], s[a + 1] = s[a] + Ro.distanceTo(Co);
    const i = new Yi(s, 2, 1);
    return e.setAttribute("instanceDistanceStart", new Vt(i, 1, 0)), e.setAttribute("instanceDistanceEnd", new Vt(i, 1, 1)), this;
  }
  raycast(e, t) {
    const n = this.material.worldUnits, s = e.camera;
    s === null && !n && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
    const i = e.params.Line2 !== void 0 && e.params.Line2.threshold || 0;
    Ot = e.ray;
    const r = this.matrixWorld, a = this.geometry, l = this.material;
    xn = l.linewidth + i, a.boundingSphere === null && a.computeBoundingSphere(), zs.copy(a.boundingSphere).applyMatrix4(r);
    let c;
    if (n)
      c = xn * 0.5;
    else {
      const h = Math.max(s.near, zs.distanceToPoint(Ot.origin));
      c = Do(s, h, l.resolution);
    }
    if (zs.radius += c, Ot.intersectsSphere(zs) === !1)
      return;
    a.boundingBox === null && a.computeBoundingBox(), Ns.copy(a.boundingBox).applyMatrix4(r);
    let u;
    if (n)
      u = xn * 0.5;
    else {
      const h = Math.max(s.near, Ns.distanceToPoint(Ot.origin));
      u = Do(s, h, l.resolution);
    }
    Ns.expandByScalar(u), Ot.intersectsBox(Ns) !== !1 && (n ? Nd(this, t) : zd(this, s, t));
  }
}
class Za extends $a {
  constructor() {
    super(), this.isLineGeometry = !0, this.type = "LineGeometry";
  }
  setPositions(e) {
    const t = e.length - 3, n = new Float32Array(2 * t);
    for (let s = 0; s < t; s += 3)
      n[2 * s] = e[s], n[2 * s + 1] = e[s + 1], n[2 * s + 2] = e[s + 2], n[2 * s + 3] = e[s + 3], n[2 * s + 4] = e[s + 4], n[2 * s + 5] = e[s + 5];
    return super.setPositions(n), this;
  }
  setColors(e) {
    const t = e.length - 3, n = new Float32Array(2 * t);
    for (let s = 0; s < t; s += 3)
      n[2 * s] = e[s], n[2 * s + 1] = e[s + 1], n[2 * s + 2] = e[s + 2], n[2 * s + 3] = e[s + 3], n[2 * s + 4] = e[s + 4], n[2 * s + 5] = e[s + 5];
    return super.setColors(n), this;
  }
  fromLine(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
}
class Gd extends Hd {
  constructor(e = new Za(), t = new _r({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLine2 = !0, this.type = "Line2";
  }
}
const jd = ["object"], Vd = /* @__PURE__ */ pe({
  __name: "Line2",
  props: {
    points: {},
    vertexColors: { default: null },
    color: { default: "white" },
    lineWidth: { default: 1 },
    worldUnits: { type: Boolean, default: !1 },
    alphaToCoverage: { type: Boolean, default: !1 },
    dashed: { type: Boolean, default: !1 },
    dashSize: { default: 1 },
    gapSize: { default: 1 },
    dashScale: { default: 1 },
    dashOffset: { default: 0 }
  },
  setup(o) {
    const e = o;
    function t(u, h) {
      if (!u || u.length === 0)
        return new Array(h).fill(ln(e.color));
      if (u.length === 1)
        return new Array(h).fill(ln(u[0]));
      if (u.length === h)
        return u.map(ln);
      const m = h - 1, p = u.map(ln);
      closed && p.push(p[0].clone());
      const v = [p[0]], _ = m / (p.length - 1);
      for (let y = 1; y < m; y++) {
        const E = y % _ / _, R = Math.floor(y / _);
        v.push(p[R].clone().lerp(p[R + 1], E));
      }
      return v.push(p[p.length - 1]), v;
    }
    function n(u, h, m) {
      const p = h.map((_) => _ instanceof ee ? [_.x, _.y, _.z] : _ instanceof le ? [_.x, _.y, 0] : Array.isArray(_) && _.length === 2 ? [_[0], _[1], 0] : _).flat();
      u.setPositions(p.flat());
      const v = t(m, h.length).map((_) => _.toArray()).flat();
      u.setColors(v), a.computeLineDistances();
    }
    function s(u, h) {
      u.color = ln(h.color), u.linewidth = h.lineWidth, u.alphaToCoverage = h.alphaToCoverage, u.worldUnits = h.worldUnits, u.vertexColors = Array.isArray(h.vertexColors), u.dashed = h.dashed, u.dashScale = h.dashScale, u.dashSize = h.dashSize, u.dashOffset = h.dashOffset, u.gapSize = h.gapSize, u.needsUpdate = !0;
    }
    const i = new _r(), r = new Za(), a = new Gd(r, i), l = je().sizes, c = Ne(() => Array.isArray(e.vertexColors));
    return s(i, e), n(r, e.points, e.vertexColors), a.computeLineDistances(), we(() => [
      e.color,
      e.lineWidth,
      e.alphaToCoverage,
      e.worldUnits,
      c,
      e.dashed,
      e.dashScale,
      e.dashSize,
      e.dashOffset
    ], () => s(i, e)), we([e.points, e.vertexColors], () => n(r, e.points, e.vertexColors)), we(() => e.vertexColors, () => n(r, e.points, e.vertexColors)), we(() => e.points, () => n(r, e.points, e.vertexColors)), we([l.height, l.width], () => i.resolution = new le(l.width.value, l.height.value)), ot(() => {
      r.dispose(), i.dispose();
    }), (u, h) => (fe(), de("primitive", { object: z(a) }, null, 8, jd));
  }
}), rg = /* @__PURE__ */ pe({
  __name: "CatmullRomCurve3",
  props: {
    segments: { default: 20 },
    closed: { type: Boolean, default: !1 },
    curveType: { default: "centripetal" },
    tension: { default: 0.5 },
    points: {},
    vertexColors: {},
    color: {},
    lineWidth: {},
    alphaToCoverage: { type: Boolean },
    dashed: { type: Boolean },
    dashSize: {},
    dashScale: {},
    dashOffset: {},
    gapSize: {},
    worldUnits: { type: Boolean }
  },
  setup(o) {
    const e = o;
    function t(r, a, l, c) {
      const u = r.map(
        (h) => h instanceof ee ? h : new ee(...h)
      );
      return new Gl(u, a, l, c);
    }
    function n(r, a) {
      return r.getPoints(a);
    }
    const s = Ne(() => t(e.points, e.closed, e.curveType, e.tension)), i = Ne(() => n(s.value, e.segments));
    return (r, a) => (fe(), sc(Vd, {
      points: i.value,
      "vertex-colors": e.vertexColors,
      color: e.color,
      lineWidth: e.lineWidth,
      alphaToCoverage: e.alphaToCoverage,
      dashed: e.dashed,
      dashSize: e.dashSize,
      dashScale: e.dashScale,
      dashOffset: e.dashOffset,
      gapSize: e.gapSize,
      worldUnits: e.worldUnits
    }, null, 8, ["points", "vertex-colors", "color", "lineWidth", "alphaToCoverage", "dashed", "dashSize", "dashScale", "dashOffset", "gapSize", "worldUnits"]));
  }
}), Yd = ["args"], Xd = ["color"], og = /* @__PURE__ */ pe({
  __name: "Circle",
  props: {
    args: { default: () => [1, 32, 0, Math.PI * 2] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = Fe(t), i = xe();
    return e({
      value: i
    }), (r, a) => (fe(), de("TresMesh", Ye({
      ref_key: "circleRef",
      ref: i
    }, r.$attrs), [
      Te("TresCircleGeometry", { args: z(n) }, null, 8, Yd),
      $e(r.$slots, "default", {}, () => [
        Te("TresMeshBasicMaterial", { color: z(s) }, null, 8, Xd)
      ])
    ], 16));
  }
}), Wd = ["args"], $d = ["color"], ag = /* @__PURE__ */ pe({
  __name: "Cone",
  props: {
    args: { default: () => [1, 1, 12, 12, !1, 0, Math.PI * 2] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = Fe(t), i = xe();
    return e({
      value: i
    }), (r, a) => (fe(), de("TresMesh", Ye({
      ref_key: "coneRef",
      ref: i
    }, r.$attrs), [
      Te("TresConeGeometry", { args: z(n) }, null, 8, Wd),
      $e(r.$slots, "default", {}, () => [
        Te("TresMeshBasicMaterial", { color: z(s) }, null, 8, $d)
      ])
    ], 16));
  }
}), Zd = ["args"], Kd = ["color"], lg = /* @__PURE__ */ pe({
  __name: "Dodecahedron",
  props: {
    args: { default: () => [1, 0] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = Fe(t), i = xe();
    return e({
      value: i
    }), (r, a) => (fe(), de("TresMesh", Ye({
      ref_key: "dodecahedronRef",
      ref: i
    }, r.$attrs), [
      Te("TresDodecahedronGeometry", { args: z(n) }, null, 8, Zd),
      $e(r.$slots, "default", {}, () => [
        Te("TresMeshBasicMaterial", { color: z(s) }, null, 8, Kd)
      ])
    ], 16));
  }
}), qd = ["args"], Qd = ["color"], cg = /* @__PURE__ */ pe({
  __name: "Icosahedron",
  props: {
    args: { default: () => [1, 0] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = Fe(t), i = xe();
    return e({
      value: i
    }), (r, a) => (fe(), de("TresMesh", Ye({
      ref_key: "icosahedronRef",
      ref: i
    }, r.$attrs), [
      Te("TresIcosahedronGeometry", { args: z(n) }, null, 8, qd),
      $e(r.$slots, "default", {}, () => [
        Te("TresMeshBasicMaterial", { color: z(s) }, null, 8, Qd)
      ])
    ], 16));
  }
}), Jd = ["args"], ep = ["color"], ug = /* @__PURE__ */ pe({
  __name: "Octahedron",
  props: {
    args: { default: () => [1, 0] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = Fe(t), i = xe();
    return e({
      value: i
    }), (r, a) => (fe(), de("TresMesh", Ye({
      ref_key: "octahedronRef",
      ref: i
    }, r.$attrs), [
      Te("TresOctahedronGeometry", { args: z(n) }, null, 8, Jd),
      $e(r.$slots, "default", {}, () => [
        Te("TresMeshBasicMaterial", { color: z(s) }, null, 8, ep)
      ])
    ], 16));
  }
}), tp = ["rotation"], np = ["args"], sp = ["color"], hg = /* @__PURE__ */ pe({
  __name: "Plane",
  props: {
    args: { default: () => [1, 1] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = Fe(t), i = xe();
    return e({
      value: i
    }), (r, a) => (fe(), de("TresMesh", Ye({
      ref_key: "planeRef",
      ref: i,
      rotation: [-Math.PI / 2, 0, 0]
    }, r.$attrs), [
      Te("TresPlaneGeometry", { args: z(n) }, null, 8, np),
      $e(r.$slots, "default", {}, () => [
        Te("TresMeshBasicMaterial", { color: z(s) }, null, 8, sp)
      ])
    ], 16, tp));
  }
}), ip = ["args"], rp = ["color"], fg = /* @__PURE__ */ pe({
  __name: "Ring",
  props: {
    args: { default: () => [0.5, 1, 32] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = Fe(t), i = xe();
    return e({
      value: i
    }), (r, a) => (fe(), de("TresMesh", Ye({
      ref_key: "ringRef",
      ref: i
    }, r.$attrs), [
      Te("TresRingGeometry", { args: z(n) }, null, 8, ip),
      $e(r.$slots, "default", {}, () => [
        Te("TresMeshBasicMaterial", { color: z(s) }, null, 8, rp)
      ])
    ], 16));
  }
}), op = ["args"], ap = ["color"], dg = /* @__PURE__ */ pe({
  __name: "Sphere",
  props: {
    args: { default: () => [2, 32, 16] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = Fe(t), i = xe();
    return e({
      value: i
    }), (r, a) => (fe(), de("TresMesh", Ye({
      ref_key: "sphereRef",
      ref: i
    }, r.$attrs), [
      Te("TresSphereGeometry", { args: z(n) }, null, 8, op),
      $e(r.$slots, "default", {}, () => [
        Te("TresMeshBasicMaterial", { color: z(s) }, null, 8, ap)
      ])
    ], 16));
  }
}), lp = ["geometry"], cp = ["color"], pg = /* @__PURE__ */ pe({
  __name: "Superformula",
  props: {
    widthSegments: { default: 32 },
    heightSegments: { default: 32 },
    numArmsA: { default: 4 },
    expA: { default: () => [40, 1.3, 0.9] },
    numArmsB: { default: 4 },
    expB: { default: () => [40, 1.3, 0.9] },
    color: { default: "white" }
  },
  setup(o, { expose: e }) {
    const t = o, { cos: n, sin: s, abs: i } = Math, r = xe(), a = xe(t.color);
    function l(m, p) {
      const v = new rt(), _ = m * p, y = new Float32Array(new Array(3 * _).fill(0)), E = new Float32Array(new Array(3 * _).fill(0)), R = [];
      for (let T = 0; T < p - 1; T++) {
        for (let d = 0; d < m - 1; d++) {
          const w = T * m + d, f = w + 1, P = w + m, I = f + m;
          R.push(w, P, f), R.push(P, I, f);
        }
        const g = T * m + m - 1, A = T * m, x = g + m, M = A + m;
        R.push(g, x, A), R.push(x, M, A);
      }
      return v.setIndex(R), v.setAttribute("position", new pt(y, 3)), v.setAttribute("normal", new pt(E, 3)), v;
    }
    function c(m, p, v, _, y) {
      return (i(n(p * m * 0.25)) ** _ + i(s(p * m * 0.25)) ** y) ** (-1 / v);
    }
    function u(m, p, v, _, y, E, R, T, g, A, x) {
      const M = 2 * Math.PI / A, d = -Math.PI, w = Math.PI / (x - 1), f = -0.5 * Math.PI, P = m.getAttribute("position");
      let I = 0, K = 0, N = f;
      for (let Z = 0; Z < x; Z++) {
        K = d;
        for (let W = 0; W < A; W++) {
          const X = c(K, p, v, _, y), V = c(N, E, R, T, g);
          P.setXYZ(
            I,
            X * n(K) * V * n(N),
            V * s(N),
            X * s(K) * V * n(N)
          ), I++, K += M;
        }
        N += w;
      }
      P.needsUpdate = !0, m.computeVertexNormals();
    }
    we(() => t.color, () => a.value = t.color), we(() => [t.widthSegments, t.heightSegments], () => {
      r.value && r.value.dispose(), r.value = l(t.widthSegments, t.heightSegments);
    }, { immediate: !0 }), we(
      () => [
        t.numArmsA,
        t.expA[0],
        t.expA[1],
        t.expA[2],
        t.numArmsB,
        t.expB[0],
        t.expB[1],
        t.expB[2]
      ],
      () => u(
        r.value,
        t.numArmsA,
        t.expA[0],
        t.expA[1],
        t.expA[2],
        t.numArmsB,
        t.expB[0],
        t.expB[1],
        t.expB[2],
        t.widthSegments,
        t.heightSegments
      ),
      { immediate: !0 }
    ), ot(() => {
      r.value && r.value.dispose();
    });
    const h = xe();
    return e({
      value: h
    }), (m, p) => (fe(), de("TresMesh", Ye({
      ref_key: "superformulaRef",
      ref: h
    }, m.$attrs, { geometry: r.value }), [
      $e(m.$slots, "default", {}, () => [
        Te("TresMeshBasicMaterial", { color: a.value }, null, 8, cp)
      ])
    ], 16, lp));
  }
}), up = ["rotation"], hp = ["args"], fp = ["color"], mg = /* @__PURE__ */ pe({
  __name: "Tetrahedron",
  props: {
    args: { default: () => [1, 0] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = Fe(t), i = xe();
    return e({
      value: i
    }), (r, a) => (fe(), de("TresMesh", Ye({
      ref_key: "tetrahedronRef",
      ref: i,
      rotation: [-Math.PI / 2, 0, 0]
    }, r.$attrs), [
      Te("TresTetrahedronGeometry", { args: z(n) }, null, 8, hp),
      $e(r.$slots, "default", {}, () => [
        Te("TresMeshBasicMaterial", { color: z(s) }, null, 8, fp)
      ])
    ], 16, up));
  }
}), dp = ["args"], pp = ["color"], gg = /* @__PURE__ */ pe({
  __name: "Torus",
  props: {
    args: { default: () => [1, 1, 16, 80] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = Fe(t), i = xe();
    return e({
      value: i
    }), (r, a) => (fe(), de("TresMesh", Ye({
      ref_key: "torusRef",
      ref: i
    }, r.$attrs), [
      Te("TresTorusGeometry", { args: z(n) }, null, 8, dp),
      $e(r.$slots, "default", {}, () => [
        Te("TresMeshBasicMaterial", { color: z(s) }, null, 8, pp)
      ])
    ], 16));
  }
}), mp = ["args"], gp = ["color"], yg = /* @__PURE__ */ pe({
  __name: "TorusKnot",
  props: {
    args: { default: () => [1, 0.4, 64, 8] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = Fe(t), i = xe();
    return e({
      value: i
    }), (r, a) => (fe(), de("TresMesh", Ye({
      ref_key: "torusKnotRef",
      ref: i
    }, r.$attrs), [
      Te("TresTorusKnotGeometry", { args: z(n) }, null, 8, mp),
      $e(r.$slots, "default", {}, () => [
        Te("TresMeshBasicMaterial", { color: z(s) }, null, 8, gp)
      ])
    ], 16));
  }
}), yp = ["args"], vp = ["color"], vg = /* @__PURE__ */ pe({
  __name: "Tube",
  props: {
    args: { default: () => [
      new jl(new ee(-1, 0, 0), new ee(0, 1, 0), new ee(1, 0, 0)),
      20,
      0.2,
      8,
      !1
    ] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = Fe(t), i = xe();
    return e({
      value: i
    }), (r, a) => (fe(), de("TresMesh", Ye({
      ref_key: "tubeRef",
      ref: i
    }, r.$attrs), [
      Te("TresTubeGeometry", { args: z(n) }, null, 8, yp),
      $e(r.$slots, "default", {}, () => [
        Te("TresMeshBasicMaterial", { color: z(s) }, null, 8, vp)
      ])
    ], 16));
  }
}), _g = /* @__PURE__ */ pe({
  __name: "component",
  props: {
    background: { type: [Boolean, String], default: !1 },
    blur: { default: 0 },
    files: { default: [] },
    path: { default: "" },
    preset: { default: void 0 }
  },
  async setup(o, { expose: e }) {
    let t, n;
    const s = o, i = ue(null);
    return e(i), i.value = ([t, n] = fs(() => nf(s).texture), t = await t, n(), t), () => {
    };
  }
}), _p = ["receive-shadow", "rotation"], xp = ["args"], wp = /* @__PURE__ */ Te("TresMeshStandardMaterial", {
  color: 8421504,
  side: 2
}, null, -1), xg = /* @__PURE__ */ pe({
  __name: "Backdrop",
  props: {
    floor: { default: 0.25 },
    segments: { default: 20 },
    receiveShadow: { type: Boolean, default: !1 }
  },
  setup(o) {
    const e = o, t = (a) => a === 0 ? 0 : 2 ** (10 * a - 10), { floor: n, segments: s, receiveShadow: i } = Fe(e), r = ue(null);
    return we(
      () => [s.value, n.value, r.value],
      ([a, l, c]) => {
        if (!c || a === null)
          return;
        let u = 0;
        const h = a / a / 2, m = c.attributes.position;
        for (let p = 0; p < a + 1; p++)
          for (let v = 0; v < a + 1; v++)
            m.setXYZ(
              u++,
              p / a - h + (p === 0 ? -l : 0),
              v / a - h,
              t(p / a)
            );
        m.needsUpdate = !0, c.computeVertexNormals();
      }
    ), (a, l) => (fe(), de("TresGroup", ua(ha(a.$attrs)), [
      Te("TresMesh", {
        "receive-shadow": z(i),
        rotation: [-Math.PI / 2, 0, Math.PI / 2]
      }, [
        Te("TresPlaneGeometry", {
          ref_key: "planeRef",
          ref: r,
          args: [1, 1, z(s), z(s)]
        }, null, 8, xp),
        $e(a.$slots, "default", {}, () => [
          wp
        ])
      ], 8, _p)
    ], 16));
  }
}), Tp = ["geometry"], bp = ["map", "opacity", "depth-write"], Ep = ["object"], Mp = ["args"], Sp = ["rotation", "args"], wg = /* @__PURE__ */ pe({
  __name: "ContactShadows",
  props: {
    opacity: { default: 1 },
    width: { default: 1 },
    height: { default: 1 },
    blur: { default: 1 },
    far: { default: 10 },
    smooth: { type: Boolean, default: !0 },
    resolution: { default: 512 },
    frames: { default: 1 / 0 },
    scale: { default: 10 },
    color: { default: "#000000" },
    depthWrite: { type: Boolean, default: !1 },
    helper: { type: Boolean, default: !1 }
  },
  setup(o, { expose: e }) {
    const t = o, n = xe(), s = xe();
    e(n);
    let i, r, a, l, c;
    const { renderer: u, scene: h } = je(), m = Ne(() => t.width * (Array.isArray(t.scale) ? t.scale[0] : t.scale || 1)), p = Ne(() => t.height * (Array.isArray(t.scale) ? t.scale[1] : t.scale || 1));
    ft(() => {
      i && i.dispose(), r && r.dispose(), a && a.dispose(), l && l.geometry.dispose(), i = new bn(t.resolution, t.resolution), r = new bn(t.resolution, t.resolution), r.texture.generateMipmaps = i.texture.generateMipmaps = !1, s.value = new jt(
        -m.value / 2,
        m.value / 2,
        p.value / 2,
        -p.value / 2,
        0,
        t.far
      ), a = new Dt(m.value, p.value).rotateX(Math.PI / 2), l = new ae(a), l.visible = !1;
    }), ft(() => {
      t.color && (c && c.dispose(), c = new Vl(), c.depthTest = c.depthWrite = !1, c.onBeforeCompile = (A) => {
        A.uniforms = {
          ...A.uniforms,
          ucolor: { value: t.color ? new Be(t.color) : new Be() }
        }, A.fragmentShader = A.fragmentShader.replace(
          "void main() {",
          //
          `uniform vec3 ucolor;
             void main() {
            `
        ), A.fragmentShader = A.fragmentShader.replace(
          "vec4( vec3( 1.0 - fragCoordZ ), opacity );",
          // Colorize the shadow, multiply by the falloff so that the center can remain darker
          "vec4( ucolor * fragCoordZ * 2.0, ( 1.0 - fragCoordZ ) * 1.0 );"
        );
      });
    });
    const v = new Xt(Nu), _ = new Xt(zu);
    _.depthTest = v.depthTest = !1;
    function y(A) {
      !u.value || !s.value || (l.visible = !0, l.material = v, v.uniforms.tDiffuse.value = i.texture, v.uniforms.h.value = A / 256, u.value.setRenderTarget(r), u.value.render(l, s.value), l.material = _, _.uniforms.tDiffuse.value = r.texture, _.uniforms.v.value = A / 256, u.value.setRenderTarget(i), u.value.render(l, s.value), l.visible = !1);
    }
    const { onLoop: E } = Ke();
    let R = 0, T, g;
    return E(() => {
      !s.value || h.value === void 0 || u.value === void 0 || (t.frames === 1 / 0 || R < t.frames) && (R++, T = h.value.background, g = h.value.overrideMaterial, n.value.visible = !1, h.value.background = null, h.value.overrideMaterial = c, u.value.setRenderTarget(i), u.value.render(h.value, s.value), y(t.blur), t.smooth && y(t.blur * 0.4), u.value.setRenderTarget(null), n.value.visible = !0, h.value.background = T, h.value.overrideMaterial = g);
    }), (A, x) => (fe(), de("TresGroup", Ye({
      ref_key: "groupRef",
      ref: n
    }, A.$attrs), [
      Te("TresMesh", {
        scale: [1, -1, 1],
        geometry: z(a)
      }, [
        Te("TresMeshBasicMaterial", {
          map: z(i).texture,
          opacity: A.opacity,
          "depth-write": A.depthWrite,
          transparent: !0
        }, null, 8, bp)
      ], 8, Tp),
      Te("primitive", { object: z(l) }, null, 8, Ep),
      s.value && A.helper ? (fe(), de("TresCameraHelper", {
        key: 0,
        args: [s.value]
      }, null, 8, Mp)) : Wt("", !0),
      Te("TresOrthographicCamera", {
        ref_key: "shadowCamera",
        ref: s,
        position: [0, 0, 0],
        rotation: [Math.PI / 2, 0, 0],
        args: [-m.value / 2, m.value / 2, p.value / 2, -p.value / 2, 0, A.far]
      }, null, 8, Sp)
    ], 16));
  }
}), Ap = ["size", "color", "alpha-map", "map", "opacity", "alpha-test", "depth-write", "transparent", "size-attenuation"], Pp = ["position", "velocity"], Tg = /* @__PURE__ */ pe({
  __name: "Precipitation",
  props: {
    size: { default: 0.1 },
    area: { default: () => [10, 10, 20] },
    color: { default: 16777215 },
    map: {},
    alphaMap: {},
    alphaTest: { default: 0.01 },
    opacity: { default: 0.8 },
    count: { default: 5e3 },
    speed: { default: 0.1 },
    randomness: { default: 0.5 },
    depthWrite: { type: Boolean, default: !1 },
    transparent: { type: Boolean, default: !0 },
    sizeAttenuation: { type: Boolean, default: !0 }
  },
  setup(o) {
    const e = o, {
      size: t,
      area: n,
      color: s,
      alphaMap: i,
      map: r,
      opacity: a,
      alphaTest: l,
      depthWrite: c,
      transparent: u,
      sizeAttenuation: h,
      count: m,
      speed: p,
      randomness: v
    } = Fe(e), _ = xe();
    let y = [], E = [];
    const R = () => {
      y = new Float32Array(m.value * 3);
      for (let A = 0; A < m.value; A++) {
        const x = A * 3;
        y[x] = (Math.random() - 0.5) * n.value[0], y[x + 1] = (Math.random() - 0.5) * n.value[1], y[x + 2] = (Math.random() - 0.5) * n.value[2];
      }
    }, T = () => {
      E = new Float32Array(m.value * 2);
      for (let A = 0; A < m.value * 2; A += 2)
        E[A] = (Math.random() - 0.5) / 5 * p.value * v.value, E[A + 1] = Math.random() / 5 * p.value + 0.01;
    };
    T(), R(), ft(() => {
      T(), R();
    });
    const { onLoop: g } = Ke();
    return g(() => {
      var A, x;
      if ((A = _.value) != null && A.attributes.position.array && ((x = _.value) != null && x.attributes.position.count)) {
        const M = _.value.attributes.position.array;
        for (let d = 0; d < _.value.attributes.position.count; d++) {
          const w = E[d * 2], f = E[d * 2 + 1];
          M[d * 3] += w, M[d * 3 + 1] -= f, (M[d * 3] <= -n.value[0] / 2 || M[d * 3] >= n.value[0] / 2) && (M[d * 3] = M[d * 3] * -1), (M[d * 3 + 1] <= -n.value[1] / 2 || M[d * 3 + 1] >= n.value[1] / 2) && (M[d * 3 + 1] = M[d * 3 + 1] * -1);
        }
        _.value.attributes.position.needsUpdate = !0;
      }
    }), (A, x) => (fe(), de("TresPoints", null, [
      Te("TresPointsMaterial", {
        size: z(t),
        color: z(s),
        "alpha-map": z(i),
        map: z(r),
        opacity: z(a),
        "alpha-test": z(l),
        "depth-write": z(c),
        transparent: z(u),
        "size-attenuation": z(h)
      }, null, 8, Ap),
      Te("TresBufferGeometry", {
        ref_key: "geometryRef",
        ref: _,
        position: [z(y), 3],
        velocity: [z(E)]
      }, null, 8, Pp)
    ]));
  }
});
class ni extends ae {
  constructor() {
    const e = ni.SkyShader, t = new Xt({
      name: e.name,
      uniforms: Js.clone(e.uniforms),
      vertexShader: e.vertexShader,
      fragmentShader: e.fragmentShader,
      side: ta,
      depthWrite: !1
    });
    super(new tn(1, 1, 1), t), this.isSky = !0;
  }
}
ni.SkyShader = {
  name: "SkyShader",
  uniforms: {
    turbidity: { value: 2 },
    rayleigh: { value: 1 },
    mieCoefficient: { value: 5e-3 },
    mieDirectionalG: { value: 0.8 },
    sunPosition: { value: new ee() },
    up: { value: new ee(0, 1, 0) }
  },
  vertexShader: (
    /* glsl */
    `
		uniform vec3 sunPosition;
		uniform float rayleigh;
		uniform float turbidity;
		uniform float mieCoefficient;
		uniform vec3 up;

		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		// constants for atmospheric scattering
		const float e = 2.71828182845904523536028747135266249775724709369995957;
		const float pi = 3.141592653589793238462643383279502884197169;

		// wavelength of used primaries, according to preetham
		const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );
		// this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
		// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
		const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );

		// mie stuff
		// K coefficient for the primaries
		const float v = 4.0;
		const vec3 K = vec3( 0.686, 0.678, 0.666 );
		// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
		const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );

		// earth shadow hack
		// cutoffAngle = pi / 1.95;
		const float cutoffAngle = 1.6110731556870734;
		const float steepness = 1.5;
		const float EE = 1000.0;

		float sunIntensity( float zenithAngleCos ) {
			zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
			return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );
		}

		vec3 totalMie( float T ) {
			float c = ( 0.2 * T ) * 10E-18;
			return 0.434 * c * MieConst;
		}

		void main() {

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vWorldPosition = worldPosition.xyz;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			gl_Position.z = gl_Position.w; // set z to camera.far

			vSunDirection = normalize( sunPosition );

			vSunE = sunIntensity( dot( vSunDirection, up ) );

			vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );

			float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );

			// extinction (absorbtion + out scattering)
			// rayleigh coefficients
			vBetaR = totalRayleigh * rayleighCoefficient;

			// mie coefficients
			vBetaM = totalMie( turbidity ) * mieCoefficient;

		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		uniform float mieDirectionalG;
		uniform vec3 up;

		// constants for atmospheric scattering
		const float pi = 3.141592653589793238462643383279502884197169;

		const float n = 1.0003; // refractive index of air
		const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)

		// optical length at zenith for molecules
		const float rayleighZenithLength = 8.4E3;
		const float mieZenithLength = 1.25E3;
		// 66 arc seconds -> degrees, and the cosine of that
		const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;

		// 3.0 / ( 16.0 * pi )
		const float THREE_OVER_SIXTEENPI = 0.05968310365946075;
		// 1.0 / ( 4.0 * pi )
		const float ONE_OVER_FOURPI = 0.07957747154594767;

		float rayleighPhase( float cosTheta ) {
			return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );
		}

		float hgPhase( float cosTheta, float g ) {
			float g2 = pow( g, 2.0 );
			float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );
			return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );
		}

		void main() {

			vec3 direction = normalize( vWorldPosition - cameraPosition );

			// optical length
			// cutoff angle at 90 to avoid singularity in next formula.
			float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );
			float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );
			float sR = rayleighZenithLength * inverse;
			float sM = mieZenithLength * inverse;

			// combined extinction factor
			vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );

			// in scattering
			float cosTheta = dot( direction, vSunDirection );

			float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );
			vec3 betaRTheta = vBetaR * rPhase;

			float mPhase = hgPhase( cosTheta, mieDirectionalG );
			vec3 betaMTheta = vBetaM * mPhase;

			vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );
			Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );

			// nightsky
			float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]
			float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]
			vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );
			vec3 L0 = vec3( 0.1 ) * Fex;

			// composition + solar disc
			float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );
			L0 += ( vSunE * 19000.0 * Fex ) * sundisk;

			vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );

			vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );

			gl_FragColor = vec4( retColor, 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`
  )
};
const Rp = ["object", "material-uniforms-turbidity-value", "material-uniforms-rayleigh-value", "material-uniforms-mieCoefficient-value", "material-uniforms-mieDirectionalG-value", "material-uniforms-sunPosition-value", "scale"], bg = /* @__PURE__ */ pe({
  __name: "Sky",
  props: {
    turbidity: { default: 3.4 },
    rayleigh: { default: 3 },
    mieCoefficient: { default: 5e-3 },
    mieDirectionalG: { default: 0.7 },
    elevation: { default: 0.6 },
    azimuth: { default: 180 },
    distance: { default: 45e4 }
  },
  setup(o) {
    const e = o, t = new ni(), n = Ne(
      () => s(e.azimuth, e.elevation)
    );
    function s(i, r) {
      const a = We.degToRad(90 - r), l = We.degToRad(i);
      return new ee().setFromSphericalCoords(1, a, l);
    }
    return (i, r) => (fe(), de("primitive", {
      object: z(t),
      "material-uniforms-turbidity-value": e.turbidity,
      "material-uniforms-rayleigh-value": e.rayleigh,
      "material-uniforms-mieCoefficient-value": e.mieCoefficient,
      "material-uniforms-mieDirectionalG-value": e.mieDirectionalG,
      "material-uniforms-sunPosition-value": n.value,
      scale: e.distance
    }, null, 8, Rp));
  }
}), Cp = ["position"], Ip = ["position"], Dp = ["scale"], Lp = ["map", "depth-test", "color-space", "color", "opacity"], Eg = /* @__PURE__ */ pe({
  __name: "Smoke",
  props: {
    color: { default: "#ffffff" },
    opacity: { default: 0.5 },
    speed: { default: 0.4 },
    width: { default: 10 },
    depth: { default: 1.5 },
    segments: { default: 20 },
    texture: { default: "https://raw.githubusercontent.com/Tresjs/assets/main/textures/clouds/defaultCloud.png" },
    depthTest: { type: Boolean, default: !0 }
  },
  async setup(o, { expose: e }) {
    let t, n;
    const s = o, { width: i, depth: r, segments: a, texture: l, color: c, depthTest: u, opacity: h, speed: m } = Fe(s), p = xe(), v = xe();
    e({
      value: p
    });
    const _ = [...new Array(a)].map((x, M) => ({
      x: i.value / 2 - Math.random() * i.value,
      y: i.value / 2 - Math.random() * i.value,
      scale: 0.4 + Math.sin((M + 1) / a.value * Math.PI) * ((0.2 + Math.random()) * 10),
      density: Math.max(0.2, Math.random()),
      rotation: Math.max(2e-3, 5e-3 * Math.random()) * m.value
    })), y = (x, M) => x / 6 * M * h.value, { map: E } = ([t, n] = fs(() => $i({ map: l.value })), t = await t, n(), t), { renderer: R, camera: T } = je(), g = Ne(() => {
      var x;
      return (x = R.value) == null ? void 0 : x.outputColorSpace;
    }), { onLoop: A } = Ke();
    return A(() => {
      var x, M;
      p.value && T.value && v.value && ((x = v.value) == null || x.children.forEach((d, w) => {
        d.rotation.z += _[w].rotation;
      }), p.value.lookAt((M = T.value) == null ? void 0 : M.position));
    }), (x, M) => (fe(), de("TresGroup", Ye({
      ref_key: "smokeRef",
      ref: p
    }, x.$attrs), [
      Te("TresGroup", {
        ref_key: "groupRef",
        ref: v,
        position: [0, 0, z(a) / 2 * z(r)]
      }, [
        (fe(!0), de(la, null, ca(z(_), ({ scale: d, x: w, y: f, density: P }, I) => (fe(), de("TresMesh", {
          key: `${I}`,
          position: [w, f, -I * z(r)]
        }, [
          Te("TresPlaneGeometry", {
            scale: [d, d, d],
            rotation: [0, 0, 0]
          }, null, 8, Dp),
          Te("TresMeshStandardMaterial", {
            map: z(E),
            "depth-test": z(u),
            "color-space": g.value,
            color: z(c),
            "depth-write": !1,
            transparent: "",
            opacity: y(d, P)
          }, null, 8, Lp)
        ], 8, Ip))), 128))
      ], 8, Cp)
    ], 16));
  }
});
function Op(o) {
  return xr(o, {
    normalizeValue: (e) => ln(e),
    getDefaultValue: () => new Be(0, 0, 0),
    isSingleValue: (e) => !Array.isArray(e),
    isMultipleValues: (e) => Array.isArray(e) && (e.length === 0 || !Array.isArray(e[0])),
    isMultipleValuesWithStops: (e) => Array.isArray(e) && e.length > 0 && Array.isArray(e[0]),
    isEmpty: (e) => Array.isArray(e) && e.length === 0
  });
}
function Ui(o) {
  return "isVector3" in o || Array.isArray(o) && o.length > 0 && o.every((e) => typeof e == "number");
}
function Fp(o) {
  return xr(o, {
    normalizeValue: (e) => oc(e),
    getDefaultValue: () => [0, 0, 0],
    isSingleValue: (e) => Ui(e),
    isMultipleValues: (e) => Array.isArray(e) && e.length > 0 && Ui(e[0]),
    isMultipleValuesWithStops: (e) => Array.isArray(e) && e.length > 0 && Array.isArray(e[0]) && e[0].length === 2 && Ui(e[0][1]),
    isEmpty: (e) => Array.isArray(e) && e.length === 0
  });
}
function kp(o) {
  return xr(o, {
    normalizeValue: (e) => e,
    getDefaultValue: () => 1,
    isSingleValue: (e) => !Array.isArray(e) && typeof e < "u",
    isMultipleValues: (e) => Array.isArray(e) && (e.length === 0 || !Array.isArray(e[0])),
    isMultipleValuesWithStops: (e) => Array.isArray(e) && e.length > 0 && Array.isArray(e[0]),
    isEmpty: (e) => Array.isArray(e) && e.length === 0
  });
}
function xr(o, e) {
  const { normalizeValue: t, getDefaultValue: n, isEmpty: s } = e, i = (l) => e.isSingleValue(l), r = (l) => e.isMultipleValues(l), a = (l) => e.isMultipleValuesWithStops(l);
  if (s(o))
    return [[0, n()]];
  if (i(o))
    return [[0, t(o)]];
  if (r(o)) {
    const l = o.length > 1 ? 1 / (o.length - 1) : 1;
    return o.map((c, u) => [l * u, t(c)]);
  } else if (a(o))
    return o.map(([l, c], u) => [l, t(c)]);
  return [[0, n()]];
}
class Up {
  constructor(e, t) {
    oe(this, "entries");
    oe(this, "resolution");
    this.entries = e, this.resolution = t;
  }
  useTexture() {
    return new zp(this.entries, this.resolution).use();
  }
}
class wr {
  constructor(e, t, n, s, i, r) {
    oe(this, "data");
    oe(this, "ref");
    oe(this, "name");
    oe(this, "valueMin");
    oe(this, "valueMax");
    oe(this, "suffix");
    oe(this, "renderToCanvasGradient");
    this.data = Wi(e) ? e.value : e, this.ref = Wi(e) ? e : null, this.name = t, this.valueMin = n, this.valueMax = s, this.suffix = i, this.renderToCanvasGradient = r;
  }
}
class Bp extends wr {
  constructor(e, t = "color", n = 0, s = 1, i = "rgba", r = Hp) {
    super(e, t, n, s, i, r);
  }
}
class Lo extends wr {
  constructor(e, t = "scalar", n = 0, s = 1, i = "x", r = Gp) {
    super(e, t, n, s, i, r);
  }
}
class Np extends wr {
  constructor(e, t = "scalar3", n = 0, s = 1, i = "xyz", r = jp) {
    super(e, t, n, s, i, r);
  }
}
class zp {
  constructor(e, t) {
    oe(this, "entries");
    oe(this, "size");
    oe(this, "dirty", xe(0));
    oe(this, "context");
    this.entries = e, this.size = Math.max(t, e.length);
    const n = document.createElement("canvas");
    n.height = this.size, n.width = this.size, this.context = n.getContext("2d");
  }
  use() {
    const e = this.build(), t = xe(e);
    for (const n of this.entries)
      n.ref && we(n.ref, () => {
        var s;
        n.data = (s = n.ref) == null ? void 0 : s.value, ic(this.dirty);
      });
    return Mh(
      this.dirty,
      () => {
        this.build(e), t.value = e;
      },
      { throttle: 1e3 / 60 }
    ), {
      texture: t,
      dispose: () => e.dispose(),
      yFor: this.entries.reduce((n, s, i) => (n[s.name] = (i + 0.5) / this.size, n), {})
    };
  }
  build(e) {
    this.entries.forEach((n, s) => {
      const i = this.context.createLinearGradient(0, s, this.size, s);
      n.renderToCanvasGradient(i, n), this.context.fillStyle = i, this.context.fillRect(0, s, this.size, 1);
    }), e && (e.source.data = this.context.getImageData(
      0,
      0,
      this.size,
      this.size
    ));
    const t = e ?? new ia(
      this.context.getImageData(0, 0, this.size, this.size).data,
      this.size,
      this.size,
      Uo,
      Vi,
      Yl,
      Hn,
      Hn
    );
    return t.needsUpdate = !0, t;
  }
}
function Ka(o, e, t, n, s) {
  return Mf(cn(o, e, t), e, t, n, s);
}
function Hp(o, e) {
  return Op(e.data).forEach(
    ([t, n]) => o.addColorStop(
      t,
      `rgb(${n.r * 255}, ${n.g * 255}, ${n.b * 255})`
    )
  );
}
function Gp(o, e) {
  return kp(e.data).forEach(([t, n]) => {
    o.addColorStop(
      t,
      `rgb(${Ka(
        n,
        e.valueMin,
        e.valueMax,
        0,
        255
      )}, 0, 0)`
    );
  });
}
function jp(o, e) {
  return Fp(e.data).forEach(
    ([t, n]) => o.addColorStop(
      t,
      `rgb(${n.map(
        (s) => Ka(s, e.valueMin, e.valueMax, 0, 255)
      )})`
    )
  );
}
class Vp {
  constructor(e = 256) {
    oe(this, "entries");
    oe(this, "resolution");
    this.resolution = e, this.entries = [];
  }
  withResolution(e) {
    return this.resolution = e, this;
  }
  get add() {
    return new Xp(
      (e) => this.onAdd(e)
    );
  }
  build() {
    return new Up(this.entries, this.resolution);
  }
  onAdd(e) {
    return this.entries.push(e), new Yp(e, this);
  }
}
class Yp {
  constructor(e, t) {
    oe(this, "entry");
    oe(this, "parent");
    this.entry = e, this.parent = t;
  }
  id(e) {
    return this.entry.name = e, this;
  }
  range(e, t) {
    return this.entry.valueMin = e, this.entry.valueMax = t, this;
  }
  suffix(e) {
    return this.entry.suffix = e, this;
  }
  canvasGradientRenderer(e) {
    return this.entry.renderToCanvasGradient = e, this;
  }
  /**
   * Add another entry to the ShaderDataBuilder
   */
  get add() {
    return this.parent.add;
  }
  /**
   * Finalize the ShaderDataBuilder
   * @returns ShaderData
   */
  build() {
    return this.parent.build();
  }
}
class Xp {
  constructor(e) {
    oe(this, "onAdd");
    this.onAdd = e;
  }
  GradientTresColor(e) {
    return this.onAdd(new Bp(e));
  }
  Gradient01(e) {
    return this.onAdd(new Lo(e, "zeroOne", 0, 1));
  }
  GradientScalar(e, t, n) {
    return this.onAdd(
      new Lo(e, "scalar", t, n)
    );
  }
  GradientXyz(e, t, n) {
    return this.onAdd(
      new Np(e, "position", t, n)
    );
  }
}
let Bi = null;
function Wp() {
  return Bi === null && (Bi = new ia(new Uint8Array([0, 0, 0, 0]), 1, 1)), Bi;
}
const $p = ["object"], Mg = /* @__PURE__ */ pe({
  __name: "component",
  props: {
    map: { default: "https://raw.githubusercontent.com/Tresjs/assets/e41a93c56ec7cb5ac2d241f309e23582a5fe1fc6/textures/sparkles/particle.png" },
    geometry: { default: void 0 },
    directionalLight: { default: void 0 },
    lifetimeSec: { default: 0.4 },
    cooldownSec: { default: 2 },
    normalThreshold: { default: 0.7 },
    noiseScale: { default: 3 },
    scaleNoise: { default: 1 },
    offsetNoise: { default: 0.1 },
    lifetimeNoise: { default: 0 },
    size: { default: 1 },
    alpha: { default: 1 },
    offset: { default: 1 },
    surfaceDistance: { default: 1 },
    sequenceColor: { default: () => [[0.7, "#82dbc5"], [0.8, "#fbb03b"]] },
    sequenceAlpha: { default: () => [[0, 0], [0.1, 1], [0.5, 1], [0.9, 0]] },
    sequenceOffset: { default: () => [0, 0, 0] },
    sequenceNoise: { default: () => [0.1, 0.1, 0.1] },
    sequenceSize: { default: () => [0, 1] },
    sequenceSurfaceDistance: { default: () => [0.05, 0.08, 0.1] },
    mixColor: { default: 0.5 },
    mixAlpha: { default: 1 },
    mixOffset: { default: 1 },
    mixSize: { default: 0 },
    mixSurfaceDistance: { default: 1 },
    mixNoise: { default: 1 },
    blending: { default: na },
    transparent: { type: Boolean, default: !0 },
    depthWrite: { type: Boolean, default: !1 }
  },
  setup(o) {
    const e = o, t = parseInt(rr.replace(/\D+/g, "")), n = Fe(e), s = typeof e.map == "string" ? Wp() : e.map, { texture: i, yFor: r } = new Vp(256).add.GradientTresColor(n.sequenceColor).id("sequenceColor").add.Gradient01(n.sequenceAlpha).id("sequenceAlpha").add.Gradient01(n.sequenceSurfaceDistance).id("sequenceSurfaceDistance").add.Gradient01(n.sequenceSize).id("sequenceSize").add.GradientXyz(n.sequenceOffset, -1, 1).id("sequenceOffset").add.GradientXyz(n.sequenceNoise, 0, 1).id("sequenceNoise").build().useTexture(), a = {
      blending: e.blending,
      transparent: e.transparent,
      depthWrite: e.depthWrite,
      uniforms: {
        uMap: new Re(s),
        uPixelRatio: new Re(1),
        uNormal: new Re(St.DEFAULT_UP),
        uNormalThreshold: new Re(e.normalThreshold),
        uTime: new Re(0),
        uCooldownRatio: new Re(1),
        uSize: new Re(e.size),
        uAlpha: new Re(e.alpha),
        uOffset: new Re(e.offset),
        uSurfaceDistance: new Re(e.surfaceDistance),
        uNoiseScale: new Re(e.noiseScale),
        uScaleNoise: new Re(e.scaleNoise),
        uOffsetNoise: new Re(e.offsetNoise),
        uLifetimeNoise: new Re(e.lifetimeNoise),
        uMixColor: new Re(e.mixColor),
        uMixAlpha: new Re(e.mixAlpha),
        uMixOffset: new Re(e.mixOffset),
        uMixSize: new Re(e.mixSize),
        uMixSurfaceDistance: new Re(e.mixSurfaceDistance),
        uMixNoise: new Re(e.mixNoise),
        uInfoTexture: new Re(i.value)
      },
      vertexShader: `
    uniform float uPixelRatio;
    uniform vec3 uNormal;
    uniform float uNormalThreshold;
    uniform float uTime;
    uniform float uCooldownRatio;
    uniform float uSize;
    uniform float uAlpha;
    uniform float uOffset;
    uniform float uSurfaceDistance;
    uniform float uNoiseScale;
    uniform float uScaleNoise;
    uniform float uOffsetNoise;
    uniform float uLifetimeNoise;
    uniform float uMixColor;
    uniform float uMixAlpha;
    uniform float uMixOffset;
    uniform float uMixSize;
    uniform float uMixSurfaceDistance;
    uniform float uMixNoise;
    uniform sampler2D uInfoTexture;

    varying vec4 vColor;

    void main() {
      float dotNormal = dot(normal, uNormal) * 0.5 + 0.5;
      float normalP = smoothstep(uNormalThreshold, 1., dotNormal);
      float lifetimeNoise = uLifetimeNoise * mix(normalP, 1.0, uMixNoise);

      float t = uTime + position.x * 1. * uNoiseScale + position.y * 10. * uNoiseScale + 
      position.z * 7.3 * uNoiseScale + sin(lifetimeNoise * (position.x + 13. * position.y)) * lifetimeNoise;

      float lifetimeP = max(-0.0001, mix(-uCooldownRatio, 1. + cos(t) * lifetimeNoise, fract(t)));
      float surfaceDistance = texture2D(uInfoTexture, vec2(
        mix(normalP, lifetimeP, uMixSurfaceDistance),
        ${r.sequenceSurfaceDistance})).x * uSurfaceDistance;

      vec4 modelPosition = modelMatrix * (vec4(position, 1.0) + vec4(normal * surfaceDistance, 0.0));
      vec3 noise = texture2D(uInfoTexture, vec2(
        mix(normalP, lifetimeP, uMixNoise),
        ${r.sequenceNoise})).xyz;
      vec3 offset = uOffset * (texture2D(uInfoTexture, vec2(
        mix(normalP, lifetimeP, uMixOffset),
        ${r.sequenceOffset})).xyz * 2.0 - vec3(1.0, 1.0, 1.0));
      modelPosition.x += cos(t * uNoiseScale * 10.0) * 0.2 * uOffsetNoise * noise.x + offset.x;
      modelPosition.y += sin(t * uNoiseScale * 10.0) * 0.2 * uOffsetNoise * noise.y + offset.y;
      modelPosition.z += cos(t * uNoiseScale * 10.0) * 0.2 * uOffsetNoise * noise.z + offset.z;

      vec4 viewPosition = viewMatrix * modelPosition;
      vec4 projectionPostion = projectionMatrix * viewPosition;
      gl_Position = projectionPostion;

      gl_PointSize = 2.
      * texture2D(uInfoTexture, vec2(mix(normalP, lifetimeP, uMixSize), ${r.sequenceSize})).x
      * mix(1., abs(sin(t * uNoiseScale + position.x * 13.9 + position.y * 73.1)), uScaleNoise)
      * uSize * (100.0 / -viewPosition.z) * uPixelRatio;

      if (gl_PointSize < 0.6 || lifetimeP < 0.0) { gl_Position = vec4(2, 2, 2, 1); }

      vColor = texture2D(uInfoTexture, vec2(mix(normalP, lifetimeP, uMixColor), ${r.sequenceColor}))
      * texture2D(uInfoTexture, vec2(mix(normalP, lifetimeP, uMixAlpha), ${r.sequenceAlpha})).x * uAlpha;
    }`,
      fragmentShader: `
    varying vec4 vColor;

    uniform sampler2D uMap;
    uniform sampler2D uInfoTexture;

    void main() {
      gl_FragColor = vColor * texture2D(uMap, gl_PointCoord);
      #include <tonemapping_fragment>
      #include <${t >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
    }`
    }, l = new Xt(a), c = new Zo(void 0, l), u = l.uniforms, h = { immediate: !0 };
    [
      [u.uPixelRatio, je().sizes.aspectRatio],
      [u.uSize, n.size],
      [u.uNormalThreshold, n.normalThreshold],
      [u.uAlpha, n.alpha],
      [u.uOffset, n.offset],
      [u.uOffsetNoise, n.offsetNoise],
      [u.uMixColor, n.mixColor],
      [u.uMixAlpha, n.mixAlpha],
      [u.uMixOffset, n.mixOffset],
      [u.uMixSize, n.mixSize],
      [u.uMixSurfaceDistance, n.mixSurfaceDistance],
      [u.uMixNoise, n.mixNoise],
      [u.uInfoTexture, i]
    ].forEach(
      ([R, T]) => we(
        T,
        () => {
          R.value = T.value;
        },
        h
      )
    ), we(
      [n.noiseScale, n.lifetimeSec],
      () => {
        u.uNoiseScale.value = n.noiseScale.value * n.lifetimeSec.value;
      },
      h
    ), we(
      [n.lifetimeSec, n.cooldownSec],
      () => {
        u.uCooldownRatio.value = n.cooldownSec.value / n.lifetimeSec.value;
      },
      h
    ), we(n.map, () => {
      typeof n.map.value == "string" ? $i([n.map.value]).then((R) => l.uniforms.uMap.value = R) : l.uniforms.uMap.value = n.map.value;
    });
    const p = new He(), v = new ee();
    Ke().onLoop(({ elapsed: R }) => {
      c.getWorldQuaternion(p), v.copy(e.directionalLight ? e.directionalLight.position : St.DEFAULT_UP).normalize(), v.applyQuaternion(p.invert()), l.uniforms.uNormal.value = v, l.uniforms.uTime.value = R / (e.cooldownSec + e.lifetimeSec);
    });
    function _(R) {
      return R && "isObject3D" in R;
    }
    function y(R) {
      return R && "isBufferGeometry" in R;
    }
    ds(() => {
      e.geometry ? y(e.geometry) ? c.geometry.copy(e.geometry) : _(e.geometry) && "geometry" in e.geometry && y(e.geometry.geometry) && c.geometry.copy(e.geometry.geometry) : _(c.parent) && "geometry" in c.parent && y(c.parent.geometry) ? c.geometry.copy(c.parent.geometry) : c.geometry = new Xl(1, 16), typeof e.map == "string" && $i([e.map]).then((R) => l.uniforms.uMap.value = R);
    }), ot(() => {
      var R;
      (R = l.uniforms.uMap.value) == null || R.dispose(), i.value.dispose(), l.dispose();
    });
    const E = xe();
    return (R, T) => (fe(), de("primitive", {
      ref_key: "sparkleRef",
      ref: E,
      object: z(c)
    }, null, 8, $p));
  }
}), Zp = ["position", "a-scale"], Kp = ["size", "size-attenuation", "transparent", "alpha-test", "alpha-map"], Sg = /* @__PURE__ */ pe({
  __name: "Stars",
  props: {
    size: { default: 0.1 },
    sizeAttenuation: { type: Boolean, default: !0 },
    transparent: { type: Boolean, default: !0 },
    alphaTest: { default: 0.01 },
    count: { default: 5e3 },
    depth: { default: 50 },
    radius: { default: 100 },
    alphaMap: { default: null }
  },
  setup(o, { expose: e }) {
    const t = o, n = ue(), s = ue(), { radius: i, depth: r, count: a, size: l, sizeAttenuation: c, transparent: u, alphaMap: h, alphaTest: m } = Fe(t), p = () => {
      let _ = i.value + r.value;
      const y = Ne(() => r.value / a.value), E = [], R = Array.from(
        { length: a.value },
        () => (0.5 + 0.5 * Math.random()) * 4
      ), T = (g) => new ee().setFromSpherical(new Ws(g, Math.acos(1 - Math.random() * 2), Math.random() * 2 * Math.PI)).toArray();
      for (let g = 0; g < a.value; g++)
        _ -= y.value * Math.random(), E.push(...T(_));
      n.value = new Float32Array(E), s.value = new Float32Array(R);
    };
    ft(() => {
      p();
    });
    const v = xe();
    return e({
      value: v
    }), (_, y) => (fe(), de("TresPoints", {
      ref_key: "starsRef",
      ref: v
    }, [
      Te("TresBufferGeometry", {
        position: [n.value, 3],
        "a-scale": [s.value, 1]
      }, null, 8, Zp),
      Te("TresPointsMaterial", {
        size: z(l),
        "size-attenuation": z(c),
        transparent: z(u),
        "alpha-test": z(m),
        "alpha-map": z(h)
      }, null, 8, Kp)
    ], 512));
  }
});
let zt;
const Ag = (o = "body") => {
  zt || (zt = new ac({
    container: document.querySelector(o)
  }), zt.element.style.position = "absolute", zt.element.style.top = "1rem", zt.element.style.right = "1rem", zt.element.style.zIndex = "9999");
  const { logWarning: e } = gr();
  e("useTweakPane is deprecated as of Cientos v3.7.0 and will no longer be part of this package. Please migrate to @tresjs/leches package https://github.com/Tresjs/leches or v-tweakpane https://github.com/vinayakkulkarni/v-tweakpane instead.");
  function t() {
    zt && zt.dispose();
  }
  return ds(() => {
    const { resume: n } = Ke();
    n();
  }), ot(() => {
    t();
  }), { pane: zt, disposeTweakPane: t };
};
var qa = { exports: {} };
(function(o, e) {
  (function(t, n) {
    o.exports = n();
  })(If, function() {
    var t = function() {
      function n(p) {
        return r.appendChild(p.dom), p;
      }
      function s(p) {
        for (var v = 0; v < r.children.length; v++)
          r.children[v].style.display = v === p ? "block" : "none";
        i = p;
      }
      var i = 0, r = document.createElement("div");
      r.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", r.addEventListener("click", function(p) {
        p.preventDefault(), s(++i % r.children.length);
      }, !1);
      var a = (performance || Date).now(), l = a, c = 0, u = n(new t.Panel("FPS", "#0ff", "#002")), h = n(new t.Panel("MS", "#0f0", "#020"));
      if (self.performance && self.performance.memory)
        var m = n(new t.Panel("MB", "#f08", "#201"));
      return s(0), { REVISION: 16, dom: r, addPanel: n, showPanel: s, begin: function() {
        a = (performance || Date).now();
      }, end: function() {
        c++;
        var p = (performance || Date).now();
        if (h.update(p - a, 200), p > l + 1e3 && (u.update(1e3 * c / (p - l), 100), l = p, c = 0, m)) {
          var v = performance.memory;
          m.update(v.usedJSHeapSize / 1048576, v.jsHeapSizeLimit / 1048576);
        }
        return p;
      }, update: function() {
        a = this.end();
      }, domElement: r, setMode: s };
    };
    return t.Panel = function(n, s, i) {
      var r = 1 / 0, a = 0, l = Math.round, c = l(window.devicePixelRatio || 1), u = 80 * c, h = 48 * c, m = 3 * c, p = 2 * c, v = 3 * c, _ = 15 * c, y = 74 * c, E = 30 * c, R = document.createElement("canvas");
      R.width = u, R.height = h, R.style.cssText = "width:80px;height:48px";
      var T = R.getContext("2d");
      return T.font = "bold " + 9 * c + "px Helvetica,Arial,sans-serif", T.textBaseline = "top", T.fillStyle = i, T.fillRect(0, 0, u, h), T.fillStyle = s, T.fillText(n, m, p), T.fillRect(v, _, y, E), T.fillStyle = i, T.globalAlpha = 0.9, T.fillRect(v, _, y, E), { dom: R, update: function(g, A) {
        r = Math.min(r, g), a = Math.max(a, g), T.fillStyle = i, T.globalAlpha = 1, T.fillRect(0, 0, u, _), T.fillStyle = s, T.fillText(l(g) + " " + n + " (" + l(r) + "-" + l(a) + ")", m, p), T.drawImage(R, v + c, _, y - c, E, v, _, y - c, E), T.fillRect(v + y - c, _, c, E), T.fillStyle = i, T.globalAlpha = 0.9, T.fillRect(v + y - c, _, c, l((1 - g / A) * E));
      } };
    }, t;
  });
})(qa);
var qp = qa.exports;
const Qp = /* @__PURE__ */ ys(qp), Pg = pe({
  name: "Stats",
  props: {
    showPanel: {
      type: Number,
      default: 0
    }
  },
  setup(o, { expose: e }) {
    const t = new Qp();
    e({ stats: t });
    const n = document.body;
    t.showPanel(o.showPanel || 0), n == null || n.appendChild(t.dom);
    const { onBeforeLoop: s, onAfterLoop: i, resume: r } = Ke();
    r(), s(() => t.begin()), i(() => t.end()), ot(() => {
      n == null || n.removeChild(t.dom);
    });
  }
});
class Jp {
  constructor(e, t, n) {
    this.name = e, this.fg = t, this.bg = n, this.PR = Math.round(window.devicePixelRatio || 1), this.WIDTH = 90 * this.PR, this.HEIGHT = 48 * this.PR, this.TEXT_X = 3 * this.PR, this.TEXT_Y = 2 * this.PR, this.GRAPH_X = 3 * this.PR, this.GRAPH_Y = 15 * this.PR, this.GRAPH_WIDTH = 84 * this.PR, this.GRAPH_HEIGHT = 30 * this.PR, this.canvas = document.createElement("canvas"), this.canvas.width = 90 * this.PR, this.canvas.height = 48 * this.PR, this.canvas.style.width = "90px", this.canvas.style.position = "absolute", this.canvas.style.height = "48px", this.canvas.style.cssText = "width:90px;height:48px", this.context = this.canvas.getContext("2d"), this.context && (this.context.font = "bold " + 9 * this.PR + "px Helvetica,Arial,sans-serif", this.context.textBaseline = "top", this.context.fillStyle = this.bg, this.context.fillRect(0, 0, this.WIDTH, this.HEIGHT), this.context.fillStyle = this.fg, this.context.fillText(this.name, this.TEXT_X, this.TEXT_Y), this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT), this.context.fillStyle = this.bg, this.context.globalAlpha = 0.9, this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT));
  }
  update(e, t, n, s, i = 0) {
    let r = 1 / 0, a = 0;
    this.context && (r = Math.min(r, e), a = Math.max(n, e), s = Math.max(s, t), this.context.fillStyle = this.bg, this.context.globalAlpha = 1, this.context.fillRect(0, 0, this.WIDTH, this.GRAPH_Y), this.context.fillStyle = this.fg, this.context.fillText(e.toFixed(i) + " " + this.name + " (" + r.toFixed(i) + "-" + parseFloat(a.toFixed(i)) + ")", this.TEXT_X, this.TEXT_Y), this.context.drawImage(this.canvas, this.GRAPH_X + this.PR, this.GRAPH_Y, this.GRAPH_WIDTH - this.PR, this.GRAPH_HEIGHT, this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH - this.PR, this.GRAPH_HEIGHT), this.context.fillRect(this.GRAPH_X + this.GRAPH_WIDTH - this.PR, this.GRAPH_Y, this.PR, this.GRAPH_HEIGHT), this.context.fillStyle = this.bg, this.context.globalAlpha = 0.9, this.context.fillRect(this.GRAPH_X + this.GRAPH_WIDTH - this.PR, this.GRAPH_Y, this.PR, (1 - t / s) * this.GRAPH_HEIGHT));
  }
}
const Qa = class Ys {
  constructor({ logsPerSecond: e = 20, samplesLog: t = 100, samplesGraph: n = 10, precision: s = 2, minimal: i = !1, horizontal: r = !0, mode: a = 0 } = {}) {
    this.totalCpuDuration = 0, this.totalGpuDuration = 0, this.totalFps = 0, this.activeQuery = null, this.gpuQueries = [], this.renderCount = 0, this.mode = a, this.horizontal = r, this.dom = document.createElement("div"), this.dom.style.cssText = "position:fixed;top:0;left:0;opacity:0.9;z-index:10000;", i && (this.dom.style.cssText += "cursor:pointer"), this.gl = null, this.query = null, this.isRunningCPUProfiling = !1, this.minimal = i, this.beginTime = (performance || Date).now(), this.prevTime = this.beginTime, this.prevCpuTime = this.beginTime, this.frames = 0, this.renderCount = 0, this.threeRendererPatched = !1, this.averageCpu = {
      logs: [],
      graph: []
    }, this.averageGpu = {
      logs: [],
      graph: []
    }, this.queryCreated = !1, this.fpsPanel = this.addPanel(new Ys.Panel("FPS", "#0ff", "#002"), 0), this.msPanel = this.addPanel(new Ys.Panel("CPU", "#0f0", "#020"), 1), this.gpuPanel = null, this.samplesLog = t, this.samplesGraph = n, this.precision = s, this.logsPerSecond = e, this.minimal ? (this.dom.addEventListener("click", (l) => {
      l.preventDefault(), this.showPanel(++this.mode % this.dom.children.length);
    }, !1), this.mode = a, this.showPanel(this.mode)) : window.addEventListener("resize", () => {
      this.resizePanel(this.fpsPanel, 0), this.resizePanel(this.msPanel, 1), this.gpuPanel && this.resizePanel(this.gpuPanel, 2);
    });
  }
  patchThreeRenderer(e) {
    const t = e.render, n = this;
    e.render = function(s, i) {
      n.begin(), t.call(this, s, i), n.end();
    }, this.threeRendererPatched = !0;
  }
  resizePanel(e, t) {
    e.canvas.style.position = "absolute", this.minimal ? e.canvas.style.display = "none" : (e.canvas.style.display = "block", this.horizontal ? (e.canvas.style.top = "0px", e.canvas.style.left = t * e.WIDTH / e.PR + "px") : (e.canvas.style.left = "0px", e.canvas.style.top = t * e.HEIGHT / e.PR + "px"));
  }
  addPanel(e, t) {
    return e.canvas && (this.dom.appendChild(e.canvas), this.resizePanel(e, t)), e;
  }
  showPanel(e) {
    for (let t = 0; t < this.dom.children.length; t++) {
      const n = this.dom.children[t];
      n.style.display = t === e ? "block" : "none";
    }
    this.mode = e;
  }
  init(e) {
    if (!e) {
      console.error('Stats: The "canvas" parameter is undefined.');
      return;
    }
    if (e.isWebGLRenderer && !this.threeRendererPatched) {
      const t = e;
      this.patchThreeRenderer(t), this.gl = t.getContext();
    }
    if (!this.gl && e instanceof WebGL2RenderingContext)
      this.gl = e;
    else if (!this.gl && e instanceof HTMLCanvasElement || e instanceof OffscreenCanvas) {
      if (this.gl = e.getContext("webgl2"), !this.gl) {
        console.error("Stats: Unable to obtain WebGL2 context.");
        return;
      }
    } else if (!this.gl) {
      console.error("Stats: Invalid input type. Expected WebGL2RenderingContext, HTMLCanvasElement, or OffscreenCanvas.");
      return;
    }
    this.ext = this.gl.getExtension("EXT_disjoint_timer_query_webgl2"), this.ext && (this.gpuPanel = this.addPanel(new Ys.Panel("GPU", "#ff0", "#220"), 2));
  }
  begin() {
    this.isRunningCPUProfiling || this.beginProfiling("cpu-started"), !(!this.gl || !this.ext) && this.gl && this.ext && (this.activeQuery && this.gl.endQuery(this.ext.TIME_ELAPSED_EXT), this.activeQuery = this.gl.createQuery(), this.activeQuery !== null && this.gl.beginQuery(this.ext.TIME_ELAPSED_EXT, this.activeQuery));
  }
  end() {
    this.renderCount++, this.gl && this.ext && this.activeQuery && (this.gl.endQuery(this.ext.TIME_ELAPSED_EXT), this.gpuQueries.push({ query: this.activeQuery }), this.activeQuery = null);
  }
  processGpuQueries() {
    !this.gl || !this.ext || (this.totalGpuDuration = 0, this.gpuQueries.forEach((e, t) => {
      if (this.gl) {
        const n = this.gl.getQueryParameter(e.query, this.gl.QUERY_RESULT_AVAILABLE), s = this.gl.getParameter(this.ext.GPU_DISJOINT_EXT);
        if (n && !s) {
          const r = this.gl.getQueryParameter(e.query, this.gl.QUERY_RESULT) * 1e-6;
          this.totalGpuDuration += r, this.gl.deleteQuery(e.query), this.gpuQueries.splice(t, 1);
        }
      }
    }));
  }
  update() {
    this.processGpuQueries(), this.endProfiling("cpu-started", "cpu-finished", "cpu-duration"), this.addToAverage(this.totalCpuDuration, this.averageCpu), this.addToAverage(this.totalGpuDuration, this.averageGpu), this.renderCount = 0, this.totalCpuDuration = 0, this.totalGpuDuration = 0, this.totalFps = 0, this.beginTime = this.endInternal();
  }
  endInternal() {
    this.frames++;
    const e = (performance || Date).now();
    if (e >= this.prevCpuTime + 1e3 / this.logsPerSecond && (this.updatePanel(this.msPanel, this.averageCpu), this.updatePanel(this.gpuPanel, this.averageGpu), this.prevCpuTime = e), e >= this.prevTime + 1e3) {
      const t = this.frames * 1e3 / (e - this.prevTime);
      this.fpsPanel.update(t, t, 100, 100, 0), this.prevTime = e, this.frames = 0;
    }
    return e;
  }
  addToAverage(e, t) {
    t.logs.push(e), t.logs.length > this.samplesLog && t.logs.shift(), t.graph.push(e), t.graph.length > this.samplesGraph && t.graph.shift();
  }
  beginProfiling(e) {
    window.performance && (window.performance.mark(e), this.isRunningCPUProfiling = !0);
  }
  endProfiling(e, t, n) {
    if (window.performance && t && this.isRunningCPUProfiling) {
      window.performance.mark(t);
      const s = performance.measure(n, e, t);
      this.totalCpuDuration += s.duration, this.isRunningCPUProfiling = !1;
    }
  }
  updatePanel(e, t) {
    if (t.logs.length > 0) {
      let n = 0, s = 0.01;
      for (let a = 0; a < t.logs.length; a++)
        n += t.logs[a], t.logs[a] > s && (s = t.logs[a]);
      let i = 0, r = 0.01;
      for (let a = 0; a < t.graph.length; a++)
        i += t.graph[a], t.graph[a] > r && (r = t.graph[a]);
      e && e.update(n / Math.min(t.logs.length, this.samplesLog), i / Math.min(t.graph.length, this.samplesGraph), s, r, this.precision);
    }
  }
  get domElement() {
    return this.dom;
  }
  get container() {
    return console.warn("Stats: Deprecated! this.container as been replaced to this.dom "), this.dom;
  }
};
Qa.Panel = Jp;
let em = Qa;
const Rg = pe({
  name: "StatsGl",
  props: [
    "logsPerSecond",
    "samplesLog",
    "samplesGraph",
    "precision",
    "horizontal",
    "minimal",
    "mode"
  ],
  async setup(o, { expose: e }) {
    const t = new em({
      logsPerSecond: o.logsPerSecond,
      samplesLog: o.samplesLog,
      samplesGraph: o.samplesGraph,
      precision: o.precision,
      horizontal: o.horizontal,
      minimal: o.minimal,
      mode: o.mode
    });
    e({ statsGl: t });
    const n = document.body, s = t.dom || t.container;
    n == null || n.appendChild(s);
    const { renderer: i } = je(), { onAfterLoop: r, resume: a } = Ke();
    t.init(i.value), a(), r(() => {
      t.update();
    }), ot(() => {
      n == null || n.removeChild(s);
    });
  }
}), Cg = pe({
  name: "BakeShadows",
  setup() {
    const { renderer: o } = je();
    ft(() => {
      o.value.shadowMap.autoUpdate = !1, o.value.shadowMap.needsUpdate = !0;
    });
  }
});
var tm = `#include <common>

void main() {
  vec2 center = vec2(0., 1.);
  float rotation = 0.0;

  
  
  float size = 0.03;

  vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
  vec2 scale;
  scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
  scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

  bool isPerspective = isPerspectiveMatrix( projectionMatrix );
  if ( isPerspective ) scale *= - mvPosition.z;

  vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
  vec2 rotatedPosition;
  rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
  rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
  mvPosition.xy += rotatedPosition;

  gl_Position = projectionMatrix * mvPosition;
}`, nm = `void main() {
  gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
}`;
const vs = new ee(0, 0, 0), Tr = new ee(0, 0, 0), sm = new ee(0, 0, 0);
function Oo(o, e, t) {
  const n = vs.setFromMatrixPosition(o.matrixWorld);
  n.project(e);
  const s = t.width / 2, i = t.height / 2;
  return [
    (Number.isNaN(n.x) ? 0 : n.x) * s + s,
    -(n.y * i) + i
  ];
}
function im(o, e) {
  const t = vs.setFromMatrixPosition(o.matrixWorld), n = Tr.setFromMatrixPosition(e.matrixWorld), s = t.sub(n), i = e.getWorldDirection(sm);
  return s.angleTo(i) > Math.PI / 2;
}
function rm(o, e, t, n) {
  const s = vs.setFromMatrixPosition(o.matrixWorld), i = s.clone();
  i.project(e), t.setFromCamera(new le(i.x, i.y), e);
  const r = t.intersectObjects(n, !0);
  if (r.length > 0) {
    const a = r[0].distance;
    return s.distanceTo(t.ray.origin) < a;
  }
  return !0;
}
function om(o, e) {
  if (e instanceof jt)
    return e.zoom;
  if (e instanceof Mt) {
    const t = vs.setFromMatrixPosition(o.matrixWorld), n = Tr.setFromMatrixPosition(e.matrixWorld), s = e.fov * Math.PI / 180, i = t.distanceTo(n);
    return 1 / (2 * Math.tan(s / 2) * i);
  } else
    return 1;
}
function am(o, e, t) {
  if (e instanceof Mt || e instanceof jt) {
    const n = vs.setFromMatrixPosition(o.matrixWorld), s = Tr.setFromMatrixPosition(e.matrixWorld), i = n.distanceTo(s), r = (t[1] - t[0]) / (e.far - e.near), a = t[1] - r * e.far;
    return Math.round(r * i + a);
  }
}
const ir = (o) => Math.abs(o) < 1e-10 ? 0 : o;
function Ja(o, e, t = "") {
  let n = "matrix3d(";
  for (let s = 0; s !== 16; s++)
    n += ir(e[s] * o.elements[s]) + (s !== 15 ? "," : ")");
  return t + n;
}
const lm = /* @__PURE__ */ ((o) => (e) => Ja(e, o))([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]), cm = /* @__PURE__ */ ((o) => (e, t) => Ja(e, o(t), "translate(-50%,-50%)"))((o) => [1 / o, 1 / o, 1 / o, 1, -1 / o, -1 / o, -1 / o, -1, 1 / o, 1 / o, 1 / o, 1, 1, 1, 1, 1]), um = ["geometry", "material"], Ig = /* @__PURE__ */ pe({
  __name: "HTML",
  props: {
    geometry: { default: new Dt() },
    material: {},
    as: { default: "div" },
    transform: { type: Boolean, default: !1 },
    portal: {},
    wrapperClass: {},
    eps: { default: 1e-4 },
    distanceFactor: {},
    fullscreen: { type: Boolean },
    center: { type: Boolean },
    pointerEvents: { default: "auto" },
    sprite: { type: Boolean, default: !1 },
    zIndexRange: { default: () => [16777271, 0] },
    occlude: { type: [Array, Boolean, String] }
  },
  emits: ["onOcclude"],
  setup(o, { emit: e }) {
    const t = o, n = e, s = fa(), i = ra(), r = ue(), a = ue(), {
      geometry: l,
      material: c,
      as: u,
      transform: h,
      portal: m,
      wrapperClass: p,
      eps: v,
      distanceFactor: _,
      fullscreen: y,
      center: E,
      pointerEvents: R,
      sprite: T,
      occlude: g,
      zIndexRange: A
    } = Fe(t), { renderer: x, scene: M, camera: d, raycaster: w, sizes: f } = je(), P = Ne(() => document.createElement(u.value)), I = ue([0, 0]), K = ue(0), N = ue(), Z = Ne(() => h.value ? {
      position: "absolute",
      top: 0,
      left: 0,
      width: `${f.width.value}px`,
      height: `${f.height.value}px`,
      transformStyle: "preserve-3d",
      pointerEvents: "none",
      zIndex: 2,
      willChange: "transform"
    } : {
      position: "absolute",
      transform: E.value ? "translate3d(-50%,-50%,0)" : "none",
      ...y.value && {
        top: -f.height.value / 2,
        left: -f.width.value / 2,
        width: `${f.width.value}px`,
        height: `${f.height.value}px`
      },
      zIndex: 2,
      ...s.style,
      willChange: "transform"
    }), W = Ne(() => ({
      position: "absolute",
      pointerEvents: R.value
    })), X = ue(null), V = ue(!1), ne = Ne(
      () => (g == null ? void 0 : g.value) && (g == null ? void 0 : g.value) !== "blending" || Array.isArray(g == null ? void 0 : g.value) && (g == null ? void 0 : g.value.length) && Wi(g.value[0])
    );
    we(
      () => g,
      (b) => {
        b && b === "blending" ? (P.value.style.zIndex = `${Math.floor(A.value[0] / 2)}`, P.value.style.position = "absolute", P.value.style.pointerEvents = "none") : (P.value.style.zIndex = null, P.value.style.position = null, P.value.style.pointerEvents = null);
      }
    ), we(
      () => {
        var b;
        return [r.value, x.value, f.width.value, f.height.value, (b = i.default) == null ? void 0 : b.call(i)];
      },
      ([b, U]) => {
        var J, F, B, S, C, D;
        if (b && U) {
          const G = (m == null ? void 0 : m.value) || U.domElement;
          if ((J = M.value) == null || J.updateMatrixWorld(), h.value)
            P.value.style.cssText = "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";
          else {
            const $ = Oo(b, d.value, {
              width: f.width.value,
              height: f.height.value
            });
            P.value.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${$[0]}px,${$[1]}px,0);transform-origin:0 0;`;
          }
          G && !P.value.parentNode && ((F = G.parentNode) == null || F.appendChild(P.value)), h.value ? N.value = bs("div", { id: "outer", style: Z.value }, [
            bs("div", { id: "inner", style: W.value }, [
              bs("div", {
                key: (B = a.value) == null ? void 0 : B.uuid,
                id: M == null ? void 0 : M.value.uuid,
                class: s.class,
                style: s.style
              }, (S = i.default) == null ? void 0 : S.call(i))
            ])
          ]) : N.value = bs(
            "div",
            {
              key: (C = a.value) == null ? void 0 : C.uuid,
              id: M == null ? void 0 : M.value.uuid,
              style: Z.value
            },
            (D = i.default) == null ? void 0 : D.call(i)
          ), rc(N.value, P.value);
        }
      }
    ), ft(() => {
      p != null && p.value && (P.value.className = p.value);
    });
    const se = ue(!0), { onLoop: he } = Ke();
    he(() => {
      var b, U, J, F, B, S, C;
      if (r.value && d.value && x.value) {
        (b = d.value) == null || b.updateMatrixWorld(), r.value.updateWorldMatrix(!0, !1);
        const D = h.value ? I.value : Oo(r.value, d.value, {
          width: f.width.value || 0,
          height: f.height.value || 0
        });
        if (h.value || Math.abs(K.value - d.value.zoom) > v.value || Math.abs(I.value[0] - D[0]) > v.value || Math.abs(I.value[1] - D[1]) > v.value) {
          const G = im(r.value, d.value);
          let $ = !1;
          ne.value && (Array.isArray(g == null ? void 0 : g.value) ? $ = g == null ? void 0 : g.value : (g == null ? void 0 : g.value) !== "blending" && ($ = [M.value]));
          const Y = se.value;
          if ($) {
            const L = rm(
              r.value,
              d.value,
              w.value,
              $
            );
            se.value = L && !G;
          } else
            se.value = !G;
          Y !== se.value && (n("onOcclude", !se.value), P.value.style.display = se.value ? "block" : "none");
          const te = Math.floor(A.value[0] / 2), O = g != null && g.value ? ne.value ? [A.value[0], te] : [te - 1, 0] : A.value;
          if (P.value.style.zIndex = `${am(r.value, d.value, O)}`, P.value.style.willChange = "transform", h.value) {
            const [L, re] = [
              f.width.value / 2,
              f.height.value / 2
            ], ce = d.value.projectionMatrix.elements[5] * re, { isOrthographicCamera: be, top: Me, left: Se, bottom: qe, right: kt } = d.value, jn = lm(d.value.matrixWorldInverse), Sn = be ? `scale(${ce})translate(${ir(-(kt + Se) / 2)}px,${ir((Me + qe) / 2)}px)` : `translateZ(${ce}px)`;
            let gt = r.value.matrixWorld;
            T.value && (gt = d.value.matrixWorldInverse.clone().transpose().copyPosition(gt).scale(r.value.scale), gt.elements[3] = gt.elements[7] = gt.elements[11] = 0, gt.elements[15] = 1), P.value.style.width = `${f.width.value}px`, P.value.style.height = `${f.height.value}px`, P.value.style.perspective = be ? "" : `${ce}px`, (U = N.value) != null && U.el && ((J = N.value) != null && J.children) && (N.value.el.style.willChange = "transform", N.value.el.style.transform = `${Sn}${jn}translate(${L}px,${re}px)`, N.value.children[0].willChange = "transform", N.value.children[0].el.style.transform = cm(
              gt,
              1 / (((_ == null ? void 0 : _.value) || 10) / 400)
            ));
          } else {
            const L = (_ == null ? void 0 : _.value) === void 0 ? 1 : om(r.value, d.value) * (_ == null ? void 0 : _.value);
            P.value.style.transform = `translate3d(${D[0]}px,${D[1]}px,0) scale(${L})`;
          }
        }
        I.value = D, K.value = d.value.zoom;
      }
      if (!ne.value && a.value && !V.value)
        if (h.value) {
          if ((F = N.value) != null && F.el && ((B = N.value) != null && B.children)) {
            const D = (S = N.value) == null ? void 0 : S.children[0];
            if (D != null && D.clientWidth && (D != null && D.clientHeight)) {
              const { isOrthographicCamera: G } = d.value;
              if (G || l)
                s.scale && (Array.isArray(s.scale) ? s.scale instanceof ee ? a.value.scale.copy(s.scale.clone().divideScalar(1)) : a.value.scale.set(1 / s.scale[0], 1 / s.scale[1], 1 / s.scale[2]) : a.value.scale.setScalar(1 / s.scale));
              else {
                const $ = ((_ == null ? void 0 : _.value) || 10) / 400, Y = D.clientWidth * $, te = D.clientHeight * $;
                a.value.scale.set(Y, te, 1);
              }
              V.value = !0;
            }
          }
        } else {
          const D = P.value.children[0];
          if (D != null && D.clientWidth && (D != null && D.clientHeight)) {
            const $ = D.clientWidth * 1, Y = D.clientHeight * 1;
            a.value.scale.set($, Y, 1), V.value = !0;
          }
          X.value.lookAt((C = d.value) == null ? void 0 : C.position);
        }
    });
    const H = Ne(() => ({
      vertexShader: h.value ? void 0 : tm,
      fragmentShader: nm
    })), k = Ne(() => {
      const b = H.value;
      return c.value || new Xt({
        vertexShader: b.vertexShader,
        fragmentShader: b.fragmentShader,
        side: wn
      });
    });
    return ot(() => {
      k.value && k.value.dispose(), P.value.remove();
    }), (b, U) => (fe(), de("TresGroup", {
      ref_key: "groupRef",
      ref: r
    }, [
      z(g) && !ne.value ? (fe(), de("TresMesh", {
        key: 0,
        ref_key: "meshRef",
        ref: a,
        geometry: z(l),
        material: k.value
      }, null, 8, um)) : Wt("", !0)
    ], 512));
  }
}), { logError: hm } = ps();
async function Dg(o, e) {
  const t = new hr(), n = (e == null ? void 0 : e.fileName) || "scene";
  t.parse(
    o,
    (s) => {
      if (s instanceof ArrayBuffer)
        dm(s, `${n}.glb`);
      else {
        const i = JSON.stringify(s, null, 2);
        fm(i, `${n}.gltf`);
      }
    },
    (s) => {
      hm("An error happened while exporting the GLTF", s);
    },
    e
  );
}
function fm(o, e) {
  el(new Blob([o], { type: "text/plain" }), e);
}
function dm(o, e) {
  el(new Blob([o], { type: "application/octet-stream" }), e);
}
function el(o, e) {
  const t = document.createElement("a");
  t.style.display = "none", document.body.appendChild(t), t.href = URL.createObjectURL(o), t.download = e, t.click(), t.remove();
}
const Lg = {
  mounted: (o, e) => {
    if (e.arg) {
      console.log(`v-log:${e.arg}`, o[e.arg]);
      return;
    }
    console.log("v-log", o);
  }
}, { logWarning: Fo } = ps(), Og = {
  mounted: (o) => {
    if (!o.isLight) {
      Fo(`${o.type} is not a light`);
      return;
    }
    Hs = pm[o.type], o.parent.add(new Hs(o));
  },
  updated: (o) => {
    Bn = o.parent.children.find((e) => e instanceof Hs), !(Bn instanceof Ra) && Bn.update();
  },
  unmounted: (o) => {
    if (!o.isLight) {
      Fo(`${o.type} is not a light`);
      return;
    }
    Bn = o.parent.children.find((e) => e instanceof Hs), Bn.dispose(), o.parent.remove(Bn);
  }
};
let Hs, Bn;
const pm = {
  DirectionalLight: Wl,
  PointLight: $l,
  SpotLight: Zl,
  HemisphereLight: Kl,
  RectAreaLight: Ra
};
function Fg(o, e) {
  const t = {};
  for (const n of e)
    Object.prototype.hasOwnProperty.call(o, n) && (t[n] = o[n]);
  return t;
}
function kg(o, e) {
  const t = `set${e[0].toUpperCase()}${e.slice(1)}`;
  return o[t] !== void 0;
}
function tl(o) {
  var t, n;
  let e = o.value;
  return o.value && ((n = (t = o.value) == null ? void 0 : t.value) != null && n.isMesh) && (e = o.value.value.position), Array.isArray(o.value) && (e = new ee(...e)), e;
}
const { logWarning: mm } = ps(), Ug = {
  updated: (o, e) => {
    const t = tl(e);
    if (!t) {
      mm(`v-always-look-at: problem with binding value: ${e.value}`);
      return;
    }
    const { onLoop: n } = Ke();
    n(() => {
      o.lookAt(t);
    });
  }
}, { logWarning: gm } = ps(), Bg = {
  updated: (o, e) => {
    var s;
    const t = tl(e);
    if (!t) {
      gm(`v-distance-to: problem with binding value: ${e.value}`);
      return;
    }
    Ht && (Ht.dispose(), o.parent.remove(Ht));
    const n = t.clone().sub(o.position);
    n.normalize(), Ht = new ql(n, o.position, o.position.distanceTo(t) / 1.5, 16776960), o.parent.add(Ht), console.table(
      [
        ["Distance:", o.position.distanceTo(t)],
        [`origin: ${o.name || o.type}`, `x:${o.position.x}, y:${o.position.y}, z:${(s = o.position) == null ? void 0 : s.z}`],
        [`Destiny: ${o.name || o.type}`, `x:${t.x}, y:${t.y}, z:${t == null ? void 0 : t.z}`]
      ]
    );
  },
  unmounted: (o) => {
    Ht == null || Ht.dispose(), o.parent.remove(Ht);
  }
};
let Ht = null;
export {
  xg as Backdrop,
  Cg as BakeShadows,
  ig as Box,
  Jm as CameraControls,
  rg as CatmullRomCurve3,
  og as Circle,
  ag as Cone,
  wg as ContactShadows,
  ng as CustomShaderMaterial,
  lg as Dodecahedron,
  _g as Environment,
  jm as FBXModel,
  zm as Fbo,
  Gm as GLTFModel,
  Bm as GlobalAudio,
  Ig as Html,
  cg as Icosahedron,
  $m as KeyboardControls,
  Nm as Lensflare,
  Fm as Levioso,
  Vd as Line2,
  qm as MapControls,
  tg as MeshGlassMaterial,
  sg as MeshReflectionMaterial,
  eg as MeshWobbleMaterial,
  Um as MouseParallax,
  ug as Octahedron,
  Wm as OrbitControls,
  hg as Plane,
  Km as PointerLockControls,
  Tg as Precipitation,
  km as Reflector,
  fg as Ring,
  Vm as SVG,
  Hm as Sampler,
  Qm as ScrollControls,
  bg as Sky,
  Eg as Smoke,
  Mg as Sparkles,
  dg as Sphere,
  Sg as Stars,
  Pg as Stats,
  Rg as StatsGl,
  pg as Superformula,
  mg as Tetrahedron,
  Lm as Text3D,
  gg as Torus,
  yg as TorusKnot,
  Zm as TransformControls,
  vg as Tube,
  tl as extractBindingPosition,
  kg as hasSetter,
  Fg as pick,
  Om as useAnimations,
  nf as useEnvironment,
  Jh as useFBO,
  af as useFBX,
  rf as useGLTF,
  Dg as useGLTFExporter,
  Ym as useProgress,
  ef as useSurfaceSampler,
  Ag as useTweakPane,
  Xm as useVideoTexture,
  Ug as vAlwaysLookAt,
  Bg as vDistanceTo,
  Og as vLightHelper,
  Lg as vLog
};

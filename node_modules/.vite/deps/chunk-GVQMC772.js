import {
  ACESFilmicToneMapping,
  ArrowHelper,
  BackSide,
  BufferAttribute,
  BufferGeometry,
  Camera,
  Clock,
  Color,
  DirectionalLightHelper,
  DoubleSide,
  Float32BufferAttribute,
  HemisphereLightHelper,
  Line,
  LineBasicMaterial,
  LoadingManager,
  Mesh,
  MeshBasicMaterial,
  OrthographicCamera,
  PCFSoftShadowMap,
  PerspectiveCamera,
  PointLightHelper,
  REVISION,
  Raycaster,
  SRGBColorSpace,
  Scene,
  SpotLightHelper,
  TextureLoader,
  Vector2,
  Vector3,
  WebGLRenderer,
  three_module_exports
} from "./chunk-SSCX553G.js";
import {
  Fragment,
  computed,
  createElementBlock,
  createRenderer,
  customRef,
  defineComponent,
  getCurrentInstance,
  getCurrentScope,
  h,
  inject,
  isRef,
  nextTick,
  normalizeClass,
  normalizeStyle,
  onMounted,
  onScopeDispose,
  onUnmounted,
  openBlock,
  provide,
  reactive,
  readonly,
  ref,
  shallowRef,
  toRefs,
  unref,
  useSlots,
  watch,
  watchEffect
} from "./chunk-2FDUVFJ5.js";

// node_modules/@vueuse/shared/index.mjs
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
function createEventHook() {
  const fns = /* @__PURE__ */ new Set();
  const off = (fn) => {
    fns.delete(fn);
  };
  const on = (fn) => {
    fns.add(fn);
    const offFn = () => off(fn);
    tryOnScopeDispose(offFn);
    return {
      off: offFn
    };
  };
  const trigger = (...args) => {
    return Promise.all(Array.from(fns).map((fn) => fn(...args)));
  };
  return {
    on,
    off,
    trigger
  };
}
function toValue(r) {
  return typeof r === "function" ? r() : unref(r);
}
var isClient = typeof window !== "undefined" && typeof document !== "undefined";
var isWorker = typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
var notNullish = (val) => val != null;
var toString = Object.prototype.toString;
var isObject = (val) => toString.call(val) === "[object Object]";
var noop = () => {
};
var isIOS = getIsIOS();
function getIsIOS() {
  var _a, _b;
  return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function createFilterWrapper(filter, fn) {
  function wrapper(...args) {
    return new Promise((resolve, reject) => {
      Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);
    });
  }
  return wrapper;
}
function debounceFilter(ms, options = {}) {
  let timer;
  let maxTimer;
  let lastRejector = noop;
  const _clearTimeout = (timer2) => {
    clearTimeout(timer2);
    lastRejector();
    lastRejector = noop;
  };
  const filter = (invoke) => {
    const duration = toValue(ms);
    const maxDuration = toValue(options.maxWait);
    if (timer)
      _clearTimeout(timer);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        _clearTimeout(maxTimer);
        maxTimer = null;
      }
      return Promise.resolve(invoke());
    }
    return new Promise((resolve, reject) => {
      lastRejector = options.rejectOnCancel ? reject : resolve;
      if (maxDuration && !maxTimer) {
        maxTimer = setTimeout(() => {
          if (timer)
            _clearTimeout(timer);
          maxTimer = null;
          resolve(invoke());
        }, maxDuration);
      }
      timer = setTimeout(() => {
        if (maxTimer)
          _clearTimeout(maxTimer);
        maxTimer = null;
        resolve(invoke());
      }, duration);
    });
  };
  return filter;
}
function cacheStringFunction(fn) {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
var camelizeRE = /-(\w)/g;
var camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
function identity(arg) {
  return arg;
}
function objectPick(obj, keys2, omitUndefined = false) {
  return keys2.reduce((n, k2) => {
    if (k2 in obj) {
      if (!omitUndefined || obj[k2] !== void 0)
        n[k2] = obj[k2];
    }
    return n;
  }, {});
}
function getLifeCycleTarget(target) {
  return target || getCurrentInstance();
}
function useDebounceFn(fn, ms = 200, options = {}) {
  return createFilterWrapper(
    debounceFilter(ms, options),
    fn
  );
}
function refDebounced(value, ms = 200, options = {}) {
  const debounced = ref(value.value);
  const updater = useDebounceFn(() => {
    debounced.value = value.value;
  }, ms, options);
  watch(value, () => updater());
  return debounced;
}
function toRefs2(objectRef, options = {}) {
  if (!isRef(objectRef))
    return toRefs(objectRef);
  const result = Array.isArray(objectRef.value) ? Array.from({ length: objectRef.value.length }) : {};
  for (const key in objectRef.value) {
    result[key] = customRef(() => ({
      get() {
        return objectRef.value[key];
      },
      set(v2) {
        var _a;
        const replaceRef = (_a = toValue(options.replaceRef)) != null ? _a : true;
        if (replaceRef) {
          if (Array.isArray(objectRef.value)) {
            const copy = [...objectRef.value];
            copy[key] = v2;
            objectRef.value = copy;
          } else {
            const newObject = { ...objectRef.value, [key]: v2 };
            Object.setPrototypeOf(newObject, Object.getPrototypeOf(objectRef.value));
            objectRef.value = newObject;
          }
        } else {
          objectRef.value[key] = v2;
        }
      }
    }));
  }
  return result;
}
function tryOnMounted(fn, sync = true, target) {
  const instance = getLifeCycleTarget();
  if (instance)
    onMounted(fn, target);
  else if (sync)
    fn();
  else
    nextTick(fn);
}
function useIntervalFn(cb, interval = 1e3, options = {}) {
  const {
    immediate = true,
    immediateCallback = false
  } = options;
  let timer = null;
  const isActive = ref(false);
  function clean() {
    if (timer) {
      clearInterval(timer);
      timer = null;
    }
  }
  function pause() {
    isActive.value = false;
    clean();
  }
  function resume() {
    const intervalValue = toValue(interval);
    if (intervalValue <= 0)
      return;
    isActive.value = true;
    if (immediateCallback)
      cb();
    clean();
    timer = setInterval(cb, intervalValue);
  }
  if (immediate && isClient)
    resume();
  if (isRef(interval) || typeof interval === "function") {
    const stopWatch = watch(interval, () => {
      if (isActive.value && isClient)
        resume();
    });
    tryOnScopeDispose(stopWatch);
  }
  tryOnScopeDispose(pause);
  return {
    isActive,
    pause,
    resume
  };
}

// node_modules/@vueuse/core/node_modules/vue-demi/lib/index.mjs
var isVue22 = false;

// node_modules/@vueuse/core/index.mjs
function unrefElement(elRef) {
  var _a;
  const plain = toValue(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}
var defaultWindow = isClient ? window : void 0;
var defaultDocument = isClient ? window.document : void 0;
var defaultNavigator = isClient ? window.navigator : void 0;
var defaultLocation = isClient ? window.location : void 0;
function useEventListener(...args) {
  let target;
  let events;
  let listeners;
  let options;
  if (typeof args[0] === "string" || Array.isArray(args[0])) {
    [events, listeners, options] = args;
    target = defaultWindow;
  } else {
    [target, events, listeners, options] = args;
  }
  if (!target)
    return noop;
  if (!Array.isArray(events))
    events = [events];
  if (!Array.isArray(listeners))
    listeners = [listeners];
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register = (el, event, listener, options2) => {
    el.addEventListener(event, listener, options2);
    return () => el.removeEventListener(event, listener, options2);
  };
  const stopWatch = watch(
    () => [unrefElement(target), toValue(options)],
    ([el, options2]) => {
      cleanup();
      if (!el)
        return;
      const optionsClone = isObject(options2) ? { ...options2 } : options2;
      cleanups.push(
        ...events.flatMap((event) => {
          return listeners.map((listener) => register(el, event, listener, optionsClone));
        })
      );
    },
    { immediate: true, flush: "post" }
  );
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return stop;
}
function useMounted() {
  const isMounted = ref(false);
  const instance = getCurrentInstance();
  if (instance) {
    onMounted(() => {
      isMounted.value = true;
    }, isVue22 ? null : instance);
  }
  return isMounted;
}
function useSupported(callback) {
  const isMounted = useMounted();
  return computed(() => {
    isMounted.value;
    return Boolean(callback());
  });
}
function useRafFn(fn, options = {}) {
  const {
    immediate = true,
    fpsLimit = void 0,
    window: window2 = defaultWindow
  } = options;
  const isActive = ref(false);
  const intervalLimit = fpsLimit ? 1e3 / fpsLimit : null;
  let previousFrameTimestamp = 0;
  let rafId = null;
  function loop(timestamp2) {
    if (!isActive.value || !window2)
      return;
    if (!previousFrameTimestamp)
      previousFrameTimestamp = timestamp2;
    const delta = timestamp2 - previousFrameTimestamp;
    if (intervalLimit && delta < intervalLimit) {
      rafId = window2.requestAnimationFrame(loop);
      return;
    }
    previousFrameTimestamp = timestamp2;
    fn({ delta, timestamp: timestamp2 });
    rafId = window2.requestAnimationFrame(loop);
  }
  function resume() {
    if (!isActive.value && window2) {
      isActive.value = true;
      previousFrameTimestamp = 0;
      rafId = window2.requestAnimationFrame(loop);
    }
  }
  function pause() {
    isActive.value = false;
    if (rafId != null && window2) {
      window2.cancelAnimationFrame(rafId);
      rafId = null;
    }
  }
  if (immediate)
    resume();
  tryOnScopeDispose(pause);
  return {
    isActive: readonly(isActive),
    pause,
    resume
  };
}
function useMediaQuery(query, options = {}) {
  const { window: window2 = defaultWindow } = options;
  const isSupported = useSupported(() => window2 && "matchMedia" in window2 && typeof window2.matchMedia === "function");
  let mediaQuery;
  const matches = ref(false);
  const handler = (event) => {
    matches.value = event.matches;
  };
  const cleanup = () => {
    if (!mediaQuery)
      return;
    if ("removeEventListener" in mediaQuery)
      mediaQuery.removeEventListener("change", handler);
    else
      mediaQuery.removeListener(handler);
  };
  const stopWatch = watchEffect(() => {
    if (!isSupported.value)
      return;
    cleanup();
    mediaQuery = window2.matchMedia(toValue(query));
    if ("addEventListener" in mediaQuery)
      mediaQuery.addEventListener("change", handler);
    else
      mediaQuery.addListener(handler);
    matches.value = mediaQuery.matches;
  });
  tryOnScopeDispose(() => {
    stopWatch();
    cleanup();
    mediaQuery = void 0;
  });
  return matches;
}
var _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var globalKey = "__vueuse_ssr_handlers__";
var handlers = getHandlers();
function getHandlers() {
  if (!(globalKey in _global))
    _global[globalKey] = _global[globalKey] || {};
  return _global[globalKey];
}
function useMutationObserver(target, callback, options = {}) {
  const { window: window2 = defaultWindow, ...mutationOptions } = options;
  let observer;
  const isSupported = useSupported(() => window2 && "MutationObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const targets = computed(() => {
    const value = toValue(target);
    const items = (Array.isArray(value) ? value : [value]).map(unrefElement).filter(notNullish);
    return new Set(items);
  });
  const stopWatch = watch(
    () => targets.value,
    (targets2) => {
      cleanup();
      if (isSupported.value && window2 && targets2.size) {
        observer = new MutationObserver(callback);
        targets2.forEach((el) => observer.observe(el, mutationOptions));
      }
    },
    { immediate: true, flush: "post" }
  );
  const takeRecords = () => {
    return observer == null ? void 0 : observer.takeRecords();
  };
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop,
    takeRecords
  };
}
function useDevicePixelRatio(options = {}) {
  const {
    window: window2 = defaultWindow
  } = options;
  const pixelRatio = ref(1);
  if (window2) {
    let observe2 = function() {
      pixelRatio.value = window2.devicePixelRatio;
      cleanup2();
      media = window2.matchMedia(`(resolution: ${pixelRatio.value}dppx)`);
      media.addEventListener("change", observe2, { once: true });
    }, cleanup2 = function() {
      media == null ? void 0 : media.removeEventListener("change", observe2);
    };
    let media;
    observe2();
    tryOnScopeDispose(cleanup2);
  }
  return { pixelRatio };
}
function useResizeObserver(target, callback, options = {}) {
  const { window: window2 = defaultWindow, ...observerOptions } = options;
  let observer;
  const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const targets = computed(() => Array.isArray(target) ? target.map((el) => unrefElement(el)) : [unrefElement(target)]);
  const stopWatch = watch(
    targets,
    (els) => {
      cleanup();
      if (isSupported.value && window2) {
        observer = new ResizeObserver(callback);
        for (const _el of els)
          _el && observer.observe(_el, observerOptions);
      }
    },
    { immediate: true, flush: "post" }
  );
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop
  };
}
function useElementBounding(target, options = {}) {
  const {
    reset = true,
    windowResize = true,
    windowScroll = true,
    immediate = true
  } = options;
  const height = ref(0);
  const bottom = ref(0);
  const left = ref(0);
  const right = ref(0);
  const top = ref(0);
  const width = ref(0);
  const x = ref(0);
  const y = ref(0);
  function update() {
    const el = unrefElement(target);
    if (!el) {
      if (reset) {
        height.value = 0;
        bottom.value = 0;
        left.value = 0;
        right.value = 0;
        top.value = 0;
        width.value = 0;
        x.value = 0;
        y.value = 0;
      }
      return;
    }
    const rect = el.getBoundingClientRect();
    height.value = rect.height;
    bottom.value = rect.bottom;
    left.value = rect.left;
    right.value = rect.right;
    top.value = rect.top;
    width.value = rect.width;
    x.value = rect.x;
    y.value = rect.y;
  }
  useResizeObserver(target, update);
  watch(() => unrefElement(target), (ele) => !ele && update());
  useMutationObserver(target, update, {
    attributeFilter: ["style", "class"]
  });
  if (windowScroll)
    useEventListener("scroll", update, { capture: true, passive: true });
  if (windowResize)
    useEventListener("resize", update, { passive: true });
  tryOnMounted(() => {
    if (immediate)
      update();
  });
  return {
    height,
    bottom,
    left,
    right,
    top,
    width,
    x,
    y,
    update
  };
}
function useElementSize(target, initialSize = { width: 0, height: 0 }, options = {}) {
  const { window: window2 = defaultWindow, box = "content-box" } = options;
  const isSVG = computed(() => {
    var _a, _b;
    return (_b = (_a = unrefElement(target)) == null ? void 0 : _a.namespaceURI) == null ? void 0 : _b.includes("svg");
  });
  const width = ref(initialSize.width);
  const height = ref(initialSize.height);
  const { stop: stop1 } = useResizeObserver(
    target,
    ([entry]) => {
      const boxSize = box === "border-box" ? entry.borderBoxSize : box === "content-box" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;
      if (window2 && isSVG.value) {
        const $elem = unrefElement(target);
        if ($elem) {
          const styles = window2.getComputedStyle($elem);
          width.value = Number.parseFloat(styles.width);
          height.value = Number.parseFloat(styles.height);
        }
      } else {
        if (boxSize) {
          const formatBoxSize = Array.isArray(boxSize) ? boxSize : [boxSize];
          width.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);
          height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);
        } else {
          width.value = entry.contentRect.width;
          height.value = entry.contentRect.height;
        }
      }
    },
    options
  );
  tryOnMounted(() => {
    const ele = unrefElement(target);
    if (ele) {
      width.value = "offsetWidth" in ele ? ele.offsetWidth : initialSize.width;
      height.value = "offsetHeight" in ele ? ele.offsetHeight : initialSize.height;
    }
  });
  const stop2 = watch(
    () => unrefElement(target),
    (ele) => {
      width.value = ele ? initialSize.width : 0;
      height.value = ele ? initialSize.height : 0;
    }
  );
  function stop() {
    stop1();
    stop2();
  }
  return {
    width,
    height,
    stop
  };
}
function useFps(options) {
  var _a;
  const fps = ref(0);
  if (typeof performance === "undefined")
    return fps;
  const every = (_a = options == null ? void 0 : options.every) != null ? _a : 10;
  let last = performance.now();
  let ticks = 0;
  useRafFn(() => {
    ticks += 1;
    if (ticks >= every) {
      const now = performance.now();
      const diff = now - last;
      fps.value = Math.round(1e3 / (diff / ticks));
      last = now;
      ticks = 0;
    }
  });
  return fps;
}
function useMemory(options = {}) {
  const memory = ref();
  const isSupported = useSupported(() => typeof performance !== "undefined" && "memory" in performance);
  if (isSupported.value) {
    const { interval = 1e3 } = options;
    useIntervalFn(() => {
      memory.value = performance.memory;
    }, interval, { immediate: options.immediate, immediateCallback: options.immediateCallback });
  }
  return { isSupported, memory };
}
var defaultState = {
  x: 0,
  y: 0,
  pointerId: 0,
  pressure: 0,
  tiltX: 0,
  tiltY: 0,
  width: 0,
  height: 0,
  twist: 0,
  pointerType: null
};
var keys = Object.keys(defaultState);
function usePointer(options = {}) {
  const {
    target = defaultWindow
  } = options;
  const isInside = ref(false);
  const state = ref(options.initialValue || {});
  Object.assign(state.value, defaultState, state.value);
  const handler = (event) => {
    isInside.value = true;
    if (options.pointerTypes && !options.pointerTypes.includes(event.pointerType))
      return;
    state.value = objectPick(event, keys, false);
  };
  if (target) {
    const listenerOptions = { passive: true };
    useEventListener(target, ["pointerdown", "pointermove", "pointerup"], handler, listenerOptions);
    useEventListener(target, "pointerleave", () => isInside.value = false, listenerOptions);
  }
  return {
    ...toRefs2(state),
    isInside
  };
}
var DEFAULT_UNITS = [
  { max: 6e4, value: 1e3, name: "second" },
  { max: 276e4, value: 6e4, name: "minute" },
  { max: 72e6, value: 36e5, name: "hour" },
  { max: 5184e5, value: 864e5, name: "day" },
  { max: 24192e5, value: 6048e5, name: "week" },
  { max: 28512e6, value: 2592e6, name: "month" },
  { max: Number.POSITIVE_INFINITY, value: 31536e6, name: "year" }
];
var _TransitionPresets = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
var TransitionPresets = Object.assign({}, { linear: identity }, _TransitionPresets);
function useWindowSize(options = {}) {
  const {
    window: window2 = defaultWindow,
    initialWidth = Number.POSITIVE_INFINITY,
    initialHeight = Number.POSITIVE_INFINITY,
    listenOrientation = true,
    includeScrollbar = true
  } = options;
  const width = ref(initialWidth);
  const height = ref(initialHeight);
  const update = () => {
    if (window2) {
      if (includeScrollbar) {
        width.value = window2.innerWidth;
        height.value = window2.innerHeight;
      } else {
        width.value = window2.document.documentElement.clientWidth;
        height.value = window2.document.documentElement.clientHeight;
      }
    }
  };
  update();
  tryOnMounted(update);
  useEventListener("resize", update, { passive: true });
  if (listenOrientation) {
    const matches = useMediaQuery("(orientation: portrait)");
    watch(matches, () => update());
  }
  return { width, height };
}

// node_modules/@tresjs/core/dist/tres.js
var je = Object.defineProperty;
var He = (e, r, t) => r in e ? je(e, r, { enumerable: true, configurable: true, writable: true, value: t }) : e[r] = t;
var J = (e, r, t) => (He(e, typeof r != "symbol" ? r + "" : r, t), t);
var xt = "@tresjs/core";
var Pt = "module";
var kt = "3.7.0";
var At = "pnpm@8.10.2";
var Tt = "Declarative ThreeJS using Vue Components";
var Lt = "Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)";
var Ot = "MIT";
var Dt = [
  "vue",
  "3d",
  "threejs",
  "three",
  "threejs-vue"
];
var Bt = false;
var jt = {
  ".": {
    types: "./dist/index.d.ts",
    require: "./dist/tres.umd.cjs",
    import: "./dist/tres.js"
  },
  "./components": {
    types: "./dist/components/index.d.ts"
  },
  "./composables": {
    types: "./dist/composables/index.d.ts"
  },
  "./types": {
    types: "./dist/types/index.d.ts"
  },
  "./utils": {
    types: "./dist/utils/index.d.ts"
  },
  "./*": "./*"
};
var Ht = "./dist/tres.js";
var Rt = "./dist/tres.js";
var $t = "./dist/index.d.ts";
var It = [
  "dist",
  "*.d.ts"
];
var zt = {
  access: "public"
};
var Nt = {
  dev: "cd playground && npm run dev",
  build: "vite build",
  playground: "cd playground && npm run dev",
  test: "vitest",
  "test:ci": "vitest run",
  "test:ui": "vitest --ui",
  release: "release-it",
  coverage: "vitest run --coverage",
  lint: "eslint . --ext .js,.jsx,.ts,.tsx,.vue",
  "docs:dev": "vitepress dev docs",
  "docs:build": "vitepress build docs",
  "docs:serve": "vitepress serve docs",
  "docs:preview": "vitepress preview docs",
  "docs:contributors": "esno scripts/update-contributors.ts"
};
var Vt = {
  three: ">=0.133",
  vue: ">=3.3"
};
var Wt = {
  "@alvarosabu/utils": "^3.1.1",
  "@vueuse/core": "^10.7.0"
};
var Ut = {
  "@release-it/conventional-changelog": "^8.0.1",
  "@stackblitz/sdk": "^1.9.0",
  "@tresjs/cientos": "3.6.0",
  "@tresjs/eslint-config-vue": "^0.2.1",
  "@types/three": "^0.159.0",
  "@typescript-eslint/eslint-plugin": "^6.14.0",
  "@typescript-eslint/parser": "^6.14.0",
  "@vitejs/plugin-vue": "^4.5.2",
  "@vitest/coverage-c8": "^0.33.0",
  "@vitest/ui": "^1.0.4",
  "@vue/test-utils": "^2.4.3",
  eslint: "^8.55.0",
  "eslint-plugin-vue": "^9.19.2",
  esno: "^4.0.0",
  gsap: "^3.12.3",
  jsdom: "^23.0.1",
  kolorist: "^1.8.0",
  ohmyfetch: "^0.4.21",
  pathe: "^1.1.1",
  "release-it": "^17.0.1",
  "rollup-plugin-analyzer": "^4.0.0",
  "rollup-plugin-copy": "^3.5.0",
  "rollup-plugin-visualizer": "^5.11.0",
  three: "^0.159.0",
  unocss: "^0.58.0",
  unplugin: "^1.5.1",
  "unplugin-vue-components": "^0.26.0",
  vite: "^5.0.8",
  "vite-plugin-banner": "^0.7.1",
  "vite-plugin-dts": "3.6.4",
  "vite-plugin-inspect": "^0.8.1",
  "vite-plugin-require-transform": "^1.0.21",
  "vite-svg-loader": "^5.1.0",
  vitepress: "1.0.0-rc.31",
  vitest: "^1.0.4",
  vue: "^3.3.11",
  "vue-demi": "^0.14.6"
};
var Ft = {
  name: xt,
  type: Pt,
  version: kt,
  packageManager: At,
  description: Tt,
  author: Lt,
  license: Ot,
  keywords: Dt,
  sideEffects: Bt,
  exports: jt,
  main: Ht,
  module: Rt,
  types: $t,
  files: It,
  publishConfig: zt,
  scripts: Nt,
  peerDependencies: Vt,
  dependencies: Wt,
  devDependencies: Ut
};
var Gt = ({ sizes: e, scene: r }) => {
  const t = ref([]), n = computed(
    () => t.value[0]
  ), s = (i, l = false) => {
    t.value.some(({ uuid: c }) => c === i.uuid) || (l ? o(i) : t.value.push(i));
  }, a = (i) => {
    t.value = t.value.filter(({ uuid: l }) => l !== i.uuid);
  }, o = (i) => {
    const l = i instanceof Camera ? i : t.value.find((p) => p.uuid === i);
    if (!l)
      return;
    const c = t.value.filter(({ uuid: p }) => p !== l.uuid);
    t.value = [l, ...c];
  };
  return watchEffect(() => {
    e.aspectRatio.value && t.value.forEach((i) => {
      i instanceof PerspectiveCamera && (i.aspect = e.aspectRatio.value), (i instanceof PerspectiveCamera || i instanceof OrthographicCamera) && i.updateProjectionMatrix();
    });
  }), r.userData.tres__registerCamera = s, r.userData.tres__deregisterCamera = a, onUnmounted(() => {
    t.value = [];
  }), {
    camera: n,
    cameras: t,
    registerCamera: s,
    deregisterCamera: a,
    setCameraActive: o
  };
};
var be = createEventHook();
var _e = createEventHook();
var ee = createEventHook();
var j = new Clock();
var W = 0;
var U = 0;
var { pause: Jt, resume: Qt, isActive: Yt } = useRafFn(
  () => {
    be.trigger({ delta: W, elapsed: U, clock: j }), _e.trigger({ delta: W, elapsed: U, clock: j }), ee.trigger({ delta: W, elapsed: U, clock: j });
  },
  { immediate: false }
);
ee.on(() => {
  W = j.getDelta(), U = j.getElapsedTime();
});
var te = () => ({
  onBeforeLoop: be.on,
  onLoop: _e.on,
  onAfterLoop: ee.on,
  pause: Jt,
  resume: Qt,
  isActive: Yt
});
var Vr = true;
var le = "[TresJS ▲ ■ ●] ";
function T() {
  function e(n, s) {
    console.error(`${le} ${n}`, s || "");
  }
  function r(n) {
    console.warn(`${le} ${n}`);
  }
  function t(n, s) {
  }
  return {
    logError: e,
    logWarning: r,
    logMessage: t
  };
}
function Wr(e) {
  return typeof e == "number" ? [e, e, e] : e instanceof Vector3 ? [e.x, e.y, e.z] : e;
}
function qt(e) {
  return e instanceof Color ? e : Array.isArray(e) ? new Color(...e) : new Color(e);
}
var Kt = class extends Mesh {
  constructor(...t) {
    super(...t);
    J(this, "type", "HightlightMesh");
    J(this, "createTime");
    this.createTime = Date.now();
  }
  onBeforeRender() {
    const n = (Date.now() - this.createTime) / 1e3, o = 1 + 0.07 * Math.sin(2.5 * n);
    this.scale.set(o, o, o);
  }
};
var Ee = (e, r) => {
  for (const t of Object.keys(r))
    r[t] instanceof Object && Object.assign(r[t], Ee(e[t], r[t]));
  return Object.assign(e || {}, r), e;
};
var Xt = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
var Zt = er(Xt);
function ue(e) {
  return e && e.nodeType === 1;
}
function I(e) {
  return e.replace(/-([a-z])/g, (r, t) => t.toUpperCase());
}
function er(e, r) {
  const t = /* @__PURE__ */ Object.create(null), n = e.split(",");
  for (let s = 0; s < n.length; s++)
    t[n[s]] = true;
  return r ? (s) => !!t[s.toLowerCase()] : (s) => !!t[s];
}
var tr = (e, r) => {
  const t = /* @__PURE__ */ new Set(), n = [];
  for (const s of e) {
    const a = r(s);
    t.has(a) || (t.add(a), n.push(s));
  }
  return n;
};
var ce = (e, r) => {
  if (!r)
    return;
  const t = Array.isArray(r) ? r : r.match(/([^[.\]])+/g);
  return t == null ? void 0 : t.reduce((n, s) => n && n[s], e);
};
var rr = (e, r, t) => {
  const n = Array.isArray(r) ? r : r.match(/([^[.\]])+/g);
  n && n.reduce((s, a, o) => (s[a] === void 0 && (s[a] = {}), o === n.length - 1 && (s[a] = t), s[a]), e);
};
function Me(e, r) {
  if (ue(e) && ue(r)) {
    const s = e.attributes, a = r.attributes;
    return s.length !== a.length ? false : Array.from(s).every(({ name: o, value: i }) => r.getAttribute(o) === i);
  }
  if (e === r)
    return true;
  if (e === null || typeof e != "object" || r === null || typeof r != "object")
    return false;
  const t = Object.keys(e), n = Object.keys(r);
  if (t.length !== n.length)
    return false;
  for (const s of t)
    if (!n.includes(s) || !Me(e[s], r[s]))
      return false;
  return true;
}
function nr(e, r) {
  if (!Array.isArray(e) || !Array.isArray(r) || e.length !== r.length)
    return false;
  for (let t = 0; t < e.length; t++)
    if (!Me(e[t], r[t]))
      return false;
  return true;
}
var or = Array.isArray;
function sr(e, r, t, n) {
  const s = (l) => {
    if (l.uuid === r)
      return l;
    for (const c of l.children) {
      const p = s(c);
      if (p)
        return p;
    }
  }, a = s(e);
  if (!a) {
    console.warn("Object with UUID not found in the scene.");
    return;
  }
  let o = a;
  for (let l = 0; l < t.length - 1; l++)
    if (o[t[l]] !== void 0)
      o = o[t[l]];
    else {
      console.warn(`Property path is not valid: ${t.join(".")}`);
      return;
    }
  const i = t[t.length - 1];
  o[i] !== void 0 ? o[i] = n : console.warn(`Property path is not valid: ${t.join(".")}`);
}
function ir(e) {
  const r = new MeshBasicMaterial({
    color: 11003607,
    // Highlight color, e.g., yellow
    transparent: true,
    opacity: 0.2,
    depthTest: false,
    // So the highlight is always visible
    side: DoubleSide
    // To e
  });
  return new Kt(e.geometry.clone(), r);
}
function Ce(e) {
  var t;
  let r = e.value;
  return e.value && ((t = e.value) != null && t.isMesh) && (r = e.value.position), Array.isArray(e.value) && (r = new Vector3(...r)), r;
}
var ar = Number.parseInt(REVISION.replace("dev", ""));
var z = {
  realistic: {
    shadows: true,
    physicallyCorrectLights: true,
    outputColorSpace: SRGBColorSpace,
    toneMapping: ACESFilmicToneMapping,
    toneMappingExposure: 3,
    shadowMap: {
      enabled: true,
      type: PCFSoftShadowMap
    }
  }
};
function lr({
  scene: e,
  canvas: r,
  options: t,
  disableRender: n,
  contextParts: { sizes: s, camera: a }
}) {
  const o = computed(() => ({
    alpha: toValue(t.alpha),
    depth: toValue(t.depth),
    canvas: unrefElement(r),
    context: toValue(t.context),
    stencil: toValue(t.stencil),
    antialias: toValue(t.antialias) === void 0 ? true : toValue(t.antialias),
    precision: toValue(t.precision),
    powerPreference: toValue(t.powerPreference),
    premultipliedAlpha: toValue(t.premultipliedAlpha),
    preserveDrawingBuffer: toValue(t.preserveDrawingBuffer),
    logarithmicDepthBuffer: toValue(t.logarithmicDepthBuffer),
    failIfMajorPerformanceCaveat: toValue(t.failIfMajorPerformanceCaveat)
  })), i = shallowRef(new WebGLRenderer(o.value));
  watch(o, () => {
    i.value.dispose(), i.value = new WebGLRenderer(o.value);
  }), watchEffect(() => {
    i.value.setSize(s.width.value, s.height.value);
  });
  const { pixelRatio: l } = useDevicePixelRatio();
  watchEffect(() => {
    i.value.setPixelRatio(l.value);
  });
  const { logError: c } = T(), d = (() => {
    const f = new WebGLRenderer(), h2 = {
      shadowMap: {
        enabled: f.shadowMap.enabled,
        type: f.shadowMap.type
      },
      toneMapping: f.toneMapping,
      toneMappingExposure: f.toneMappingExposure,
      outputColorSpace: f.outputColorSpace
    };
    return f.dispose(), h2;
  })();
  watchEffect(() => {
    const f = toValue(t.preset);
    f && (f in z || c(`Renderer Preset must be one of these: ${Object.keys(z).join(", ")}`), Ee(i.value, z[f]));
    const h2 = (C, S) => {
      const b = toValue(C), x = () => {
        if (f)
          return ce(z[f], S);
      };
      if (b !== void 0)
        return b;
      const g = x();
      return g !== void 0 ? g : ce(d, S);
    }, _ = (C, S) => rr(i.value, S, h2(C, S));
    _(t.shadows, "shadowMap.enabled"), _(t.toneMapping, "toneMapping"), _(t.shadowMapType, "shadowMap.type"), ar < 150 && _(!t.useLegacyLights, "physicallyCorrectLights"), _(t.outputColorSpace, "outputColorSpace"), _(t.toneMappingExposure, "toneMappingExposure");
    const w = h2(t.clearColor, "clearColor");
    w && i.value.setClearColor(
      w ? qt(w) : new Color(0)
      // default clear color is not easily/efficiently retrievable from three
    );
  });
  const { pause: u, resume: m, onLoop: y } = te();
  return y(() => {
    a.value && !toValue(n) && i.value.render(e, a.value);
  }), m(), onUnmounted(() => {
    u(), i.value.dispose(), i.value.forceContextLoss();
  }), {
    renderer: i
  };
}
var de = (e) => typeof e == "function";
var ur = (e) => !!e && e.constructor === Array;
function cr(e) {
  const r = { nodes: {}, materials: {} };
  return e && e.traverse((t) => {
    t.name && (r.nodes[t.name] = t), t.material && !r.materials[t.material.name] && (r.materials[t.material.name] = t.material);
  }), r;
}
async function Ur(e, r, t, n, s) {
  const { logError: a } = T(), o = new e();
  s && s(o), t && t(o);
  const l = (Array.isArray(r) ? r : [r]).map(
    (c) => new Promise((p, d) => {
      o.load(
        c,
        (u) => {
          u.scene && Object.assign(u, cr(u.scene)), p(u);
        },
        n,
        (u) => d(a("[useLoader] - Failed to load resource", u))
      );
    })
  );
  return ur(r) ? await Promise.all(l) : await l[0];
}
async function Fr(e) {
  const r = new LoadingManager(), t = new TextureLoader(r), n = (s) => new Promise((a, o) => {
    t.load(
      s,
      (i) => a(i),
      () => null,
      () => {
        o(new Error("[useTextures] - Failed to load texture"));
      }
    );
  });
  if (or(e)) {
    const s = await Promise.all(e.map((a) => n(a)));
    return e.length > 1 ? s : s[0];
  } else {
    const {
      map: s,
      displacementMap: a,
      normalMap: o,
      roughnessMap: i,
      metalnessMap: l,
      aoMap: c,
      alphaMap: p,
      matcap: d
    } = e;
    return {
      map: s ? await n(s) : null,
      displacementMap: a ? await n(a) : null,
      normalMap: o ? await n(o) : null,
      roughnessMap: i ? await n(i) : null,
      metalnessMap: l ? await n(l) : null,
      aoMap: c ? await n(c) : null,
      alphaMap: p ? await n(p) : null,
      matcap: d ? await n(d) : null
    };
  }
}
var dr = (e, { renderer: r, camera: t, raycaster: n }) => {
  const s = computed(() => r.value.domElement), { x: a, y: o } = usePointer({ target: s }), { width: i, height: l, top: c, left: p } = useElementBounding(s), d = ({ x: g, y: E }) => {
    if (s.value)
      return {
        x: (g - p.value) / i.value * 2 - 1,
        y: -((E - c.value) / l.value) * 2 + 1
      };
  }, u = ({ x: g, y: E }) => {
    if (t.value)
      return n.value.setFromCamera(new Vector2(g, E), t.value), n.value.intersectObjects(e.value, false);
  }, m = (g) => {
    const E = d({
      x: (g == null ? void 0 : g.clientX) ?? a.value,
      y: (g == null ? void 0 : g.clientY) ?? o.value
    });
    return E ? u(E) || [] : [];
  }, y = computed(() => m()), f = createEventHook(), h2 = createEventHook(), _ = (g, E) => {
    g.trigger({ event: E, intersects: m(E) });
  }, w = (g) => {
    _(h2, g);
  };
  let C;
  const S = (g) => {
    var E;
    C = (E = m(g)[0]) == null ? void 0 : E.object;
  }, b = (g) => {
    var E;
    g instanceof PointerEvent && C === ((E = m(g)[0]) == null ? void 0 : E.object) && _(f, g);
  }, x = (g) => h2.trigger({ event: g, intersects: [] });
  return s.value.addEventListener("pointerup", b), s.value.addEventListener("pointerdown", S), s.value.addEventListener("pointermove", w), s.value.addEventListener("pointerleave", x), onUnmounted(() => {
    s != null && s.value && (s.value.removeEventListener("pointerup", b), s.value.removeEventListener("pointerdown", S), s.value.removeEventListener("pointermove", w), s.value.removeEventListener("pointerleave", x));
  }), {
    intersects: y,
    onClick: (g) => f.on(g).off,
    onPointerMove: (g) => h2.on(g).off
  };
};
function Gr() {
  const { logWarning: e } = T();
  function r(a, o, i) {
    let l = null;
    return a.traverse((c) => {
      c[o] === i && (l = c);
    }), l || e(`Child with ${o} '${i}' not found.`), l;
  }
  function t(a, o, i) {
    const l = [];
    return a.traverse((c) => {
      c[o].includes(i) && l.push(c);
    }), l.length || e(`Children with ${o} '${i}' not found.`), l;
  }
  function n(a, o) {
    return r(a, "name", o);
  }
  function s(a, o) {
    return t(a, "name", o);
  }
  return {
    seek: r,
    seekByName: n,
    seekAll: t,
    seekAllByName: s
  };
}
var fr = ({ scene: e, contextParts: r }) => {
  const t = reactive({
    click: /* @__PURE__ */ new Map(),
    pointerMove: /* @__PURE__ */ new Map(),
    pointerEnter: /* @__PURE__ */ new Map(),
    pointerLeave: /* @__PURE__ */ new Map()
  }), n = ref(/* @__PURE__ */ new Set()), s = (u) => {
    n.value.add(u);
  }, a = (u) => {
    n.value.delete(u);
  }, o = (u) => {
    Object.values(t).forEach((m) => m.delete(u)), a(u);
  }, i = (u) => {
    const { onClick: m, onPointerMove: y, onPointerEnter: f, onPointerLeave: h2 } = u;
    m && t.click.set(u, m), y && t.pointerMove.set(u, y), f && t.pointerEnter.set(u, f), h2 && t.pointerLeave.set(u, h2);
  };
  e.userData.tres__registerAtPointerEventHandler = i, e.userData.tres__deregisterAtPointerEventHandler = o, e.userData.tres__registerBlockingObjectAtPointerEventHandler = s, e.userData.tres__deregisterBlockingObjectAtPointerEventHandler = a;
  const l = computed(
    () => tr(
      [
        ...Array.from(n.value),
        ...Object.values(t).map((u) => Array.from(u.keys())).flat()
      ],
      ({ uuid: u }) => u
    )
  ), { onClick: c, onPointerMove: p } = dr(l, r);
  c(({ intersects: u, event: m }) => {
    var y;
    u.length && ((y = t.click.get(u[0].object)) == null || y(u[0], m));
  });
  let d;
  return p(({ intersects: u, event: m }) => {
    var w, C, S, b;
    const y = (w = u == null ? void 0 : u[0]) == null ? void 0 : w.object, { pointerLeave: f, pointerEnter: h2, pointerMove: _ } = t;
    d && d !== y && ((C = f.get(d)) == null || C(d, m)), y && (d !== y && ((S = h2.get(y)) == null || S(u[0], m)), (b = _.get(y)) == null || b(u[0], m)), d = y || null;
  }), {
    registerObject: i,
    deregisterObject: o
  };
};
function Se(e) {
  let r = 0;
  return e.traverse((t) => {
    if (t.isMesh && t.geometry) {
      const n = t.geometry, s = n.attributes.position.count * 3 * Float32Array.BYTES_PER_ELEMENT, a = n.index ? n.index.count * Uint32Array.BYTES_PER_ELEMENT : 0, o = n.attributes.normal ? n.attributes.normal.count * 3 * Float32Array.BYTES_PER_ELEMENT : 0, i = n.attributes.uv ? n.attributes.uv.count * 2 * Float32Array.BYTES_PER_ELEMENT : 0, l = s + a + o + i;
      r += l;
    }
  }), r;
}
function pr(e) {
  return (e / 1024).toFixed(2);
}
var X = ref({});
var re = (e) => Object.assign(X.value, e);
function mr({
  scene: e,
  canvas: r,
  windowSize: t,
  disableRender: n,
  rendererOptions: s
}) {
  const a = computed(
    () => toValue(t) ? useWindowSize() : useElementSize(toValue(r).parentElement)
  ), o = shallowRef({
    width: 0,
    height: 0
  }), i = refDebounced(o, 10), l = watchEffect(() => {
    o.value = {
      width: a.value.width.value,
      height: a.value.height.value
    };
  }), c = computed(() => i.value.width / i.value.height), p = {
    height: computed(() => i.value.height),
    width: computed(() => i.value.width),
    aspectRatio: c
  }, d = shallowRef(e), {
    camera: u,
    cameras: m,
    registerCamera: y,
    deregisterCamera: f,
    setCameraActive: h2
  } = Gt({ sizes: p, scene: e }), { renderer: _ } = lr(
    {
      scene: e,
      canvas: r,
      options: s,
      contextParts: { sizes: p, camera: u },
      disableRender: n
    }
  ), w = {
    sizes: p,
    scene: d,
    camera: u,
    cameras: readonly(m),
    renderer: _,
    raycaster: shallowRef(new Raycaster()),
    controls: ref(null),
    perf: {
      maxFrames: 160,
      fps: {
        value: 0,
        accumulator: []
      },
      memory: {
        currentMem: 0,
        allocatedMem: 0,
        accumulator: []
      }
    },
    extend: re,
    registerCamera: y,
    setCameraActive: h2,
    deregisterCamera: f
  };
  provide("useTres", w);
  const C = 100, S = useFps({ every: C }), { isSupported: b, memory: x } = useMemory({ interval: C }), g = 160;
  let E = performance.now();
  const Te = ({ timestamp: $ }) => {
    w.scene.value && (w.perf.memory.allocatedMem = Se(w.scene.value)), $ - E >= C && (E = $, w.perf.fps.accumulator.push(S.value), w.perf.fps.accumulator.length > g && w.perf.fps.accumulator.shift(), w.perf.fps.value = S.value, b.value && x.value && (w.perf.memory.accumulator.push(x.value.usedJSHeapSize / 1024 / 1024), w.perf.memory.accumulator.length > g && w.perf.memory.accumulator.shift(), w.perf.memory.currentMem = w.perf.memory.accumulator.reduce((De, Be) => De + Be, 0) / w.perf.memory.accumulator.length));
  };
  let G = 0;
  const Le = 1, { pause: Oe, resume: Rr } = useRafFn(({ delta: $ }) => {
    window.__TRES__DEVTOOLS__ && (Te({ timestamp: performance.now() }), G += $, G >= Le && (window.__TRES__DEVTOOLS__.cb(w), G = 0));
  }, { immediate: true });
  return onUnmounted(() => {
    l(), Oe();
  }), w;
}
function gr() {
  const e = inject("useTres");
  if (!e)
    throw new Error("useTresContext must be used together with useTresContextProvider");
  return e;
}
var Jr = gr;
var v = null;
var { logError: fe } = T();
var Y = [
  "onClick",
  "onPointerMove",
  "onPointerEnter",
  "onPointerLeave"
];
var vr = {
  createElement(e, r, t, n) {
    var o, i;
    if (n || (n = {}), n.args || (n.args = []), e === "template" || Zt(e))
      return null;
    let s = e.replace("Tres", ""), a;
    if (e === "primitive") {
      (n == null ? void 0 : n.object) === void 0 && fe("Tres primitives need a prop 'object'");
      const l = n.object;
      s = l.type, a = Object.assign(l, { type: s, attach: n.attach, primitive: true });
    } else {
      const l = X.value[s];
      l || fe(`${s} is not defined on the THREE namespace. Use extend to add it to the catalog.`), a = new l(...n.args);
    }
    return a.isCamera && (n != null && n.position || a.position.set(3, 3, 3), n != null && n.lookAt || a.lookAt(0, 0, 0)), (n == null ? void 0 : n.attach) === void 0 && (a.isMaterial ? a.attach = "material" : a.isBufferGeometry && (a.attach = "geometry")), a.isObject3D && ((o = n == null ? void 0 : n.material) != null && o.isMaterial && (a.userData.tres__materialViaProp = true), (i = n == null ? void 0 : n.geometry) != null && i.isBufferGeometry && (a.userData.tres__geometryViaProp = true)), a.userData = {
      ...a.userData,
      tres__name: s
    }, a;
  },
  insert(e, r) {
    var n, s, a, o;
    r && r.isScene && (v = r);
    const t = r || v;
    if (e != null && e.isObject3D) {
      if (e != null && e.isCamera) {
        if (!(v != null && v.userData.tres__registerCamera))
          throw "could not find tres__registerCamera on scene's userData";
        (s = v == null ? void 0 : (n = v.userData).tres__registerCamera) == null || s.call(n, e);
      }
      if (e && Y.some((i) => e[i])) {
        if (!(v != null && v.userData.tres__registerAtPointerEventHandler))
          throw "could not find tres__registerAtPointerEventHandler on scene's userData";
        (o = v == null ? void 0 : (a = v.userData).tres__registerAtPointerEventHandler) == null || o.call(a, e);
      }
    }
    e != null && e.isObject3D && (t != null && t.isObject3D) ? (t.add(e), e.dispatchEvent({ type: "added" })) : e != null && e.isFog ? t.fog = e : typeof (e == null ? void 0 : e.attach) == "string" && (e.__previousAttach = e[t == null ? void 0 : t.attach], t && (t[e.attach] = e));
  },
  remove(e) {
    var r, t;
    if (e) {
      if (e.isObject3D) {
        const n = e, s = (c) => {
          var d, u;
          const p = c;
          c.userData.tres__materialViaProp || ((d = p.material) == null || d.dispose(), p.material = void 0), c.userData.tres__geometryViaProp || ((u = p.geometry) == null || u.dispose(), p.geometry = void 0);
        }, a = v == null ? void 0 : v.userData.tres__deregisterAtPointerEventHandler, o = v == null ? void 0 : v.userData.tres__deregisterBlockingObjectAtPointerEventHandler, i = (c) => {
          var p, d;
          if (!o)
            throw "could not find tres__deregisterBlockingObjectAtPointerEventHandler on scene's userData";
          if ((d = v == null ? void 0 : (p = v.userData).tres__deregisterBlockingObjectAtPointerEventHandler) == null || d.call(p, c), !a)
            throw "could not find tres__deregisterAtPointerEventHandler on scene's userData";
          c && Y.some((u) => c[u]) && (a == null || a(c));
        }, l = (c) => {
          const p = v == null ? void 0 : v.userData.tres__deregisterCamera;
          if (!p)
            throw "could not find tres__deregisterCamera on scene's userData";
          c.isCamera && (p == null || p(c));
        };
        (r = e.removeFromParent) == null || r.call(e), n.traverse((c) => {
          s(c), l(c), i == null || i(c);
        }), s(n), l(n), i == null || i(n);
      }
      (t = e.dispose) == null || t.call(e);
    }
  },
  patchProp(e, r, t, n) {
    var s, a, o, i;
    if (e) {
      let l = e, c = r;
      if (e.isObject3D && c === "blocks-pointer-events") {
        n || n === "" ? (a = v == null ? void 0 : (s = v.userData).tres__registerBlockingObjectAtPointerEventHandler) == null || a.call(s, e) : (i = v == null ? void 0 : (o = v.userData).tres__deregisterBlockingObjectAtPointerEventHandler) == null || i.call(o, e);
        return;
      }
      let p = I(c), d = l == null ? void 0 : l[p];
      if (c === "args") {
        const m = e, y = t ?? [], f = n ?? [], h2 = e.userData.tres__name || e.type;
        h2 && y.length && !nr(y, f) && (l = Object.assign(m, new X.value[h2](...n)));
        return;
      }
      if (l.type === "BufferGeometry") {
        if (c === "args")
          return;
        l.setAttribute(
          I(c),
          new BufferAttribute(...n)
        );
        return;
      }
      if (c.includes("-") && d === void 0) {
        const m = c.split("-");
        d = m.reduce((y, f) => y[I(f)], l), c = m.pop(), p = c.toLowerCase(), d != null && d.set || (l = m.reduce((y, f) => y[I(f)], l));
      }
      let u = n;
      if (u === "" && (u = true), de(d)) {
        Y.includes(r) || (Array.isArray(u) ? e[p](...u) : e[p](u));
        return;
      }
      !(d != null && d.set) && !de(d) ? l[p] = u : d.constructor === u.constructor && (d != null && d.copy) ? d == null || d.copy(u) : Array.isArray(u) ? d.set(...u) : !d.isColor && d.setScalar ? d.setScalar(u) : d.set(u);
    }
  },
  parentNode(e) {
    return (e == null ? void 0 : e.parent) || null;
  },
  createText: () => void 0,
  createComment: () => void 0,
  setText: () => void 0,
  setElementText: () => void 0,
  nextSibling: () => void 0,
  querySelector: () => void 0,
  setScopeId: () => void 0,
  cloneNode: () => void 0,
  insertStaticContent: () => void 0
};
var { render: hr } = createRenderer(vr);
re(three_module_exports);
function yr() {
  return xe().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function xe() {
  return typeof navigator < "u" && typeof window < "u" ? window : typeof global < "u" ? global : {};
}
var wr = typeof Proxy == "function";
var br = "devtools-plugin:setup";
var _r = "plugin:settings:set";
var L;
var Z;
function Er() {
  var e;
  return L !== void 0 || (typeof window < "u" && window.performance ? (L = true, Z = window.performance) : typeof global < "u" && (!((e = global.perf_hooks) === null || e === void 0) && e.performance) ? (L = true, Z = global.perf_hooks.performance) : L = false), L;
}
function Mr() {
  return Er() ? Z.now() : Date.now();
}
var Cr = class {
  constructor(r, t) {
    this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = r, this.hook = t;
    const n = {};
    if (r.settings)
      for (const o in r.settings) {
        const i = r.settings[o];
        n[o] = i.defaultValue;
      }
    const s = `__vue-devtools-plugin-settings__${r.id}`;
    let a = Object.assign({}, n);
    try {
      const o = localStorage.getItem(s), i = JSON.parse(o);
      Object.assign(a, i);
    } catch {
    }
    this.fallbacks = {
      getSettings() {
        return a;
      },
      setSettings(o) {
        try {
          localStorage.setItem(s, JSON.stringify(o));
        } catch {
        }
        a = o;
      },
      now() {
        return Mr();
      }
    }, t && t.on(_r, (o, i) => {
      o === this.plugin.id && this.fallbacks.setSettings(i);
    }), this.proxiedOn = new Proxy({}, {
      get: (o, i) => this.target ? this.target.on[i] : (...l) => {
        this.onQueue.push({
          method: i,
          args: l
        });
      }
    }), this.proxiedTarget = new Proxy({}, {
      get: (o, i) => this.target ? this.target[i] : i === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(i) ? (...l) => (this.targetQueue.push({
        method: i,
        args: l,
        resolve: () => {
        }
      }), this.fallbacks[i](...l)) : (...l) => new Promise((c) => {
        this.targetQueue.push({
          method: i,
          args: l,
          resolve: c
        });
      })
    });
  }
  async setRealTarget(r) {
    this.target = r;
    for (const t of this.onQueue)
      this.target.on[t.method](...t.args);
    for (const t of this.targetQueue)
      t.resolve(await this.target[t.method](...t.args));
  }
};
function Sr(e, r) {
  const t = e, n = xe(), s = yr(), a = wr && t.enableEarlyProxy;
  if (s && (n.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !a))
    s.emit(br, e, r);
  else {
    const o = a ? new Cr(t, s) : null;
    (n.__VUE_DEVTOOLS_PLUGINS__ = n.__VUE_DEVTOOLS_PLUGINS__ || []).push({
      pluginDescriptor: t,
      setupFn: r,
      proxy: o
    }), o && r(o.proxiedTarget);
  }
}
function xr(e, r) {
  const t = `▲ ■ ●${e}`;
  typeof __VUE_DEVTOOLS_TOAST__ == "function" ? __VUE_DEVTOOLS_TOAST__(t, r) : r === "error" ? console.error(t) : r === "warn" ? console.warn(t) : console.log(t);
}
var Pe = (e) => {
  const r = {
    id: e.uuid,
    label: e.type,
    children: [],
    tags: []
  };
  e.name !== "" && r.tags.push({
    label: e.name,
    textColor: 5750629,
    backgroundColor: 15793395
  });
  const t = Se(e);
  return t > 0 && r.tags.push({
    label: `${pr(t)} KB`,
    textColor: 15707189,
    backgroundColor: 16775644,
    tooltip: "Memory usage"
  }), e.type.includes("Light") && (r.tags.push({
    label: `${e.intensity}`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Intensity"
  }), r.tags.push({
    label: `#${e.color.getHexString()}`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Color"
  })), e.type.includes("Camera") && (r.tags.push({
    label: `${e.fov}°`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Field of view"
  }), r.tags.push({
    // eslint-disable-next-line max-len
    label: `x: ${Math.round(e.position.x)} y: ${Math.round(e.position.y)} z: ${Math.round(e.position.z)}`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Position"
  })), r;
};
function ke(e, r) {
  e.children.forEach((t) => {
    if (t.type === "HightlightMesh")
      return;
    const n = Pe(t);
    r.children.push(n), ke(t, n);
  });
}
var Pr = [];
var B = "tres:inspector";
var kr = reactive({
  sceneGraph: null
});
function Ar(e, r) {
  Sr(
    {
      id: "dev.esm.tres",
      label: "TresJS 🪐",
      logo: "https://raw.githubusercontent.com/Tresjs/tres/main/public/favicon.svg",
      packageName: "tresjs",
      homepage: "https://tresjs.org",
      componentStateTypes: Pr,
      app: e
    },
    (t) => {
      typeof t.now != "function" && xr(
        // eslint-disable-next-line max-len
        "You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."
      ), t.addInspector({
        id: B,
        label: "TresJS 🪐",
        icon: "account_tree",
        treeFilterPlaceholder: "Search instances"
      }), setInterval(() => {
        t.sendInspectorTree(B);
      }, 1e3), setInterval(() => {
        t.notifyComponentUpdate();
      }, 5e3), t.on.getInspectorTree((a) => {
        if (a.inspectorId === B) {
          const o = Pe(r.scene.value);
          ke(r.scene.value, o), kr.sceneGraph = o, a.rootNodes = [o];
        }
      });
      let n = null, s = null;
      t.on.getInspectorState((a) => {
        if (a.inspectorId === B) {
          const [o] = r.scene.value.getObjectsByProperty("uuid", a.nodeId);
          if (!o)
            return;
          if (s && n && n.parent && s.remove(n), o.isMesh) {
            const i = ir(o);
            o.add(i), n = i, s = o;
          }
          a.state = {
            object: [
              {
                key: "uuid",
                editable: true,
                value: o.uuid
              },
              {
                key: "name",
                editable: true,
                value: o.name
              },
              {
                key: "type",
                editable: true,
                value: o.type
              },
              {
                key: "position",
                editable: true,
                value: o.position
              },
              {
                key: "rotation",
                editable: true,
                value: o.rotation
              },
              {
                key: "scale",
                editable: true,
                value: o.scale
              },
              {
                key: "geometry",
                value: o.geometry
              },
              {
                key: "material",
                value: o.material
              },
              {
                key: "color",
                editable: true,
                value: o.color
              },
              {
                key: "intensity",
                editable: true,
                value: o.intensity
              },
              {
                key: "castShadow",
                editable: true,
                value: o.castShadow
              },
              {
                key: "receiveShadow",
                editable: true,
                value: o.receiveShadow
              },
              {
                key: "frustumCulled",
                editable: true,
                value: o.frustumCulled
              },
              {
                key: "matrixAutoUpdate",
                editable: true,
                value: o.matrixAutoUpdate
              },
              {
                key: "matrixWorldNeedsUpdate",
                editable: true,
                value: o.matrixWorldNeedsUpdate
              },
              {
                key: "matrixWorld",
                value: o.matrixWorld
              },
              {
                key: "visible",
                editable: true,
                value: o.visible
              }
            ]
          };
        }
      }), t.on.editInspectorState((a) => {
        a.inspectorId === B && sr(r.scene.value, a.nodeId, a.path, a.state.value);
      });
    }
  );
}
var Tr = ["data-scene", "data-tres"];
var Lr = defineComponent({
  __name: "TresCanvas",
  props: {
    shadows: { type: Boolean, default: void 0 },
    clearColor: {},
    toneMapping: {},
    shadowMapType: {},
    useLegacyLights: { type: Boolean, default: void 0 },
    outputColorSpace: {},
    toneMappingExposure: {},
    camera: {},
    preset: {},
    windowSize: { type: Boolean, default: void 0 },
    disableRender: { type: Boolean, default: void 0 },
    context: {},
    precision: {},
    alpha: { type: Boolean, default: void 0 },
    premultipliedAlpha: { type: Boolean },
    antialias: { type: Boolean, default: void 0 },
    stencil: { type: Boolean, default: void 0 },
    preserveDrawingBuffer: { type: Boolean, default: void 0 },
    powerPreference: {},
    depth: { type: Boolean, default: void 0 },
    logarithmicDepthBuffer: { type: Boolean, default: void 0 },
    failIfMajorPerformanceCaveat: { type: Boolean, default: void 0 }
  },
  setup(e, { expose: r }) {
    var y;
    const t = e, { logWarning: n } = T(), s = ref(), a = shallowRef(new Scene()), { resume: o } = te(), i = useSlots(), l = (y = getCurrentInstance()) == null ? void 0 : y.appContext.app, c = (f) => defineComponent({
      setup() {
        var _;
        const h2 = (_ = getCurrentInstance()) == null ? void 0 : _.appContext;
        return h2 && (h2.app = l), provide("useTres", f), provide("extend", re), typeof window < "u" && Ar(h2.app, f), () => h(Fragment, null, i != null && i.default ? i.default() : []);
      }
    }), p = (f) => {
      const h2 = c(f);
      hr(h(h2), a.value);
    }, d = (f, h2 = false) => {
      a.value.children = [], h2 && (f.renderer.value.dispose(), f.renderer.value.renderLists.dispose(), f.renderer.value.forceContextLoss()), p(f), o();
    }, u = computed(() => t.disableRender), m = shallowRef(null);
    return r({ context: m, dispose: () => d(m.value, true) }), onMounted(() => {
      const f = s;
      m.value = mr({
        scene: a.value,
        canvas: f,
        windowSize: t.windowSize,
        disableRender: u,
        rendererOptions: t
      }), fr({ scene: a.value, contextParts: m.value });
      const { registerCamera: h2, camera: _, cameras: w, deregisterCamera: C } = m.value;
      p(m.value);
      const S = () => {
        const b = new PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          1e3
        );
        b.position.set(3, 3, 3), b.lookAt(0, 0, 0), h2(b);
        const x = watchEffect(() => {
          w.value.length >= 2 && (b.removeFromParent(), C(b), x == null || x());
        });
      };
      watch(
        () => t.camera,
        (b, x) => {
          b && h2(b), x && (x.removeFromParent(), C(x));
        },
        {
          immediate: true
        }
      ), _.value || (n(
        "No camera found. Creating a default perspective camera. To have full control over a camera, please add one to the scene."
      ), S());
    }), (f, h2) => (openBlock(), createElementBlock("canvas", {
      ref_key: "canvas",
      ref: s,
      "data-scene": a.value.uuid,
      class: normalizeClass(f.$attrs.class),
      "data-tres": `tresjs ${unref(Ft).version}`,
      style: normalizeStyle({
        display: "block",
        width: "100%",
        height: "100%",
        position: f.windowSize ? "fixed" : "relative",
        top: 0,
        left: 0,
        pointerEvents: "auto",
        touchAction: "none",
        ...f.$attrs.style
      })
    }, null, 14, Tr));
  }
});
var Or = [
  "TresCanvas",
  "TresLeches",
  "TresScene"
];
var Dr = {
  template: {
    compilerOptions: {
      isCustomElement: (e) => e.startsWith("Tres") && !Or.includes(e) || e === "primitive"
    }
  }
};
var Qr = Dr;
var Yr = {
  mounted: (e, r) => {
    if (r.arg) {
      console.log(`v-log:${r.arg}`, e[r.arg]);
      return;
    }
    console.log("v-log", e);
  }
};
var Ae = class extends Line {
  constructor(r, t) {
    const n = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], s = new BufferGeometry();
    s.setAttribute("position", new Float32BufferAttribute(n, 3)), s.computeBoundingSphere();
    const a = new LineBasicMaterial({ fog: false });
    super(s, a), this.light = r, this.color = t, this.type = "RectAreaLightHelper";
    const o = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], i = new BufferGeometry();
    i.setAttribute("position", new Float32BufferAttribute(o, 3)), i.computeBoundingSphere(), this.add(new Mesh(i, new MeshBasicMaterial({ side: BackSide, fog: false })));
  }
  updateMatrixWorld() {
    if (this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1), this.color !== void 0)
      this.material.color.set(this.color), this.children[0].material.color.set(this.color);
    else {
      this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      const r = this.material.color, t = Math.max(r.r, r.g, r.b);
      t > 1 && r.multiplyScalar(1 / t), this.children[0].material.color.copy(this.material.color);
    }
    this.matrixWorld.extractRotation(this.light.matrixWorld).scale(this.scale).copyPosition(this.light.matrixWorld), this.children[0].matrixWorld.copy(this.matrixWorld);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
};
var { logWarning: pe } = T();
var N;
var A;
var Br = {
  DirectionalLight: DirectionalLightHelper,
  PointLight: PointLightHelper,
  SpotLight: SpotLightHelper,
  HemisphereLight: HemisphereLightHelper,
  RectAreaLight: Ae
};
var qr = {
  mounted: (e) => {
    if (!e.isLight) {
      pe(`${e.type} is not a light`);
      return;
    }
    N = Br[e.type], e.parent.add(new N(e, 1, e.color.getHex()));
  },
  updated: (e) => {
    A = e.parent.children.find((r) => r instanceof N), !(A instanceof Ae) && A.update();
  },
  unmounted: (e) => {
    if (!e.isLight) {
      pe(`${e.type} is not a light`);
      return;
    }
    A = e.parent.children.find((r) => r instanceof N), A && A.dispose && A.dispose(), e.parent.remove(A);
  }
};
var { logWarning: jr } = T();
var Kr = {
  updated: (e, r) => {
    const t = Ce(r);
    if (!t) {
      jr(`v-always-look-at: problem with binding value: ${r.value}`);
      return;
    }
    const { onLoop: n } = te();
    n(() => {
      e.lookAt(t);
    });
  }
};
var { logWarning: Hr } = T();
var Xr = {
  updated: (e, r) => {
    var s;
    const t = Ce(r);
    if (!t) {
      Hr(`v-distance-to: problem with binding value: ${r.value}`);
      return;
    }
    k && (k.dispose(), e.parent.remove(k));
    const n = t.clone().sub(e.position);
    n.normalize(), k = new ArrowHelper(n, e.position, e.position.distanceTo(t), 16776960), e.parent.add(k), console.table(
      [
        ["Distance:", e.position.distanceTo(t)],
        [`origin: ${e.name || e.type}`, `x:${e.position.x}, y:${e.position.y}, z:${(s = e.position) == null ? void 0 : s.z}`],
        [`Destiny: ${e.name || e.type}`, `x:${t.x}, y:${t.y}, z:${t == null ? void 0 : t.z}`]
      ]
    );
  },
  unmounted: (e) => {
    k == null || k.dispose(), e.parent.remove(k);
  }
};
var k = null;
var Zr = {
  install(e) {
    e.component("TresCanvas", Lr);
  }
};

export {
  Gt,
  te,
  Vr,
  T,
  Wr,
  qt,
  lr,
  cr,
  Ur,
  Fr,
  dr,
  Gr,
  fr,
  X,
  re,
  mr,
  gr,
  Jr,
  Lr,
  Qr,
  Yr,
  qr,
  Kr,
  Xr,
  Zr
};
//# sourceMappingURL=chunk-GVQMC772.js.map
